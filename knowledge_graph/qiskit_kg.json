{
	"nodes": [
		{
			"id": "qiskit_addon_cutting.qpd.SingleQubitQPDGate",
			"name": "qiskit_addon_cutting.qpd.SingleQubitQPDGate",
			"type": "class",
			"description": "Single qubit gate to be decomposed using quasiprobability decomposition. This gate could be part of a larger decomposition on many qubits, or it could be a standalone single gate decomposition. Initialize the single qubit QPD gate, and assign member variables."
		},
		{
			"id": "qiskit_addon_cutting.qpd.TwoQubitQPDGate",
			"name": "qiskit_addon_cutting.qpd.TwoQubitQPDGate",
			"type": "class",
			"description": "Two qubit gate to be decomposed using quasiprobability decomposition. Initialize the two qubit QPD gate. **Parameters** * **basis** (QPDBasis) – A QPDBasis to which the gate should be decomposed * **basis\\_id** (int | None) – An index to the basis to which the gate should be decomposed."
		},
		{
			"id": "qiskit_addon_cutting.utils.bitwise",
			"name": "qiskit_addon_cutting.utils.bitwise",
			"type": "module",
			"description": "Count number of set bits. **Parameters** **x** (*int*\"))"
		},
		{
			"id": "qiskit_addon_cutting.utils.simulation",
			"name": "qiskit_addon_cutting.utils.simulation",
			"type": "module",
			"description": "Return each classical outcome along with its precise probability. Circuit can contain mid-circuit, projective measurements. All gates are supported, along with measurements and reset operations. **Return type** dict\")\\[int\"), float\")] **Parameters** **qc** (*QuantumCircuit*\"))"
		},
		{
			"id": "qiskit_addon_cutting",
			"name": "qiskit_addon_cutting",
			"type": "module",
			"description": "Transform all CutWire instructions in a circuit to Move instructions marked for cutting. The returned circuit will have one newly allocated qubit for every CutWire instruction. See Sec."
		},
		{
			"id": "qiskit_addon_cutting.utils.transforms",
			"name": "qiskit_addon_cutting.utils.transforms",
			"type": "module",
			"description": "Separate the circuit into its disconnected components. If partition_labels is provided, then the circuit will be separated according to those labels."
		},
		{
			"id": "qiskit_addon_cutting.qpd.BaseQPDGate",
			"name": "qiskit_addon_cutting.qpd.BaseQPDGate",
			"type": "class",
			"description": "Base class for a gate to be decomposed using quasiprobability decomposition. Initialize the instruction, and assign member variables. **Parameters** * **name** (str) – Name of the QPD gate."
		},
		{
			"id": "qiskit_addon_cutting.instructions",
			"name": "qiskit_addon_cutting.instructions",
			"type": "module",
			"description": "qiskit_addon_cutting.instructions Quantum circuit Instructions useful for circuit cutting."
		},
		{
			"id": "qiskit_addon_cutting.qpd",
			"name": "qiskit_addon_cutting.qpd",
			"type": "module",
			"description": "Type of weight associated with a QPD sample. #### EXACT A weight given in proportion to its exact weight #### SAMPLED A weight that was determined through some sampling procedure"
		},
		{
			"id": "qiskit_addon_cutting.utils.iteration",
			"name": "qiskit_addon_cutting.utils.iteration",
			"type": "module",
			"description": "Return unique objects in iterable, by identity."
		},
		{
			"id": "qiskit_addon_cutting.instructions.Move",
			"name": "qiskit_addon_cutting.instructions.Move",
			"type": "class",
			"description": "A two-qubit instruction representing a reset of the second qubit followed by a swap."
		},
		{
			"id": "qiskit_addon_cutting.utils.observable_terms",
			"name": "qiskit_addon_cutting.utils.observable_terms",
			"type": "module",
			"description": "Inspect the contents of each observable to find and return the unique Pauli terms. **Return type** PauliList **Parameters** **observables** (*Sequence\\[Pauli | SparsePauliOp] | PauliList*)"
		},
		{
			"id": "qiskit_addon_cutting.utils.transpiler_passes",
			"name": "qiskit_addon_cutting.utils.transpiler_passes",
			"type": "module",
			"description": "qiskit_addon_cutting.utils.transpiler_passes Transpiler passes useful for circuit knitting."
		},
		{
			"id": "qiskit_addon_cutting.utils.transpiler_passes.RemoveFinalReset",
			"name": "qiskit_addon_cutting.utils.transpiler_passes.RemoveFinalReset",
			"type": "class",
			"description": "Remove reset when it is the final instruction on a qubit wire. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit_addon_cutting.utils.transpiler_passes.ConsolidateResets",
			"name": "qiskit_addon_cutting.utils.transpiler_passes.ConsolidateResets",
			"type": "class",
			"description": "Consolidate a run duplicate resets in to a single reset. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit_addon_cutting.qpd.QPDBasis",
			"name": "qiskit_addon_cutting.qpd.QPDBasis",
			"type": "class",
			"description": "Basis in which to decompose an operation. This class defines a basis in which a quantum operation will be decomposed. The ideal (noise-free) quantum operation will be decomposed into a quasiprobabilistic mixture of noisy circuits. Assign member variables."
		},
		{
			"id": "qiskit_addon_cutting.instructions.CutWire",
			"name": "qiskit_addon_cutting.instructions.CutWire",
			"type": "class",
			"description": "An instruction for denoting a wire cut location. Create CutWire instruction. ## Attributes **Parameters** **label** (*str*\") *| None*) ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit_addon_cutting.utils.observable_grouping",
			"name": "qiskit_addon_cutting.utils.observable_grouping",
			"type": "module",
			"description": "Restrict each observable to its support on a given subsystem. A PauliList\") will be returned if a PauliList\") is provided; otherwise, a list[Pauli] will be returned. Any phase information will be discarded, consistent with the standard behavior when slicing a Pauli."
		},
		{
			"id": "qiskit_addon_sqd.subsampling",
			"name": "qiskit_addon_sqd.subsampling",
			"type": "module",
			"description": "Subsample batches of bit arrays from an input bitstring_matrix. Each individual batch will be sampled without replacement from the input bitstring_matrix. Samples will be replaced after creation of each batch, so different batches may contain identical samples."
		},
		{
			"id": "qiskit_addon_sqd.fermion",
			"name": "qiskit_addon_sqd.fermion",
			"type": "module",
			"description": "The amplitudes and determinants describing a quantum state."
		},
		{
			"id": "qiskit_addon_sqd.qubit",
			"name": "qiskit_addon_sqd.qubit",
			"type": "module",
			"description": "Find the energies and eigenstates of a Hamiltonian projected into a subspace. The subspace is defined by a collection of computational basis states which are specified by the bitstrings (rows) in the bitstring_matrix."
		},
		{
			"id": "qiskit_addon_sqd.counts",
			"name": "qiskit_addon_sqd.counts",
			"type": "module",
			"description": "Convert a counts dictionary into a bitstring matrix and a probability array. **Parameters** **counts** (*Mapping*\")*\\*[*str*\")*,* *float*\") *|**int*\")*]*) – The counts dictionary to convert **Returns** * A 2D array representing the sampled bitstrings."
		},
		{
			"id": "qiskit_addon_sqd.configuration_recovery",
			"name": "qiskit_addon_sqd.configuration_recovery",
			"type": "module",
			"description": "Post-select bitstrings based on the hamming weight of each half. The function qiskit_addon_sqd.configuration_recovery.post_select_by_hamming_weight() is deprecated as of qiskit-addon-sqd 0.12.0. It will be removed no earlier than v0.13.0. Instead, use the postselect_by_hamming_right_and_left function."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_circuit.CircuitEvolver",
			"name": "qiskit_addon_mpf.backends.quimb_circuit.CircuitEvolver",
			"type": "class",
			"description": "A time-evolution engine based on quantum circuits. This algorithm performs time-evolution by means of successively applying a quantum circuit corresponding to a single Trotter step to its internal state. More specifically, it builds out a tensor network in the CircuitState."
		},
		{
			"id": "qiskit_addon_mpf.backends",
			"name": "qiskit_addon_mpf.backends",
			"type": "module",
			"description": "Indicates whether the optional quimb\") dependency is installed."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_circuit",
			"name": "qiskit_addon_mpf.backends.quimb_circuit",
			"type": "module",
			"description": "qiskit_addon_mpf.backends.quimb_circuit A circuit-based time-evolution backend using quimb\")."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_tebd",
			"name": "qiskit_addon_mpf.backends.tenpy_tebd",
			"type": "module",
			"description": "qiskit_addon_mpf.backends.tenpy_tebd A tenpy\")-based TEBD backend. The optional dependency TeNPy was previously offered under a GPLv3 license. As of the release of v1.0.4 on October 2nd, 2024, it has been offered under the Apache v2 license."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_tebd.MPS_neel_state",
			"name": "qiskit_addon_mpf.backends.tenpy_tebd.MPS_neel_state",
			"type": "class",
			"description": "Constructs the Néel state as an MPS. **Parameters** **lat** (*Lattice*\")) – the lattice describing the MPS sites. **Returns** A Néel state as an MPS. **Return type** *MPS*\")"
		},
		{
			"id": "qiskit_addon_mpf.costs",
			"name": "qiskit_addon_mpf.costs",
			"type": "module",
			"description": "A namedtuple representing a linear system of equations. Create new instance of LSE(A, b) **Parameters** * **A** (*ndarray*\")) * **b** (*ndarray*\")) #### A The left hand side of the LSE. #### b The right hand side of the LSE. #### count Return number of occurrences of value."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_layers.LayerwiseEvolver",
			"name": "qiskit_addon_mpf.backends.tenpy_layers.LayerwiseEvolver",
			"type": "class",
			"description": "A special case of the TEBDEvolver based on layer-wise evolution models. As also explained in tenpy_layers, this implementation extracts the alternating even/odd bond updates implemented inside of the original TEBDEngine\") to become the end users responsibility."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_tebd.MPOState",
			"name": "qiskit_addon_mpf.backends.quimb_tebd.MPOState",
			"type": "class",
			"description": "An MPO enforcing the Vidal gauge. This specialization of quimb’s existing quimb.tensor.MatrixProductOperator\") enforces the Vidal gauge throughout its existence. This ensures a stable behavior of the DynamicMPF algorithm when using the TEBDEvolver. Initialize a MPOState instance."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_tebd",
			"name": "qiskit_addon_mpf.backends.quimb_tebd",
			"type": "module",
			"description": "qiskit_addon_mpf.backends.quimb_tebd A quimb\")-based TEBD backend."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_tebd.MPOState",
			"name": "qiskit_addon_mpf.backends.tenpy_tebd.MPOState",
			"type": "class",
			"description": "A mediator class to make TeNPy’s MPO match the State interface. This class simply ensures that a tenpy.networks.mpo.MPO\") object can work as a State instance. ## Methods ### initialize\\_from\\_lattice Construct an identity MPOState instance matching the provided lattice shape."
		},
		{
			"id": "qiskit_addon_mpf.dynamic",
			"name": "qiskit_addon_mpf.dynamic",
			"type": "module",
			"description": "Return the linear system of equations for computing dynamic MPF coefficients. This function uses the DynamicMPF algorithm to compute the components of the Gram matrix (LSE.A, in \\[1] and \\[2]) and the overlap vector (LSE.b, in \\[1] and \\[2]) for the provided time-evolution parameters."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_tebd.TEBDEvolver",
			"name": "qiskit_addon_mpf.backends.tenpy_tebd.TEBDEvolver",
			"type": "class",
			"description": "A TEBD algorithm for evolving an internal MPO. As discussed in more detail in tenpy_tebd, this extension of TeNPy’s existing TEBDEngine\") implementation time-evolves an internal matrix product operator (MPO) rather than the conventional matrix product state (MPS)."
		},
		{
			"id": "qiskit_addon_mpf.static",
			"name": "qiskit_addon_mpf.static",
			"type": "module",
			"description": "Return the linear system of equations for computing static MPF coefficients. This function constructs the following linear system of equations: with where \\ is the order, \\ is \\ if symmetric is True and \\ oterhwise, \\ are the trotter_steps, and \\ are the variables to solve for."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_layers",
			"name": "qiskit_addon_mpf.backends.tenpy_layers",
			"type": "module",
			"description": "qiskit_addon_mpf.backends.tenpy_layers A layer-wise time-evolution backend using tenpy\"). The optional dependency TeNPy was previously offered under a GPLv3 license. As of the release of v1.0.4 on October 2nd, 2024, it has been offered under the Apache v2 license."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_layers.LayerwiseEvolver",
			"name": "qiskit_addon_mpf.backends.quimb_layers.LayerwiseEvolver",
			"type": "class",
			"description": "A special case of the TEBDEvolver based on layer-wise evolution models. As also explained in quimb_layers, this implementation extracts the alternating even/odd bond updates implemented inside of the original quimb.tensor.TEBD\") to become the end users responsibility."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_layers",
			"name": "qiskit_addon_mpf.backends.quimb_layers",
			"type": "module",
			"description": "qiskit_addon_mpf.backends.quimb_layers A layer-wise time-evolution backend using quimb\")."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_tebd.TEBDEvolver",
			"name": "qiskit_addon_mpf.backends.quimb_tebd.TEBDEvolver",
			"type": "class",
			"description": "A TEBD algorithm for evolving an internal MPO. As discussed in more detail in quimb_tebd, this extension of quimb’s existing quimb.tensor.TEBD\") implementation time-evolves an internal matrix product operator (MPO) rather than the conventional matrix product state (MPS)."
		},
		{
			"id": "qiskit_addon_mpf.backends.tenpy_layers.LayerModel",
			"name": "qiskit_addon_mpf.backends.tenpy_layers.LayerModel",
			"type": "class",
			"description": "A model for representing a layer of time-evolution interactions. Essentially, this class is a simple wrapper of tenpy.models.model.CouplingMPOModel\") and tenpy.models.model.NearestNeighborModel\")."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_circuit.CircuitState",
			"name": "qiskit_addon_mpf.backends.quimb_circuit.CircuitState",
			"type": "class",
			"description": "An MPO-like representation of a time-evolution state based on quantum circuits. This time-evolution state can be evolved on its left- and right-hand side as required by the DynamicMPF algorithm. Initialize a CircuitState instance."
		},
		{
			"id": "qiskit_addon_mpf.backends.quimb_layers.LayerModel",
			"name": "qiskit_addon_mpf.backends.quimb_layers.LayerModel",
			"type": "class",
			"description": "A model for representing a layer of time-evolution interactions. Essentially, this class is a simple wrapper of quimb.tensor.LocalHam1D\"). Its main purpose is to provide a simple interface for constructing a Quimb-compatible Hamiltonian from Qiskit objects."
		},
		{
			"id": "qiskit_addon_utils.slicing",
			"name": "qiskit_addon_utils.slicing",
			"type": "module",
			"description": "Combine N-qubit slices of a circuit into a single circuit. **Parameters** * **slices** (*Sequence*\")*\\*[*QuantumCircuit*\")*]*) – The N-qubit circuit slices. * **include\\_barriers** (*bool*\")) – If True, place barriers between each slice."
		},
		{
			"id": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddPostSelectionMeasures",
			"name": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddPostSelectionMeasures",
			"type": "class",
			"description": "Add a post selection measurement after every terminal measurement. A post selection measurement is a measurement that follows a regular measurement on a given qubit. It consists of a narrowband X-pulse followed by a regular measurement operation."
		},
		{
			"id": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes",
			"name": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes",
			"type": "module",
			"description": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes A submodule with transpilation passes for post selection."
		},
		{
			"id": "qiskit_addon_utils.slicing.transpiler.passes",
			"name": "qiskit_addon_utils.slicing.transpiler.passes",
			"type": "module",
			"description": "qiskit_addon_utils.slicing.transpiler.passes A submodule with transpilation passes for slicing."
		},
		{
			"id": "qiskit_addon_utils.noise_management",
			"name": "qiskit_addon_utils.noise_management",
			"type": "module",
			"description": "Calculates TREX mitigation algorithm’s expectation value scale factor for each Pauli term in basis_dict. Calculates \\ for each Pauli term in each observable, where n is the non identity indices in the Pauli term. The calculation is done using learned measurement noise."
		},
		{
			"id": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures",
			"name": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures",
			"type": "class",
			"description": "Add measurements on spectator qubits. An active qubit is a qubit acted on in the circuit by a non-barrier instruction. A terminated qubit is one whose last action is a measurement. A spectator qubit is a qubit that is inactive, but adjacent to an active qubit under the coupling map."
		},
		{
			"id": "qiskit_addon_utils.exp_vals",
			"name": "qiskit_addon_utils.exp_vals",
			"type": "module",
			"description": "Computes expectation values from boolean data and metadata, aiming for compatibility with the components of a result from Executor in qiskit_ibm_runtime ."
		},
		{
			"id": "qiskit_addon_utils.problem_generators",
			"name": "qiskit_addon_utils.problem_generators",
			"type": "module",
			"description": "Generate a connectivity-aware qubit operator representing a quantum XYZ-type model. This function implements the following Hamiltonian: Where G(V,E) is the graph of the provided coupling map. There is often a factor included outside the summation of this equation."
		},
		{
			"id": "qiskit_addon_utils.coloring",
			"name": "qiskit_addon_utils.coloring",
			"type": "module",
			"description": "Color the input edges of an undirected graph such that no two incident edges share a color. **Parameters** **edges** (*Sequence*\")*\\*[*tuple*\")*\\*[*int*\")*,* *int*\")*]]*) – The edges describing an undirected graph. **Returns** A dictionary mapping each edge to an integer representation of a color."
		},
		{
			"id": "qiskit_addon_utils.slicing.transpiler.passes.CollectOpColor",
			"name": "qiskit_addon_utils.slicing.transpiler.passes.CollectOpColor",
			"type": "class",
			"description": "Collects blocks of operations which act on the provided edges. The collected operations are replaced by a single block instruction. Initialize a CollectOpColor object. The do_commutative_analysis keyword currently does not work as intended due to an open issue. Thus, setting it to True will not work."
		},
		{
			"id": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes.XSlowGate",
			"name": "qiskit_addon_utils.noise_management.post_selection.transpiler.passes.XSlowGate",
			"type": "class",
			"description": "The x-slow gate. **Parameters** * **name** – The name of the gate. * **num\\_qubits** – The number of qubits the gate acts on. * **params** – A list of parameters. * **label** (*str*\")) – An optional label for the gate."
		},
		{
			"id": "qiskit_addon_utils.slicing.transpiler.passes.CollectOpType",
			"name": "qiskit_addon_utils.slicing.transpiler.passes.CollectOpType",
			"type": "class",
			"description": "Collects blocks of the specified operation and replaces them by a single block instruction. Initialize a CollectOpType object. The do_commutative_analysis keyword currently does not work as intended due to an open issue. Thus, setting it to True will not work."
		},
		{
			"id": "qiskit_addon_utils.slicing.transpiler.passes.CollectOpSize",
			"name": "qiskit_addon_utils.slicing.transpiler.passes.CollectOpSize",
			"type": "class",
			"description": "Collects blocks of the specified size and replaces them by a single block instruction. Initialize a CollectOpSize object. The do_commutative_analysis keyword currently does not work as intended due to an open issue. Thus, setting it to True will not work."
		},
		{
			"id": "qiskit_addon_utils.noise_management.post_selection",
			"name": "qiskit_addon_utils.noise_management.post_selection",
			"type": "module",
			"description": "A helper class to store the properties of a quantum circuit required to post select the results. Initialize a PostSelectionSummary object."
		},
		{
			"id": "qiskit.visualization.timeline_drawer",
			"name": "qiskit.visualization.timeline_drawer",
			"type": "function",
			"description": "Generate visualization data for scheduled circuit programs. The target parameter needs to be specified in Qiskit 2.0 in order to get the instruction durations. qiskit.visualization.timeline.interface.draw()’s argument show_barriers is pending deprecation as of Qiskit 1.1.0."
		},
		{
			"id": "qiskit.primitives.BackendEstimatorV2",
			"name": "qiskit.primitives.BackendEstimatorV2",
			"type": "class",
			"description": "Evaluates expectation values for provided quantum circuit and observable combinations. The BackendEstimatorV2 class is a generic implementation of the BaseEstimatorV2 interface that is used to wrap a BackendV2 object in the BaseEstimatorV2 API."
		},
		{
			"id": "qiskit.transpiler.passes.TrivialLayout",
			"name": "qiskit.transpiler.passes.TrivialLayout",
			"type": "class",
			"description": "Choose a Layout by assigning n circuit qubits to device qubits 0, .., n-1. A pass for choosing a Layout of a circuit onto a Coupling graph, using a simple round-robin order. This pass associates a physical qubit (int) to each virtual qubit of the circuit (Qubit) in increasing order."
		},
		{
			"id": "qiskit.circuit.AnnotatedOperation",
			"name": "qiskit.circuit.AnnotatedOperation",
			"type": "class",
			"description": "Annotated operation. Create a new AnnotatedOperation. An “annotated operation” allows to add a list of modifiers to the “base” operation. For now, the only supported modifiers are of types InverseModifier, ControlModifier and PowerModifier."
		},
		{
			"id": "qiskit.qpy",
			"name": "qiskit.qpy",
			"type": "module",
			"description": "Load a QPY binary file This function is used to load a serialized QPY Qiskit program file and create QuantumCircuit objects from its contents."
		},
		{
			"id": "qiskit.circuit.library.XGate",
			"name": "qiskit.circuit.library.XGate",
			"type": "class",
			"description": "The single-qubit Pauli-X gate (). Can be applied to a QuantumCircuit with the x() method. Matrix representation: Circuit symbol: ``text ┌───┐ q_0: ┤ X ├ └───┘ ` Equivalent to a radian rotation about the X axis. A global phase difference exists between the definitions of and ."
		},
		{
			"id": "qiskit.visualization.plot_state_hinton",
			"name": "qiskit.visualization.plot_state_hinton",
			"type": "function",
			"description": "Plot a hinton diagram for the density matrix of a quantum state. The hinton diagram represents the values of a matrix using squares, whose size indicate the magnitude of their corresponding value and their color, its sign. A white square means the value is positive and a black one means negative."
		},
		{
			"id": "qiskit.circuit.library.MCMTVChain",
			"name": "qiskit.circuit.library.MCMTVChain",
			"type": "class",
			"description": "The MCMT implementation using the CCX V-chain. This implementation requires ancillas but is decomposed into a much shallower circuit than the default implementation in MCMT. Expanded circuit: !Diagram illustrating the previously described circuit."
		},
		{
			"id": "qiskit.quantum_info.QubitSparsePauliList",
			"name": "qiskit.quantum_info.QubitSparsePauliList",
			"type": "class",
			"description": "A list of phase-less Pauli operators stored in a qubit-sparse format. ## Representation Each individual Pauli operator in the list is a tensor product of single-qubit Pauli operators of the form , for ."
		},
		{
			"id": "qiskit.passmanager.PropertySet",
			"name": "qiskit.passmanager.PropertySet",
			"type": "class",
			"description": "A default dictionary-like object. ## Methods ### clear ### copy ### fromkeys Create a new dictionary with keys from iterable and values set to value. ### get Return the value for key if key is in the dictionary, else default."
		},
		{
			"id": "qiskit.circuit.library.CYGate",
			"name": "qiskit.circuit.library.CYGate",
			"type": "class",
			"description": "Controlled-Y gate. Can be applied to a QuantumCircuit with the cy() method. Circuit symbol: ``text q_0: ──■── ┌─┴─┐ q_1: ┤ Y ├ └───┘ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.transpiler.passes.OptimizeSwapBeforeMeasure",
			"name": "qiskit.transpiler.passes.OptimizeSwapBeforeMeasure",
			"type": "class",
			"description": "Remove the swaps followed by measurement (and adapt the measurement). Transpiler pass to remove swaps in front of measurements by re-targeting the classical bit of the measure instruction. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.MCPhaseGate",
			"name": "qiskit.circuit.library.MCPhaseGate",
			"type": "class",
			"description": "Multi-controlled-Phase gate. This is a diagonal and symmetric gate that induces a phase on the state of the target qubit, depending on the state of the control qubits. Can be applied to a QuantumCircuit with the mcp() method. Circuit symbol: ``text q_0: ───■──── │ ."
		},
		{
			"id": "qiskit.quantum_info.SuperOp",
			"name": "qiskit.quantum_info.SuperOp",
			"type": "class",
			"description": "Superoperator representation of a quantum channel. The Superoperator representation of a quantum channel is a matrix such that the evolution of a DensityMatrix is given by where the double-ket notation denotes a vector formed by stacking the columns of the matrix *(column-vectorization)*."
		},
		{
			"id": "qiskit.circuit.library.RGQFTMultiplier",
			"name": "qiskit.circuit.library.RGQFTMultiplier",
			"type": "class",
			"description": "A QFT multiplication circuit to store product of two input registers out-of-place. Multiplication in this circuit is implemented using the procedure of Fig. 3 in \\[1], where weighted sum rotations are implemented as given in Fig. 5 in \\[1]."
		},
		{
			"id": "qiskit.quantum_info.PauliList",
			"name": "qiskit.quantum_info.PauliList",
			"type": "class",
			"description": "List of N-qubit Pauli operators. This class is an efficient representation of a list of Pauli operators. It supports 1D numpy array indexing returning a Pauli for integer indexes or a PauliList for slice or list indices. **Initialization** A PauliList object can be initialized in several ways."
		},
		{
			"id": "qiskit.transpiler.passes.TranslateParameterizedGates",
			"name": "qiskit.transpiler.passes.TranslateParameterizedGates",
			"type": "class",
			"description": "Translate parameterized gates to a supported basis set. Once a parameterized instruction is found that is not in the supported_gates list, the instruction is decomposed one level and the parameterized sub-blocks are recursively decomposed."
		},
		{
			"id": "qiskit.circuit.CircuitInstruction",
			"name": "qiskit.circuit.CircuitInstruction",
			"type": "class",
			"description": "A single instruction in a QuantumCircuit, comprised of the operation and various operands. There is some possible confusion in the names of this class, Instruction, and Operation, and this class’s attribute operation."
		},
		{
			"id": "qiskit.circuit.library.FullAdderGate",
			"name": "qiskit.circuit.library.FullAdderGate",
			"type": "class",
			"description": "Compute the sum of two -sized qubit registers, including carry-in and -out bits."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisDefault",
			"type": "class",
			"description": "The default half-adder (no carry in, but a carry out qubit) synthesis. If we have an auxiliary qubit available, the Cuccaro ripple-carry adder uses CX gates and 1 auxiliary qubit, whereas the Vedral ripple-carry uses more CX and auxiliary qubits."
		},
		{
			"id": "qiskit.circuit.library.WeightedAdder",
			"name": "qiskit.circuit.library.WeightedAdder",
			"type": "class",
			"description": "A circuit to compute the weighted sum of qubit registers. Given qubit basis states and non-negative integer weights , this circuit performs the operation where is the number of sum qubits required."
		},
		{
			"id": "qiskit.circuit.library.MCMTGate",
			"name": "qiskit.circuit.library.MCMTGate",
			"type": "class",
			"description": "The multi-controlled multi-target gate, for an arbitrary singly controlled target gate."
		},
		{
			"id": "qiskit.circuit.library.XOR",
			"name": "qiskit.circuit.library.XOR",
			"type": "class",
			"description": "An n\\_qubit circuit for bitwise xor-ing the input with some integer amount. The amount is xor-ed in bitstring form with the input. This circuit can also represent addition by amount over the finite field GF(2)."
		},
		{
			"id": "qiskit.visualization.plot_histogram",
			"name": "qiskit.visualization.plot_histogram",
			"type": "function",
			"description": "Plot a histogram of input counts data. **Parameters** * **data** (*list*\") *or**dict*\")) – This is either a list of dictionaries or a single dict containing the values to represent (ex {'001': 130}) * **figsize** (*tuple*\")) – Figure size in inches."
		},
		{
			"id": "qiskit.visualization.array_to_latex",
			"name": "qiskit.visualization.array_to_latex",
			"type": "function",
			"description": "Latex representation of a complex numpy array (with dimension 1 or 2) **Parameters** * **array** (*ndarray*) – The array to be converted to latex, must have dimension 1 or 2 and contain only numerical data."
		},
		{
			"id": "qiskit.transpiler.passes.ContextAwareDynamicalDecoupling",
			"name": "qiskit.transpiler.passes.ContextAwareDynamicalDecoupling",
			"type": "class",
			"description": "Implement an X-sequence dynamical decoupling considering the gate- and qubit-context. This pass implements a context-aware dynamical decoupling (DD) \\[1], which ensures that > 1. simultaneously occurring DD sequences on device-adjacent qubits are mutually orthogonal, and > 2."
		},
		{
			"id": "qiskit.result.ProbDistribution",
			"name": "qiskit.result.ProbDistribution",
			"type": "class",
			"description": "A generic dict-like class for probability distributions. Builds a probability distribution object. **Parameters** * **data** (*dict*\")) – Input probability data. Where the keys represent a measured classical value and the value is a float for the probability of that result."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisGrayCode",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisGrayCode",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the Gray code. This plugin name is :mcx.gray_code which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.MCXGrayCode",
			"name": "qiskit.circuit.library.MCXGrayCode",
			"type": "class",
			"description": "Implement the multi-controlled X gate using the Gray code. This delegates the implementation to the MCU1 gate, since . Create new MCX gate."
		},
		{
			"id": "qiskit.circuit.library.PiecewiseChebyshevGate",
			"name": "qiskit.circuit.library.PiecewiseChebyshevGate",
			"type": "class",
			"description": "Piecewise Chebyshev approximation to an input function. For a given function and degree , this class implements a piecewise polynomial Chebyshev approximation on qubits to on the given intervals. All the polynomials in the approximation are of degree ."
		},
		{
			"id": "qiskit.transpiler.passes.ElidePermutations",
			"name": "qiskit.transpiler.passes.ElidePermutations",
			"type": "class",
			"description": "Remove permutation operations from a pre-layout circuit This pass is intended to be run before a layout (mapping virtual qubits to physical qubits) is set during the transpilation pipeline."
		},
		{
			"id": "qiskit.transpiler.passes.Collect1qRuns",
			"name": "qiskit.transpiler.passes.Collect1qRuns",
			"type": "class",
			"description": "Collect one-qubit subcircuits. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.ApproximateCircuit",
			"name": "qiskit.synthesis.unitary.aqc.ApproximateCircuit",
			"type": "class",
			"description": "A base class that represents an approximate circuit. **Parameters** * **num\\_qubits** (*int*\")) – number of qubit this circuit will span. * **name** (*Optional\\*[*str*\")*]*) – a name of the circuit. ## Attributes ### thetas The property is not implemented and raises a NotImplementedException exception."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisDefault",
			"type": "class",
			"description": "The default synthesis for IntegerComparatorGate. Currently this is only supporting an ancilla-based decomposition. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.qasm3",
			"name": "qiskit.qasm3",
			"type": "module",
			"description": "Serialize a QuantumCircuit object as an OpenQASM 3 stream to file-like object. **Parameters** * **circuit** (*QuantumCircuit*) – Circuit to serialize. * **stream** (*TextIOBase*) – stream-like object to dump the OpenQASM 3 serialization * **\\*\\*kwargs** – Arguments for the Exporter constructor."
		},
		{
			"id": "qiskit.transpiler.OptimizationMetric",
			"name": "qiskit.transpiler.OptimizationMetric",
			"type": "class",
			"description": "Optimization metric considered during transpilation. The metric COUNT_2Q targets optimizing the two-qubit gate count of the output circuit. This is generally the preferred choice for near-term execution."
		},
		{
			"id": "qiskit.circuit.EquivalenceLibrary",
			"name": "qiskit.circuit.EquivalenceLibrary",
			"type": "class",
			"description": "A library providing a one-way mapping of Gates to their equivalent implementations as QuantumCircuits. ## Attributes ### graph Return graph representing the equivalence library data."
		},
		{
			"id": "qiskit.circuit.library.LinearAmplitudeFunction",
			"name": "qiskit.circuit.library.LinearAmplitudeFunction",
			"type": "class",
			"description": "A circuit implementing a (piecewise) linear function on qubit amplitudes. An amplitude function of a function is a mapping for a function , where is a qubit state. This circuit implements for piecewise linear functions ."
		},
		{
			"id": "qiskit.circuit.library.GroverOperator",
			"name": "qiskit.circuit.library.GroverOperator",
			"type": "class",
			"description": "The Grover operator. Grover’s search algorithm \\[1, 2] consists of repeated applications of the so-called Grover operator used to amplify the amplitudes of the desired output states."
		},
		{
			"id": "qiskit.visualization.plot_coupling_map",
			"name": "qiskit.visualization.plot_coupling_map",
			"type": "function",
			"description": "Plots an arbitrary coupling map of qubits (embedded in a plane). **Parameters** * **num\\_qubits** (*int*\")) – The number of qubits defined and plotted."
		},
		{
			"id": "qiskit.transpiler.Layout",
			"name": "qiskit.transpiler.Layout",
			"type": "class",
			"description": "Two-ways dict to represent a Layout. construct a Layout from a bijective dictionary, mapping virtual qubits to physical qubits ## Methods ### add Adds a map element between bit and physical\\_bit. If physical\\_bit is not defined, bit will be mapped to a new physical bit."
		},
		{
			"id": "qiskit.circuit.ContinueLoopOp",
			"name": "qiskit.circuit.ContinueLoopOp",
			"type": "class",
			"description": "A circuit operation which, when encountered, moves to the next iteration of the nearest enclosing loop. Can only be used inside loops. **Parameters** * **num\\_qubits** (*int*\")) – the number of qubits this affects. * **num\\_clbits** (*int*\")) – the number of qubits this affects."
		},
		{
			"id": "qiskit.circuit.library.XXPlusYYGate",
			"name": "qiskit.circuit.library.XXPlusYYGate",
			"type": "class",
			"description": "XX+YY interaction gate. A 2-qubit parameterized XX+YY interaction, also known as an XY gate. Its action is to induce a coherent rotation by some angle between and ."
		},
		{
			"id": "qiskit.transpiler.passes.SabreSwap",
			"name": "qiskit.transpiler.passes.SabreSwap",
			"type": "class",
			"description": "Map input circuit onto a backend topology via insertion of SWAPs. Implementation of the SWAP-based heuristic search from the SABRE qubit mapping paper \\[2] (Algorithm 1) with the modifications from the LightSABRE paper \\[1]."
		},
		{
			"id": "qiskit.transpiler.passes.CheckMap",
			"name": "qiskit.transpiler.passes.CheckMap",
			"type": "class",
			"description": "Check if a DAG circuit is already mapped to a coupling map."
		},
		{
			"id": "qiskit.transpiler.passes.DenseLayout",
			"name": "qiskit.transpiler.passes.DenseLayout",
			"type": "class",
			"description": "Choose a Layout by finding the most connected subset of qubits. This pass associates a physical qubit (int) to each virtual qubit of the circuit (Qubit)."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisRustiq",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisRustiq",
			"type": "class",
			"description": "Synthesize a PauliEvolutionGate using Rustiq. This plugin name is :PauliEvolution.rustiq which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.U1Gate",
			"name": "qiskit.circuit.library.U1Gate",
			"type": "class",
			"description": "Single-qubit rotation about the Z axis. This is a diagonal gate. It can be implemented virtually in hardware via framechanges (i.e. at zero error and duration). This gate is deprecated."
		},
		{
			"id": "qiskit.transpiler.passes.CollectCliffords",
			"name": "qiskit.transpiler.passes.CollectCliffords",
			"type": "class",
			"description": "Collects blocks of Clifford gates and replaces them by a Clifford object. CollectCliffords initializer. **Parameters** * **do\\_commutative\\_analysis** (*bool*\")) – if True, exploits commutativity relations between nodes."
		},
		{
			"id": "qiskit.circuit.library.AndGate",
			"name": "qiskit.circuit.library.AndGate",
			"type": "class",
			"description": "A gate representing the logical AND operation on a number of qubits. For the AND operation the state is interpreted as True. The result qubit is flipped, if the state of all variable qubits is True."
		},
		{
			"id": "qiskit.circuit.library.PhaseOracle",
			"name": "qiskit.circuit.library.PhaseOracle",
			"type": "class",
			"description": "Phase Oracle. The Phase Oracle object constructs circuits for any arbitrary input logical expressions. A logical expression is composed of logical operators & (logical AND), | (logical OR), \\~ (logical NOT), and ^ (logical XOR). as well as symbols for literals (variables)."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.DefaultSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.DefaultSynthesisClifford",
			"type": "class",
			"description": "The default clifford synthesis plugin. For N \\ 3 qubits this is done using the general non-optimal greedy compilation routine from reference by Bravyi, Hu, Maslov, Shaydulin."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisC04",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisC04",
			"type": "class",
			"description": "A ripple-carry adder, modulo . This plugin name is:ModularAdder.ripple_c04 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. This plugin requires at least one clean auxiliary qubit."
		},
		{
			"id": "qiskit.quantum_info.SparsePauliOp",
			"name": "qiskit.quantum_info.SparsePauliOp",
			"type": "class",
			"description": "Sparse N-qubit operator in a Pauli basis representation. This is a sparse representation of an N-qubit matrix Operator in terms of N-qubit PauliList and complex coefficients."
		},
		{
			"id": "qiskit.circuit.library.RGate",
			"name": "qiskit.circuit.library.RGate",
			"type": "class",
			"description": "Rotation around the axis. Can be applied to a QuantumCircuit with the r() method. Circuit symbol: ``text ┌────────┐ q_0: ┤ R(θ,ϕ) ├ └────────┘ ` Matrix representation: **Parameters** * **theta** (*ParameterExpression* *|**float*\")) – The rotation angle ."
		},
		{
			"id": "qiskit.circuit.library.MultiplierGate",
			"name": "qiskit.circuit.library.MultiplierGate",
			"type": "class",
			"description": "Compute the product of two equally sized qubit registers into a new register. For two input registers , with qubits each and an output register with qubits, a multiplier performs the following operation where is the number of bits used to represent the result."
		},
		{
			"id": "qiskit.circuit",
			"name": "qiskit.circuit",
			"type": "module",
			"description": "Implement a generic bit. This class cannot be instantiated directly. Its only purpose is to allow generic type checking for Clbit and Qubit."
		},
		{
			"id": "qiskit.circuit.library.C3XGate",
			"name": "qiskit.circuit.library.C3XGate",
			"type": "class",
			"description": "The X gate controlled on 3 qubits. This implementation uses and 14 CNOT gates. Create a new 3-qubit controlled X gate. ## Attributes ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit.circuit.library.VBERippleCarryAdder",
			"name": "qiskit.circuit.library.VBERippleCarryAdder",
			"type": "class",
			"description": "The VBE ripple carry adder \\[1]. This circuit performs inplace addition of two equally-sized quantum registers. As an example, a classical adder circuit that performs full addition (i.e."
		},
		{
			"id": "qiskit.transpiler.passes.SolovayKitaev",
			"name": "qiskit.transpiler.passes.SolovayKitaev",
			"type": "class",
			"description": "Approximately decompose 1q gates to a discrete basis using the Solovay-Kitaev algorithm. The Solovay-Kitaev theorem \\[1] states that any single qubit gate can be approximated to arbitrary precision by a set of fixed single-qubit gates, if the set generates a dense subset in ."
		},
		{
			"id": "qiskit.circuit.library.ExcitationPreserving",
			"name": "qiskit.circuit.library.ExcitationPreserving",
			"type": "class",
			"description": "The heuristic excitation-preserving wave function ansatz. The ExcitationPreserving circuit preserves the ratio of , and states. To this end, this circuit uses two-qubit interactions of the form for the mode 'fsim' or with for the mode 'iswap'."
		},
		{
			"id": "qiskit.circuit.library.UGate",
			"name": "qiskit.circuit.library.UGate",
			"type": "class",
			"description": "Generic single-qubit rotation in terms of ZYZ Euler angles. The action of this gate can be related to the standard ZYZ Euler decomposition by Can be applied to a QuantumCircuit with the u() method."
		},
		{
			"id": "qiskit.providers.basic_provider",
			"name": "qiskit.providers.basic_provider",
			"type": "module",
			"description": "qiskit.providers.basic_provider A module of Python-based quantum simulators. Simulators can be accessed via the BasicProvider provider, e.g.: ``python from qiskit.providers.basic_provider import BasicProvider backend = BasicProvider().get_backend('basic_simulator') ``"
		},
		{
			"id": "qiskit.qasm2",
			"name": "qiskit.qasm2",
			"type": "module",
			"description": "Parse an OpenQASM 2 program from a file into a QuantumCircuit. The given path should be ASCII or UTF-8 encoded, and contain the OpenQASM 2 program. **Parameters** * **filename** (*str*\") *|**PathLike*\")) – The OpenQASM 2 program in a string."
		},
		{
			"id": "qiskit.circuit.library.CDKMRippleCarryAdder",
			"name": "qiskit.circuit.library.CDKMRippleCarryAdder",
			"type": "class",
			"description": "A ripple-carry circuit to perform in-place addition on two qubit registers."
		},
		{
			"id": "qiskit.circuit.library.UCPauliRotGate",
			"name": "qiskit.circuit.library.UCPauliRotGate",
			"type": "class",
			"description": "Uniformly controlled Pauli rotations. Implements the UCGate for the special case that all unitaries are Pauli rotations, where and is the rotation angle. **Parameters** * **angle\\_list** (*list*\")*\\*[*float*\")*]*) – List of rotation angles . * **rot\\_axis** (*str*\")) – Rotation axis."
		},
		{
			"id": "qiskit.dagcircuit.DAGCircuit",
			"name": "qiskit.dagcircuit.DAGCircuit",
			"type": "class",
			"description": "Quantum circuit as a directed acyclic graph. There are 3 types of nodes in the graph: inputs, outputs, and operations. The nodes are connected by directed edges that correspond to qubits and bits. ## Attributes ### clbits Returns the current sequence of registered Clbit instances as a list."
		},
		{
			"id": "qiskit.transpiler.passes.ResourceEstimation",
			"name": "qiskit.transpiler.passes.ResourceEstimation",
			"type": "class",
			"description": "Automatically require analysis passes for resource estimation. An analysis pass for automatically running: \\* Depth() \\* Width() \\* Size() \\* CountOps() \\* NumTensorFactors() ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.QuantumCircuit",
			"name": "qiskit.circuit.QuantumCircuit",
			"type": "class",
			"description": "Core Qiskit representation of a quantum circuit."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MultiplierSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MultiplierSynthesisDefault",
			"type": "class",
			"description": "THe default multiplier plugin. This plugin name is:Multiplier.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.providers.basic_provider.BasicProvider",
			"name": "qiskit.providers.basic_provider.BasicProvider",
			"type": "class",
			"description": "Provider for test simulators. ## Methods ### backends Return a list of backends matching the specified filtering. :param name: name of the backend. :param filters: callable for filtering. **Returns** **a list of Backends that match the filtering** criteria."
		},
		{
			"id": "qiskit.circuit.library.InnerProduct",
			"name": "qiskit.circuit.library.InnerProduct",
			"type": "class",
			"description": "A 2n-qubit Boolean function that computes the inner product of two n-qubit vectors over . This implementation is a phase oracle which computes the following transform."
		},
		{
			"id": "qiskit.circuit.library.pauli_feature_map",
			"name": "qiskit.circuit.library.pauli_feature_map",
			"type": "function",
			"description": "The Pauli expansion circuit. The Pauli expansion circuit is a data encoding circuit that transforms input data , where is the feature_dimension, as Here, is a set of qubit indices that describes the connections in the feature map, is a set containing all these index sets, and ."
		},
		{
			"id": "qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure",
			"name": "qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure",
			"type": "class",
			"description": "Remove diagonal gates (including diagonal 2Q gates) before a measurement. Transpiler pass to remove diagonal gates (like RZ, T, Z, etc) before a measurement. Including diagonal 2Q gates. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.excitation_preserving",
			"name": "qiskit.circuit.library.excitation_preserving",
			"type": "function",
			"description": "The heuristic excitation-preserving wave function ansatz. The excitation_preserving circuit preserves the ratio of , and states. To this end, this circuit uses two-qubit interactions of the form for the mode \"fsim\" or with for the mode \"iswap\"."
		},
		{
			"id": "qiskit.circuit.library.CZGate",
			"name": "qiskit.circuit.library.CZGate",
			"type": "class",
			"description": "Controlled-Z gate. This is a Clifford and symmetric gate. Can be applied to a QuantumCircuit with the cz() method. Circuit symbol: ``text q_0: ─■─ │ q_1: ─■─ ` Matrix representation: In the computational basis, this gate flips the phase of the target qubit if the control qubit is in the state."
		},
		{
			"id": "qiskit.circuit.library.LinearFunction",
			"name": "qiskit.circuit.library.LinearFunction",
			"type": "class",
			"description": "A linear reversible circuit on n qubits. Internally, a linear function acting on n qubits is represented as a n x n matrix of 0s and 1s in numpy array format."
		},
		{
			"id": "qiskit.circuit.library.UCRZGate",
			"name": "qiskit.circuit.library.UCRZGate",
			"type": "class",
			"description": "Uniformly controlled Pauli-Z rotations. Implements the UCGate for the special case that all unitaries are Pauli-Z rotations, where is the rotation angle. **Parameters** **angle\\_list** (*list*\")*\\*[*float*\")*]*) – List of rotation angles ."
		},
		{
			"id": "qiskit.circuit.Parameter",
			"name": "qiskit.circuit.Parameter",
			"type": "class",
			"description": "A compile-time symbolic parameter. The value of a Parameter must be entirely determined before a circuit begins execution."
		},
		{
			"id": "qiskit.circuit.SwitchCaseOp",
			"name": "qiskit.circuit.SwitchCaseOp",
			"type": "class",
			"description": "A circuit operation that executes one particular circuit block based on matching a given target against an ordered list of values. The special value CASE_DEFAULT can be used to represent a default condition."
		},
		{
			"id": "qiskit.primitives.PrimitiveJob",
			"name": "qiskit.primitives.PrimitiveJob",
			"type": "class",
			"description": "Primitive job class for the reference implementations of Primitives. **Parameters** **function** – A callable function to execute the job. ## Methods ### cancel Attempt to cancel the job. ### cancelled Return whether the job has been cancelled."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.ApproximatingObjective",
			"name": "qiskit.synthesis.unitary.aqc.ApproximatingObjective",
			"type": "class",
			"description": "A base class for an optimization problem definition. An implementing class must provide at least an implementation of the objective method. In such case only gradient free optimizers can be used. Both method, objective and gradient, preferable to have in an implementation."
		},
		{
			"id": "qiskit.providers.basic_provider.BasicProviderError",
			"name": "qiskit.providers.basic_provider.BasicProviderError",
			"type": "exception",
			"description": "Base class for errors raised by the Basic Provider. Set the error message."
		},
		{
			"id": "qiskit.transpiler",
			"name": "qiskit.transpiler",
			"type": "module",
			"description": "Exceptions raised during transpilation. Set the error message."
		},
		{
			"id": "qiskit.circuit.library.PiecewisePolynomialPauliRotationsGate",
			"name": "qiskit.circuit.library.PiecewisePolynomialPauliRotationsGate",
			"type": "class",
			"description": "Piecewise-polynomially-controlled Pauli rotations. This class implements a piecewise polynomial (not necessarily continuous) function, , on qubit amplitudes, which is defined through breakpoints and coefficients as follows. Suppose the breakpoints are a subset of , where is the number of state qubits."
		},
		{
			"id": "qiskit.circuit.library.CCXGate",
			"name": "qiskit.circuit.library.CCXGate",
			"type": "class",
			"description": "CCX gate, also known as Toffoli gate. Can be applied to a QuantumCircuit with the ccx() method. Circuit symbol: ``text q_0: ──■── │ q_1: ──■── ┌─┴─┐ q_2: ┤ X ├ └───┘ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.primitives.DataBin",
			"name": "qiskit.primitives.DataBin",
			"type": "class",
			"description": "Namespace for storing data."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisNoAux",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisNoAux",
			"type": "class",
			"description": "A V-chain based synthesis for MCMTGate. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.circuit.library.PiecewiseLinearPauliRotationsGate",
			"name": "qiskit.circuit.library.PiecewiseLinearPauliRotationsGate",
			"type": "class",
			"description": "Piecewise-linearly-controlled Pauli rotations. For a piecewise linear (not necessarily continuous) function , which is defined through breakpoints, slopes and offsets as follows. Suppose the breakpoints are a subset of , where is the number of state qubits."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc",
			"name": "qiskit.synthesis.unitary.aqc",
			"type": "module",
			"description": "Generates a network consisting of building blocks each containing a CNOT gate and possibly some single-qubit ones. This network models a quantum operator in question. Note, each building block has 2 input and outputs corresponding to a pair of qubits."
		},
		{
			"id": "qiskit.circuit.library.ExactReciprocalGate",
			"name": "qiskit.circuit.library.ExactReciprocalGate",
			"type": "class",
			"description": "Implements an exact reciprocal function. For a state and a scaling factor , this gate implements the operation States representing or are left unchanged, since this function would not be defined. **Parameters** * **num\\_state\\_qubits** (*int*\")) – The number of qubits representing the value to invert."
		},
		{
			"id": "qiskit.visualization.plot_state_city",
			"name": "qiskit.visualization.plot_state_city",
			"type": "function",
			"description": "Plot the cityscape of quantum state. Plot two 3d bar graphs (two dimensional) of the real and imaginary part of the density matrix rho. **Parameters** * **state** (*Statevector* *or**DensityMatrix* *or ndarray*) – an N-qubit quantum state."
		},
		{
			"id": "qiskit.circuit.library.TwoLocal",
			"name": "qiskit.circuit.library.TwoLocal",
			"type": "class",
			"description": "The two-local circuit. The two-local circuit is a parameterized circuit consisting of alternating rotation layers and entanglement layers. The rotation layers are single qubit gates applied on all qubits."
		},
		{
			"id": "qiskit.dagcircuit.DAGOpNode",
			"name": "qiskit.dagcircuit.DAGOpNode",
			"type": "class",
			"description": "Object to represent an Instruction at a node in the DAGCircuit."
		},
		{
			"id": "qiskit.transpiler.passes.ApplyLayout",
			"name": "qiskit.transpiler.passes.ApplyLayout",
			"type": "class",
			"description": "Apply or update the mapping of virtual qubits to physical qubits in the DAGCircuit. A “layout” in Qiskit is a mapping of virtual qubits (as the user typically creates circuits in terms of) to the physical qubits used to represent them on hardware."
		},
		{
			"id": "qiskit.circuit.library.Diagonal",
			"name": "qiskit.circuit.library.Diagonal",
			"type": "class",
			"description": "Circuit implementing a diagonal transformation. The class qiskit.circuit.library.generalized_gates.diagonal.Diagonal is deprecated as of Qiskit 2.1. It will be removed in Qiskit 3.0. Use DiagonalGate instead."
		},
		{
			"id": "qiskit.primitives.SamplerPubResult",
			"name": "qiskit.primitives.SamplerPubResult",
			"type": "class",
			"description": "Result of Sampler Pub. Initialize a pub result. **Parameters** * **data** (*DataBin*) – Result data. * **metadata** (*dict*\")*\\*[*str*\")*, Any] | None*) – Metadata specific to this pub. Keys are expected to be strings. ## Attributes ### data Result data for the pub. ### metadata Metadata for the pub."
		},
		{
			"id": "qiskit.passmanager.WorkflowStatus",
			"name": "qiskit.passmanager.WorkflowStatus",
			"type": "class",
			"description": ", previous_run=RunState.FAIL)\" modifiers=\"class\"> Bases: object\") Collection of compilation status of workflow, i.e. pass manager run. This data structure is initialized when the pass manager is run, and recursively handed over to underlying tasks."
		},
		{
			"id": "qiskit.transpiler.passes.CollectLinearFunctions",
			"name": "qiskit.transpiler.passes.CollectLinearFunctions",
			"type": "class",
			"description": "Collect blocks of linear gates (CXGate and SwapGate gates) and replaces them by linear functions (LinearFunction). CollectLinearFunctions initializer. **Parameters** * **do\\_commutative\\_analysis** (*bool*\")) – if True, exploits commutativity relations between nodes."
		},
		{
			"id": "qiskit.circuit.library.CU3Gate",
			"name": "qiskit.circuit.library.CU3Gate",
			"type": "class",
			"description": "Controlled-U3 gate (3-parameter two-qubit gate). This is a controlled version of the U3 gate (generic single qubit rotation). It is restricted to 3 parameters, and so cannot cover generic two-qubit controlled gates). This gate is deprecated."
		},
		{
			"id": "qiskit.transpiler.passes.MinimumPoint",
			"name": "qiskit.transpiler.passes.MinimumPoint",
			"type": "class",
			"description": "Check if the DAG has reached a relative semi-stable point over previous runs This pass is similar to the FixedPoint transpiler pass and is intended primarily to be used to set a loop break condition in the property set."
		},
		{
			"id": "qiskit.circuit.library.CUGate",
			"name": "qiskit.circuit.library.CUGate",
			"type": "class",
			"description": "Controlled-U gate (4-parameter two-qubit gate). This is a controlled version of the U gate (generic single qubit rotation), including a possible global phase of the U gate. Can be applied to a QuantumCircuit with the cu() method."
		},
		{
			"id": "qiskit.transpiler.passes.PadDelay",
			"name": "qiskit.transpiler.passes.PadDelay",
			"type": "class",
			"description": "Padding idle time with Delay instructions. Consecutive delays will be merged in the output of this pass."
		},
		{
			"id": "qiskit.transpiler.preset_passmanagers.plugin.PassManagerStagePlugin",
			"name": "qiskit.transpiler.preset_passmanagers.plugin.PassManagerStagePlugin",
			"type": "class",
			"description": "A PassManagerStagePlugin is a plugin interface object for using custom stages in transpile(). A PassManagerStagePlugin object can be added to an external package and integrated into the transpile() function with an entry point."
		},
		{
			"id": "qiskit.circuit.library.DCXGate",
			"name": "qiskit.circuit.library.DCXGate",
			"type": "class",
			"description": "Double-CNOT gate. A 2-qubit Clifford gate consisting of two back-to-back CNOTs with alternate controls. Can be applied to a QuantumCircuit with the dcx() method."
		},
		{
			"id": "qiskit.circuit.library.RZZGate",
			"name": "qiskit.circuit.library.RZZGate",
			"type": "class",
			"description": "A parametric 2-qubit interaction (rotation about ZZ). This gate is symmetric, and is maximally entangling at . Can be applied to a QuantumCircuit with the rzz() method."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.KMSSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.KMSSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on the Kutin, Moulton, Smithline method. This plugin name is :permutation.kms which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Permutation."
		},
		{
			"id": "qiskit.synthesis.QDrift",
			"name": "qiskit.synthesis.QDrift",
			"type": "class",
			"description": "The QDrift Trotterization method, which selects each term in the Trotterization randomly, with a probability proportional to its weight. Based on the work of Earl Campbell in Ref. \\[1]. **References** \\[1]: E. Campbell, “A random compiler for fast Hamiltonian simulation” (2018)."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisNoAux",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisNoAux",
			"type": "class",
			"description": "A potentially exponentially expensive comparison w/o auxiliary qubits. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.circuit.library.SwapGate",
			"name": "qiskit.circuit.library.SwapGate",
			"type": "class",
			"description": "The SWAP gate. This is a symmetric and Clifford gate. Can be applied to a QuantumCircuit with the swap() method. Circuit symbol: ``text q_0: ─X─ │ q_1: ─X─ ` Matrix representation: The gate is equivalent to a state swap and is a classical logic gate."
		},
		{
			"id": "qiskit.transpiler.passes.Split2QUnitaries",
			"name": "qiskit.transpiler.passes.Split2QUnitaries",
			"type": "class",
			"description": "Attempt to splits two-qubit unitaries in a DAGCircuit into two single-qubit gates. This pass will analyze all UnitaryGate instances and determine whether the matrix is actually a product of 2 single qubit gates."
		},
		{
			"id": "qiskit.transpiler.preset_passmanagers.plugin.PassManagerStagePluginManager",
			"name": "qiskit.transpiler.preset_passmanagers.plugin.PassManagerStagePluginManager",
			"type": "class",
			"description": "Manager class for preset pass manager stage plugins. ## Methods ### get\\_passmanager\\_stage Get a stage **Parameters** * **stage\\_name** (*str*\")) – * **plugin\\_name** (*str*\")) – * **pm\\_config** (*PassManagerConfig*) – **Return type** *PassManager*"
		},
		{
			"id": "qiskit.transpiler.passes.EnlargeWithAncilla",
			"name": "qiskit.transpiler.passes.EnlargeWithAncilla",
			"type": "class",
			"description": "Extend the dag with virtual qubits that are in layout but not in the circuit yet. Extend the DAG circuit with new virtual qubits (ancilla) that are specified in the layout, but not present in the circuit. Which qubits to add are previously allocated in the layout property, by a previous pass."
		},
		{
			"id": "qiskit.circuit.library.quantum_volume",
			"name": "qiskit.circuit.library.quantum_volume",
			"type": "function",
			"description": "A quantum volume model circuit. The model circuits are random instances of circuits used to measure the Quantum Volume metric, as introduced in \\[1]. The model circuits consist of layers of Haar random elements of SU(4) applied between corresponding pairs of qubits in a random bipartition."
		},
		{
			"id": "qiskit.quantum_info.QubitSparsePauli",
			"name": "qiskit.quantum_info.QubitSparsePauli",
			"type": "class",
			"description": "A phase-less Pauli operator stored in a qubit-sparse format. ## Representation A Pauli operator is a tensor product of single-qubit Pauli operators of the form , for . The internal representation of a QubitSparsePauli stores only the non-identity single-qubit Pauli operators."
		},
		{
			"id": "qiskit.transpiler.passes.WrapAngles",
			"name": "qiskit.transpiler.passes.WrapAngles",
			"type": "class",
			"description": "Wrap angles outside the bound specified in the target. This pass will check all the gates in the circuit and check if there are any gates outside the bound specified in the target."
		},
		{
			"id": "qiskit.circuit.library.pauli_two_design",
			"name": "qiskit.circuit.library.pauli_two_design",
			"type": "function",
			"description": "Construct a Pauli 2-design ansatz. This class implements a particular form of a 2-design circuit \\[1], which is frequently studied in quantum machine learning literature, such as, e.g., the investigation of Barren plateaus in variational algorithms \\[2]."
		},
		{
			"id": "qiskit.circuit.library.MSGate",
			"name": "qiskit.circuit.library.MSGate",
			"type": "class",
			"description": "The Mølmer–Sørensen gate. The Mølmer–Sørensen gate is native to ion-trap systems. The global MS can be applied to multiple ions to entangle multiple qubits simultaneously \\[1]. In the two-qubit case, this is equivalent to an XX interaction, and is thus reduced to the RXXGate."
		},
		{
			"id": "qiskit.transpiler.passes.OptimizeAnnotated",
			"name": "qiskit.transpiler.passes.OptimizeAnnotated",
			"type": "class",
			"description": "Optimization pass on circuits with annotated operations. Implemented optimizations: * For each annotated operation, converting the list of its modifiers to a canonical form. For example, consecutively applying inverse(), control(2) and inverse() is equivalent to applying control(2)."
		},
		{
			"id": "qiskit.circuit.ControlFlowOp",
			"name": "qiskit.circuit.ControlFlowOp",
			"type": "class",
			"description": "Abstract class to encapsulate all control flow operations. All subclasses of ControlFlowOp have an internal attribute, blocks, which exposes the inner subcircuits used in the different blocks of the control flow."
		},
		{
			"id": "qiskit.primitives.BaseEstimatorV2",
			"name": "qiskit.primitives.BaseEstimatorV2",
			"type": "class",
			"description": "Base class for EstimatorV2 implementations. An estimator calculates expectation values for provided quantum circuit and observable combinations."
		},
		{
			"id": "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements",
			"name": "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements",
			"type": "class",
			"description": "Add a barrier before final measurements. This pass adds a barrier before the set of final measurements. Measurements are considered final if they are followed by no other operations (aside from other measurements or barriers.) ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.MCXGate",
			"name": "qiskit.circuit.library.MCXGate",
			"type": "class",
			"description": "The general, multi-controlled X gate. Can be applied to a QuantumCircuit with the mcx() method. Create new MCX gate."
		},
		{
			"id": "qiskit.circuit.library.DraperQFTAdder",
			"name": "qiskit.circuit.library.DraperQFTAdder",
			"type": "class",
			"description": "A circuit that uses QFT to perform in-place addition on two qubit registers. For registers with qubits, the QFT adder can perform addition modulo (with kind=\"fixed\") or ordinary addition by adding a carry qubits (with kind=\"half\")."
		},
		{
			"id": "qiskit.circuit.library.SXdgGate",
			"name": "qiskit.circuit.library.SXdgGate",
			"type": "class",
			"description": "The inverse single-qubit Sqrt(X) gate. Can be applied to a QuantumCircuit with the sxdg() method. A global phase difference exists between the definitions of and . Create new SXdg gate. ## Attributes ### base\\_class Get the base class of this instruction."
		},
		{
			"id": "qiskit.quantum_info.Quaternion",
			"name": "qiskit.quantum_info.Quaternion",
			"type": "class",
			"description": "A class representing a Quaternion. ## Methods ### from\\_axis\\_rotation Return quaternion for rotation about given axis. **Parameters** * **angle** (*float*\")) – Angle in radians. * **axis** (*str*\")) – Axis for rotation **Returns** Quaternion for axis rotation."
		},
		{
			"id": "qiskit.primitives.BitArray",
			"name": "qiskit.primitives.BitArray",
			"type": "class",
			"description": "Stores an array of bit values. This object contains a single, contiguous block of data that represents an array of bitstrings. The last axis is over packed bits, the second last axis is over shots, and the preceding axes correspond to the shape of the pub that was executed to sample these bits."
		},
		{
			"id": "qiskit.circuit.library.RC3XGate",
			"name": "qiskit.circuit.library.RC3XGate",
			"type": "class",
			"description": "The simplified 3-controlled Toffoli gate. The simplified Toffoli gate implements the Toffoli gate up to relative phases. Note, that the simplified Toffoli is not equivalent to the Toffoli. But can be used in places where the Toffoli gate is uncomputed again."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.PMHSynthesisLinearFunction",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.PMHSynthesisLinearFunction",
			"type": "class",
			"description": "Linear function synthesis plugin based on the Patel-Markov-Hayes method. This plugin name is :linear_function.pmh which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.U2Gate",
			"name": "qiskit.circuit.library.U2Gate",
			"type": "class",
			"description": "Single-qubit rotation about the X+Z axis. Implemented using one X90 pulse on IBM Quantum systems: This gate is deprecated."
		},
		{
			"id": "qiskit.dagcircuit.DAGInNode",
			"name": "qiskit.dagcircuit.DAGInNode",
			"type": "class",
			"description": "Object to represent an incoming wire node in the DAGCircuit. ## Attributes ### wire"
		},
		{
			"id": "qiskit.circuit.annotation",
			"name": "qiskit.circuit.annotation",
			"type": "module",
			"description": "An iterator over all namespaces that can be used to lookup the given namespace. This includes the namespace and all parents, including the root empty-string namespace."
		},
		{
			"id": "qiskit.transpiler.passes.SabreLayout",
			"name": "qiskit.transpiler.passes.SabreLayout",
			"type": "class",
			"description": "Choose a Layout via iterative bidirectional routing of the input circuit. Starting with a random initial Layout, the algorithm does a full routing of the circuit (via the routing\\_pass method) to end up with a final\\_layout."
		},
		{
			"id": "qiskit.transpiler.CouplingMap",
			"name": "qiskit.transpiler.CouplingMap",
			"type": "class",
			"description": "Directed graph specifying fixed coupling. Nodes correspond to physical qubits (integers) and directed edges correspond to permitted CNOT gates, with source and destination corresponding to control and target qubits, respectively. Create coupling graph. By default, the generated coupling has no nodes."
		},
		{
			"id": "qiskit.circuit.library.UnitaryGate",
			"name": "qiskit.circuit.library.UnitaryGate",
			"type": "class",
			"description": "Class quantum gates specified by a unitary matrix. Example: We can create a unitary gate from a unitary matrix then add it to a quantum circuit. The matrix can also be directly applied to the quantum circuit, see QuantumCircuit.unitary()."
		},
		{
			"id": "qiskit.providers",
			"name": "qiskit.providers",
			"type": "module",
			"description": "Base class for errors raised while looking for a backend. Set the error message."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1CleanB95",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1CleanB95",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Barenco et al. (1995). See \\[1] for details. This plugin name is :mcx.1_clean_b95 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.synthesis.SuzukiTrotter",
			"name": "qiskit.synthesis.SuzukiTrotter",
			"type": "class",
			"description": "The (higher order) Suzuki-Trotter product formula. The Suzuki-Trotter formulas improve the error of the Lie-Trotter approximation. For example, the second order decomposition is Higher order decompositions are based on recursions, see Ref. \\[1] for more details."
		},
		{
			"id": "qiskit.circuit.library.C4XGate",
			"name": "qiskit.circuit.library.C4XGate",
			"type": "class",
			"description": "The 4-qubit controlled X gate. This implementation is based on Page 21, Lemma 7.5, of \\[1], with the use of the relative phase version of c3x, the rc3x \\[2]. **References** 1. Barenco et al., 1995. https://arxiv.org/pdf/quant-ph/9503016.pdf 2. Maslov, 2015."
		},
		{
			"id": "qiskit.transpiler.passes.RemoveFinalReset",
			"name": "qiskit.transpiler.passes.RemoveFinalReset",
			"type": "class",
			"description": "Remove reset when it is the final instruction on a qubit wire. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.passmanager.PassManagerState",
			"name": "qiskit.passmanager.PassManagerState",
			"type": "class",
			"description": "A portable container object that pass manager tasks communicate through generator. This object can contain every information about the running pass manager workflow, except for the IR object being optimized."
		},
		{
			"id": "qiskit.circuit.library.PiecewiseChebyshev",
			"name": "qiskit.circuit.library.PiecewiseChebyshev",
			"type": "class",
			"description": "Piecewise Chebyshev approximation to an input function. For a given function and degree , this class implements a piecewise polynomial Chebyshev approximation on qubits to on the given intervals. All the polynomials in the approximation are of degree ."
		},
		{
			"id": "qiskit.circuit.library.QuantumVolume",
			"name": "qiskit.circuit.library.QuantumVolume",
			"type": "class",
			"description": "A quantum volume model circuit. The model circuits are random instances of circuits used to measure the Quantum Volume metric, as introduced in \\[1]. The model circuits consist of layers of Haar random elements of SU(4) applied between corresponding pairs of qubits in a random bipartition."
		},
		{
			"id": "qiskit.providers.QubitProperties",
			"name": "qiskit.providers.QubitProperties",
			"type": "class",
			"description": "A representation of a QubitProperties object. ## Attributes ### frequency ### t1 ### t2"
		},
		{
			"id": "qiskit.circuit.library.HamiltonianGate",
			"name": "qiskit.circuit.library.HamiltonianGate",
			"type": "class",
			"description": "Class for representing evolution by a Hamiltonian operator as a gate. This gate resolves to a UnitaryGate as , which can be decomposed into basis gates if it is 2 qubits or less, or simulated directly in Aer for more qubits."
		},
		{
			"id": "qiskit.circuit.library.ECRGate",
			"name": "qiskit.circuit.library.ECRGate",
			"type": "class",
			"description": "An echoed cross-resonance gate. This gate is maximally entangling and is equivalent to a CNOT up to single-qubit pre-rotations. The echoing procedure mitigates some unwanted terms (terms other than ZX) to cancel in an experiment. More specifically, this gate implements ."
		},
		{
			"id": "qiskit.quantum_info.Z2Symmetries",
			"name": "qiskit.quantum_info.Z2Symmetries",
			"type": "class",
			"description": "The \\ symmetry converter identifies symmetries from the problem hamiltonian and uses them to provide a tapered - more efficient - representation of operators as Paulis for this problem."
		},
		{
			"id": "qiskit.transpiler.passes.RemoveFinalMeasurements",
			"name": "qiskit.transpiler.passes.RemoveFinalMeasurements",
			"type": "class",
			"description": "Remove final measurements and barriers at the end of a circuit. This pass removes final barriers and final measurements, as well as all unused classical registers and bits they are connected to."
		},
		{
			"id": "qiskit.transpiler.passes.LayoutTransformation",
			"name": "qiskit.transpiler.passes.LayoutTransformation",
			"type": "class",
			"description": "Adds a Swap circuit for a given (partial) permutation to the circuit. This circuit is found by a 4-approximation algorithm for Token Swapping. More details are available in the routing code. LayoutTransformation initializer."
		},
		{
			"id": "qiskit.primitives.PrimitiveResult",
			"name": "qiskit.primitives.PrimitiveResult",
			"type": "class",
			"description": "A container for multiple pub results and global metadata. **Parameters** * **pub\\_results** (*Iterable\\[T]*) – Pub results. * **metadata** (*dict*\")*\\*[*str*\")*, Any] | None*) – Metadata that is common to all pub results; metadata specific to particular pubs should be placed in their metadata fields."
		},
		{
			"id": "qiskit.transpiler.passes.CollectAndCollapse",
			"name": "qiskit.transpiler.passes.CollectAndCollapse",
			"type": "class",
			"description": "A general transpiler pass to collect and to consolidate blocks of nodes in a circuit. This transpiler pass depends on two functions: the collection function and the collapsing function. The collection function collect_function takes a DAG and returns a list of blocks."
		},
		{
			"id": "qiskit.quantum_info.StabilizerState",
			"name": "qiskit.quantum_info.StabilizerState",
			"type": "class",
			"description": "StabilizerState class. Stabilizer simulator using the convention from reference \\[1]. Based on the internal class Clifford."
		},
		{
			"id": "qiskit.circuit.library.RXGate",
			"name": "qiskit.circuit.library.RXGate",
			"type": "class",
			"description": "Single-qubit rotation about the X axis. Can be applied to a QuantumCircuit with the rx() method. Circuit symbol: ``text ┌───────┐ q_0: ┤ Rx(ϴ) ├ └───────┘ ` Matrix representation: **Parameters** * **theta** (*ParameterValueType*) – The rotation angle."
		},
		{
			"id": "qiskit.circuit.library.qaoa_ansatz",
			"name": "qiskit.circuit.library.qaoa_ansatz",
			"type": "function",
			"description": "A generalized QAOA quantum circuit with a support of custom initial states and mixers."
		},
		{
			"id": "qiskit.circuit.library.LinearPauliRotationsGate",
			"name": "qiskit.circuit.library.LinearPauliRotationsGate",
			"type": "class",
			"description": "Linearly-controlled X, Y or Z rotation. For a register of state qubits , a target qubit and the basis 'Y' this circuit acts as: ``python q_0: ─────────────────────────■───────── ... ────────────────────── │ . │ q_(n-1): ─────────────────────────┼───────── ..."
		},
		{
			"id": "qiskit.synthesis.ProductFormula",
			"name": "qiskit.synthesis.ProductFormula",
			"type": "class",
			"description": "Product formula base class for the decomposition of non-commuting operator exponentials. LieTrotter and SuzukiTrotter inherit from this class. **Parameters** * **order** (*int*\")) – The order of the product formula. * **reps** (*int*\")) – The number of time steps."
		},
		{
			"id": "qiskit.circuit.WhileLoopOp",
			"name": "qiskit.circuit.WhileLoopOp",
			"type": "class",
			"description": "A circuit operation which repeatedly executes a subcircuit (body) until a condition (condition) evaluates as False. The classical bits used in condition must be a subset of those attached to body."
		},
		{
			"id": "qiskit.transpiler.passes.Optimize1qGates",
			"name": "qiskit.transpiler.passes.Optimize1qGates",
			"type": "class",
			"description": "Optimize chains of single-qubit u1, u2, u3 gates by combining them into a single gate. Optimize1qGates initializer. **Parameters** * **basis** (*list*\")*\\*[*str*\")*]*) – Basis gates to consider, e.g. \\[‘u3’, ‘cx’]."
		},
		{
			"id": "qiskit.transpiler.passes.LookaheadSwap",
			"name": "qiskit.transpiler.passes.LookaheadSwap",
			"type": "class",
			"description": "Map input circuit onto a backend topology via insertion of SWAPs. Implementation of Sven Jandura’s swap mapper submission for the 2018 Qiskit Developer Challenge, adapted to integrate into the transpiler architecture."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisV95",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisV95",
			"type": "class",
			"description": "A ripple-carry adder with a carry-out bit. This plugin name is:HalfAdder.ripple_v95 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. For an adder on 2 registers with qubits each, this plugin requires at least clean auxiliary qubit."
		},
		{
			"id": "qiskit.circuit.singleton",
			"name": "qiskit.circuit.singleton",
			"type": "module",
			"description": "A base class to use for Instruction objects that by default are singleton instances. This class should be used for instruction classes that have fixed definitions and do not contain any unique state."
		},
		{
			"id": "qiskit.passmanager.GenericPass",
			"name": "qiskit.passmanager.GenericPass",
			"type": "class",
			"description": "Base class of a single pass manager task. A pass instance can read and write to the provided PropertySet, and may modify the input pass manager IR. ## Methods ### execute Execute optimization task for input Qiskit IR. **Parameters** * **passmanager\\_ir** (*Any*\")) – Qiskit IR to optimize."
		},
		{
			"id": "qiskit.transpiler.passes.HighLevelSynthesis",
			"name": "qiskit.transpiler.passes.HighLevelSynthesis",
			"type": "class",
			"description": "Synthesize higher-level objects and unroll custom definitions. The input to this pass is a DAG that may contain higher-level objects, including abstract mathematical objects (e.g., objects of type LinearFunction), annotated operations (objects of type AnnotatedOperation), and custom gates."
		},
		{
			"id": "qiskit.transpiler.passes.CountOps",
			"name": "qiskit.transpiler.passes.CountOps",
			"type": "class",
			"description": "Count the operations in a DAG circuit. The result is saved in property_set['count_ops'] as an integer. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.PauliFeatureMap",
			"name": "qiskit.circuit.library.PauliFeatureMap",
			"type": "class",
			"description": "The Pauli Expansion circuit. The Pauli Expansion circuit is a data encoding circuit that transforms input data , where n is the feature_dimension, as Here, is a set of qubit indices that describes the connections in the feature map, is a set containing all these index sets, and ."
		},
		{
			"id": "qiskit.providers.basic_provider.BasicProviderJob",
			"name": "qiskit.providers.basic_provider.BasicProviderJob",
			"type": "class",
			"description": "BasicProviderJob class. Initializes the asynchronous job. **Parameters** * **backend** – the backend used to run the job. * **job\\_id** – a unique id in the context of the backend used to run the job. * **kwargs** – Any key value metadata to associate with this job."
		},
		{
			"id": "qiskit.transpiler.preset_passmanagers.plugin",
			"name": "qiskit.transpiler.preset_passmanagers.plugin",
			"type": "module",
			"description": "Get a list of installed plugins for a stage. **Parameters** **stage\\_name** (*str*\")) – The stage name to get the plugin names for **Returns** The list of installed plugin names for the specified stages **Return type** plugins **Raises** **TranspilerError** – If an invalid stage name is specified."
		},
		{
			"id": "qiskit.circuit.Gate",
			"name": "qiskit.circuit.Gate",
			"type": "class",
			"description": "Unitary gate. **Parameters** * **name** (*str*\")) – The name of the gate. * **num\\_qubits** (*int*\")) – The number of qubits the gate acts on. * **params** (*list*\")) – A list of parameters. * **label** (*str*\") *| None*) – An optional label for the gate."
		},
		{
			"id": "qiskit.circuit.InstructionSet",
			"name": "qiskit.circuit.InstructionSet",
			"type": "class",
			"description": "Instruction collection, and their contexts. New collection of instructions. The context (qargs and cargs that each instruction is attached to) is also stored separately for each instruction."
		},
		{
			"id": "qiskit.transpiler.passes.NumTensorFactors",
			"name": "qiskit.transpiler.passes.NumTensorFactors",
			"type": "class",
			"description": "Calculate the number of tensor factors of a DAG circuit. The result is saved in property_set['num_tensor_factors'] as an integer. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.TGate",
			"name": "qiskit.circuit.library.TGate",
			"type": "class",
			"description": "Single qubit T gate (Z\\*\\*0.25). It induces a phase, and is sometimes called the pi/8 gate (because of how the RZ(pi/4) matrix looks like). This is a non-Clifford gate and a fourth-root of Pauli-Z. Can be applied to a QuantumCircuit with the t() method."
		},
		{
			"id": "qiskit.circuit.library.CSdgGate",
			"name": "qiskit.circuit.library.CSdgGate",
			"type": "class",
			"description": "Controlled-S^dagger gate. Can be applied to a QuantumCircuit with the csdg() method. Circuit symbol: ``text q_0: ───■─── ┌──┴──┐ q_1: ┤ Sdg ├ └─────┘ ` Matrix representation: Create new CSdg gate. ## Attributes ### base\\_class Get the base class of this instruction."
		},
		{
			"id": "qiskit.primitives.StatevectorSampler",
			"name": "qiskit.primitives.StatevectorSampler",
			"type": "class",
			"description": "Simple implementation of BaseSamplerV2 using full state vector simulation. This class is implemented via Statevector which turns provided circuits into pure state vectors, and is therefore incompatible with mid-circuit measurements (although other implementations may be)."
		},
		{
			"id": "qiskit.circuit.classical",
			"name": "qiskit.circuit.classical",
			"type": "module",
			"description": "Root base class of all nodes in the expression tree. The base case should never be instantiated directly. This must not be subclassed by users; subclasses form the internal data of the representation of expressions, and it does not make sense to add more outside of Qiskit library code."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin",
			"name": "qiskit.transpiler.passes.synthesis.plugin",
			"type": "module",
			"description": "qiskit.transpiler.passes.synthesis.plugin This module defines the plugin interfaces for the synthesis transpiler passes in Qiskit."
		},
		{
			"id": "qiskit.circuit.BoxOp",
			"name": "qiskit.circuit.BoxOp",
			"type": "class",
			"description": "A scoped “box” of operations on a circuit that are treated atomically in the greater context. A “box” is a control-flow construct that is entered unconditionally."
		},
		{
			"id": "qiskit.providers.basic_provider.BasicSimulator",
			"name": "qiskit.providers.basic_provider.BasicSimulator",
			"type": "class",
			"description": "Python implementation of a basic (non-efficient) quantum simulator. **Parameters** * **provider** – An optional backwards reference to the provider object that the backend is from. * **target** (*Target* *| None*) – An optional target to configure the simulator."
		},
		{
			"id": "qiskit.circuit.library.ModularAdderGate",
			"name": "qiskit.circuit.library.ModularAdderGate",
			"type": "class",
			"description": "Compute the sum modulo of two -sized qubit registers."
		},
		{
			"id": "qiskit.circuit.library",
			"name": "qiskit.circuit.library",
			"type": "module",
			"description": "Return a dictionary mapping the name of standard gates and instructions to an object for that name."
		},
		{
			"id": "qiskit.circuit.library.SGate",
			"name": "qiskit.circuit.library.SGate",
			"type": "class",
			"description": "Single qubit S gate (Z\\*\\*0.5). It induces a phase, and is sometimes called the P gate (phase). This is a Clifford gate and a square-root of Pauli-Z. Can be applied to a QuantumCircuit with the s() method."
		},
		{
			"id": "qiskit.circuit.library.GRY",
			"name": "qiskit.circuit.library.GRY",
			"type": "class",
			"description": "Global RY gate. **Circuit symbol:** ``text ┌──────────┐ q_0: ┤0 ├ │ │ q_1: ┤1 GRY(ϴ) ├ │ │ q_2: ┤2 ├ └──────────┘ ` The global RY gate is native to atomic systems (ion traps, cold neutrals). The global RY can be applied to multiple qubits simultaneously."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.DefaultSynthesisLinearFunction",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.DefaultSynthesisLinearFunction",
			"type": "class",
			"description": "The default linear function synthesis plugin. This plugin name is :linear_function.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given LinearFunction."
		},
		{
			"id": "qiskit.transpiler.passes.GateDirection",
			"name": "qiskit.transpiler.passes.GateDirection",
			"type": "class",
			"description": "Modify asymmetric gates to match the hardware coupling direction."
		},
		{
			"id": "qiskit.quantum_info.Statevector",
			"name": "qiskit.quantum_info.Statevector",
			"type": "class",
			"description": "Statevector class Initialize a statevector object. **Parameters** * **data** (*np.ndarray |* *list*\") *|**Statevector* *|**Operator* *|**QuantumCircuit* *|**circuit.instruction.Instruction*) – Data from which the statevector can be constructed."
		},
		{
			"id": "qiskit.quantum_info.Choi",
			"name": "qiskit.quantum_info.Choi",
			"type": "class",
			"description": "Choi-matrix representation of a Quantum Channel. The Choi-matrix representation of a quantum channel is a matrix Evolution of a DensityMatrix with respect to the Choi-matrix is given by where is the partial_trace() over subsystem 1. See reference \\[1] for further details. **References** 1. C.J."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.BasicSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.BasicSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on sorting. This plugin name is :permutation.basic which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Permutation."
		},
		{
			"id": "qiskit.circuit.library.HalfAdderGate",
			"name": "qiskit.circuit.library.HalfAdderGate",
			"type": "class",
			"description": "Compute the sum of two equally-sized qubit registers, including a carry-out bit."
		},
		{
			"id": "qiskit.circuit.library.CRZGate",
			"name": "qiskit.circuit.library.CRZGate",
			"type": "class",
			"description": "Controlled-RZ gate. This is a diagonal but non-symmetric gate that induces a phase on the state of the target qubit, depending on the control state. Can be applied to a QuantumCircuit with the crz() method."
		},
		{
			"id": "qiskit.transpiler.passes.FilterOpNodes",
			"name": "qiskit.transpiler.passes.FilterOpNodes",
			"type": "class",
			"description": "Remove all operations that match a filter function This transformation pass is used to remove any operations that matches a the provided filter function. **Parameters** **predicate** – A given callable that will be passed the DAGOpNode for each node in the DAGCircuit."
		},
		{
			"id": "qiskit.circuit.library.hamiltonian_variational_ansatz",
			"name": "qiskit.circuit.library.hamiltonian_variational_ansatz",
			"type": "function",
			"description": "Construct a Hamiltonian variational ansatz. For a Hamiltonian where the terms consist of only commuting Paulis, but the terms do not commute among each other , the Hamiltonian variational ansatz (HVA) is where the exponentials are implemented exactly \\[1, 2]."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNoAuxV24",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNoAuxV24",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the implementation for MCPhaseGate, which is in turn based on the paper by Vale et al. (2024). See \\[1] for details. This plugin name is :mcx.noaux_v24 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.passmanager.DoWhileController",
			"name": "qiskit.passmanager.DoWhileController",
			"type": "class",
			"description": "Run the given tasks in a loop until the do_while condition on the property set becomes False. The given tasks will always run at least once, and on iteration of the loop, all the tasks will be run (with the exception of a failure state being set). Create new flow controller."
		},
		{
			"id": "qiskit.quantum_info",
			"name": "qiskit.quantum_info",
			"type": "module",
			"description": "Return the average gate fidelity of a noisy quantum channel. The average gate fidelity is given by where is the process_fidelity() of the input quantum *channel* with a *target* unitary , and is the dimension of the *channel*."
		},
		{
			"id": "qiskit.circuit.library.efficient_su2",
			"name": "qiskit.circuit.library.efficient_su2",
			"type": "function",
			"description": "The hardware-efficient 2-local circuit. The efficient_su2 circuit consists of layers of single qubit operations spanned by and CX entanglements."
		},
		{
			"id": "qiskit.transpiler.passes.ASAPScheduleAnalysis",
			"name": "qiskit.transpiler.passes.ASAPScheduleAnalysis",
			"type": "class",
			"description": "ASAP Scheduling pass, which schedules the start time of instructions as early as possible. See the Scheduling of circuits section in the qiskit.transpiler module documentation for a more detailed description. Scheduler initializer."
		},
		{
			"id": "qiskit.providers.fake_provider",
			"name": "qiskit.providers.fake_provider",
			"type": "module",
			"description": "qiskit.providers.fake_provider"
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.WeightedSumSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.WeightedSumSynthesisDefault",
			"type": "class",
			"description": "Synthesize a WeightedSumGate using the default synthesis algorithm. This plugin name is:WeightedSum.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. This default plugin requires auxiliary qubits."
		},
		{
			"id": "qiskit.transpiler.passes.BasisTranslator",
			"name": "qiskit.transpiler.passes.BasisTranslator",
			"type": "class",
			"description": "Translates gates to a target basis by searching for a set of translations from a given EquivalenceLibrary. This pass operates in several steps: * Determine the source basis from the input circuit."
		},
		{
			"id": "qiskit.circuit.library.random_iqp",
			"name": "qiskit.circuit.library.random_iqp",
			"type": "function",
			"description": "A random instantaneous quantum polynomial time (IQP) circuit. See iqp() for more details on the IQP circuit. Example: ``python from qiskit.circuit.library import random_iqp circuit = random_iqp(3) circuit.draw(\"mpl\") `` !Circuit diagram output by the previous code."
		},
		{
			"id": "qiskit.transpiler.passes.SetIOLatency",
			"name": "qiskit.transpiler.passes.SetIOLatency",
			"type": "class",
			"description": "Set IOLatency information to the input circuit. The clbit_write_latency and conditional_latency are added to the property set of pass manager. This information can be shared among the passes that perform scheduling on instructions acting on classical registers."
		},
		{
			"id": "qiskit.quantum_info.SparseObservable",
			"name": "qiskit.quantum_info.SparseObservable",
			"type": "class",
			"description": "An observable over Pauli bases that stores its data in a qubit-sparse format. ## Mathematics This observable represents a sum over strings of the Pauli operators and Pauli-eigenstate projectors, with each term weighted by some complex number."
		},
		{
			"id": "qiskit.quantum_info.PhasedQubitSparsePauliList",
			"name": "qiskit.quantum_info.PhasedQubitSparsePauliList",
			"type": "class",
			"description": "A list of Pauli operators with phases stored in a qubit-sparse format. ## Representation Each individual Pauli operator in the list is a tensor product of single-qubit Pauli operators of the form , for , and an integer called the phase exponent."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.KMSSynthesisLinearFunction",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.KMSSynthesisLinearFunction",
			"type": "class",
			"description": "Linear function synthesis plugin based on the Kutin-Moulton-Smithline method. This plugin name is :linear_function.kms which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.IQP",
			"name": "qiskit.circuit.library.IQP",
			"type": "class",
			"description": "Instantaneous quantum polynomial (IQP) circuit. The circuit consists of a column of Hadamard gates, a column of powers of T gates, a sequence of powers of CS gates (up to of them), and a final column of Hadamard gates, as introduced in \\[1]."
		},
		{
			"id": "qiskit.circuit.library.ZGate",
			"name": "qiskit.circuit.library.ZGate",
			"type": "class",
			"description": "The single-qubit Pauli-Z gate (). Can be applied to a QuantumCircuit with the z() method. Matrix representation: Circuit symbol: ``text ┌───┐ q_0: ┤ Z ├ └───┘ ` Equivalent to a radian rotation about the Z axis. A global phase difference exists between the definitions of and ."
		},
		{
			"id": "qiskit.circuit.Instruction",
			"name": "qiskit.circuit.Instruction",
			"type": "class",
			"description": "Generic quantum instruction. The parameters duration and unit are deprecated since Qiskit 1.3, and they will be removed in 2.0 or later. An instruction’s duration is defined in a backend’s Target object."
		},
		{
			"id": "qiskit.primitives.BackendSamplerV2",
			"name": "qiskit.primitives.BackendSamplerV2",
			"type": "class",
			"description": "Evaluates bitstrings for provided quantum circuits The BackendSamplerV2 class is a generic implementation of the BaseSamplerV2 interface that is used to wrap a BackendV2 object in the class BaseSamplerV2 API."
		},
		{
			"id": "qiskit.transpiler.TransformationPass",
			"name": "qiskit.transpiler.TransformationPass",
			"type": "class",
			"description": "A transformation pass: change DAG, not property set. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis2CleanKG24",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis2CleanKG24",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and Gidney (2024). See \\[1] for details. The plugin name is :mcx.2_clean_kg24 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisC04",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisC04",
			"type": "class",
			"description": "A ripple-carry adder with a carry-in and a carry-out bit. This plugin name is:FullAdder.ripple_c04 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. This plugin requires no auxiliary qubits. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNCleanM15",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNCleanM15",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Maslov (2016). See \\[1] for details. This plugin name is :mcx.n_clean_m15 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.UnitaryOverlap",
			"name": "qiskit.circuit.library.UnitaryOverlap",
			"type": "class",
			"description": "Circuit that returns the overlap between two unitaries . The input quantum circuits must represent unitary operations, since they must be invertible."
		},
		{
			"id": "qiskit.primitives.StatevectorEstimator",
			"name": "qiskit.primitives.StatevectorEstimator",
			"type": "class",
			"description": "Simple implementation of BaseEstimatorV2 with full state vector simulation. This class is implemented via Statevector which turns provided circuits into pure state vectors."
		},
		{
			"id": "qiskit.quantum_info.Chi",
			"name": "qiskit.quantum_info.Chi",
			"type": "class",
			"description": "Pauli basis Chi-matrix representation of a quantum channel. The Chi-matrix representation of an -qubit quantum channel is a matrix such that the evolution of a DensityMatrix is given by where is the -qubit Pauli basis in lexicographic order."
		},
		{
			"id": "qiskit.providers.BackendV2",
			"name": "qiskit.providers.BackendV2",
			"type": "class",
			"description": "Abstract class for Backends This abstract class is to be used for all Backend objects created by a provider. This version differs from earlier abstract Backend classes in that the configuration attribute no longer exists."
		},
		{
			"id": "qiskit.visualization.visualize_transition",
			"name": "qiskit.visualization.visualize_transition",
			"type": "function",
			"description": "Creates animation showing transitions between states of a single qubit by applying quantum gates. The function qiskit.visualization.transition_visualization.visualize_transition() is deprecated as of Qiskit 1.2.0. It will be removed in the 2.0 release."
		},
		{
			"id": "qiskit.primitives.PubResult",
			"name": "qiskit.primitives.PubResult",
			"type": "class",
			"description": "Result of Primitive Unified Bloc. Initialize a pub result. **Parameters** * **data** (*DataBin*) – Result data. * **metadata** (*dict*\")*\\*[*str*\")*, Any] | None*) – Metadata specific to this pub. Keys are expected to be strings. ## Attributes ### data Result data for the pub."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisV17",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisV17",
			"type": "class",
			"description": "A modular adder (modulo ) without any ancillary qubits. The plugin name is :ModularAdder.v17 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. This plugin requires no auxiliary qubits. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisD00",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisD00",
			"type": "class",
			"description": "A QFT-based adder with a carry-in and a carry-out bit. This plugin name is:HalfAdder.qft_d00 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.transpiler.passes.ALAPScheduleAnalysis",
			"name": "qiskit.transpiler.passes.ALAPScheduleAnalysis",
			"type": "class",
			"description": "ALAP Scheduling pass, which schedules the **stop** time of instructions as late as possible. See the Scheduling of circuits section in the qiskit.transpiler module documentation for a more detailed explanation. Scheduler initializer."
		},
		{
			"id": "qiskit.circuit.library.QAOAAnsatz",
			"name": "qiskit.circuit.library.QAOAAnsatz",
			"type": "class",
			"description": "A generalized QAOA quantum circuit with a support of custom initial states and mixers. References: \\[1] Farhi et al., A Quantum Approximate Optimization Algorithm."
		},
		{
			"id": "qiskit.circuit.library.GlobalPhaseGate",
			"name": "qiskit.circuit.library.GlobalPhaseGate",
			"type": "class",
			"description": "The global phase gate (). Can be applied to a QuantumCircuit Mathematical representation: **Parameters** * **phase** (*ParameterExpression* *|**float*\")) – The value of phase it takes. * **label** (*str*\") *| None*) – An optional label for the gate."
		},
		{
			"id": "qiskit.transpiler.passes.CollectMultiQBlocks",
			"name": "qiskit.transpiler.passes.CollectMultiQBlocks",
			"type": "class",
			"description": "Collect sequences of uninterrupted gates acting on groups of qubits. max_block_size specifies the maximum number of qubits that can be acted upon by any single group of gates Traverse the DAG and find blocks of gates that act consecutively on groups of qubits."
		},
		{
			"id": "qiskit.transpiler.passes.VF2Layout",
			"name": "qiskit.transpiler.passes.VF2Layout",
			"type": "class",
			"description": "A pass for choosing a Layout of a circuit onto a Coupling graph, as a subgraph isomorphism problem, solved by VF2++. If a solution is found that means there is a “perfect layout” and that no further swap mapping or routing is needed."
		},
		{
			"id": "qiskit.circuit.ParameterExpression",
			"name": "qiskit.circuit.ParameterExpression",
			"type": "class",
			"description": "A parameter expression. This is backed by Qiskit’s symbolic expression engine and a cache for the parameters inside the expression. ## Attributes ### parameters Get the parameters present in the expression."
		},
		{
			"id": "qiskit.transpiler.InstructionProperties",
			"name": "qiskit.transpiler.InstructionProperties",
			"type": "class",
			"description": "A representation of the properties of a gate implementation. This class provides the optional properties that a backend can provide about an instruction. These represent the set that the transpiler can currently work with if present."
		},
		{
			"id": "qiskit.transpiler.passes.LinearFunctionsToPermutations",
			"name": "qiskit.transpiler.passes.LinearFunctionsToPermutations",
			"type": "class",
			"description": "Promotes linear functions to permutations when possible. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.quantum_info.DensityMatrix",
			"name": "qiskit.quantum_info.DensityMatrix",
			"type": "class",
			"description": "DensityMatrix class Initialize a density matrix object."
		},
		{
			"id": "qiskit.circuit.library.PiecewisePolynomialPauliRotations",
			"name": "qiskit.circuit.library.PiecewisePolynomialPauliRotations",
			"type": "class",
			"description": "Piecewise-polynomially-controlled Pauli rotations. This class implements a piecewise polynomial (not necessarily continuous) function, , on qubit amplitudes, which is defined through breakpoints and coefficients as follows. Suppose the breakpoints are a subset of , where is the number of state qubits."
		},
		{
			"id": "qiskit.circuit.library.CPhaseGate",
			"name": "qiskit.circuit.library.CPhaseGate",
			"type": "class",
			"description": "Controlled-Phase gate. This is a diagonal and symmetric gate that induces a phase on the state of the target qubit, depending on the control state. Can be applied to a QuantumCircuit with the cp() method."
		},
		{
			"id": "qiskit.quantum_info.Clifford",
			"name": "qiskit.quantum_info.Clifford",
			"type": "class",
			"description": "An N-qubit unitary operator from the Clifford group. An N-qubit Clifford operator takes Paulis to Paulis via conjugation (up to a global phase)."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin",
			"name": "qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin",
			"type": "class",
			"description": "An AQC-based Qiskit unitary synthesis plugin. This plugin is invoked by transpile() when the unitary_synthesis_method parameter is set to \"aqc\"."
		},
		{
			"id": "qiskit.transpiler.passes.StarPreRouting",
			"name": "qiskit.transpiler.passes.StarPreRouting",
			"type": "class",
			"description": "Run star to linear pre-routing This pass is a logical optimization pass that rewrites any solely 2q gate star connectivity subcircuit as a linear connectivity equivalent with swaps."
		},
		{
			"id": "qiskit.transpiler.passes.Optimize1qGatesDecomposition",
			"name": "qiskit.transpiler.passes.Optimize1qGatesDecomposition",
			"type": "class",
			"description": "Optimize chains of single-qubit gates by combining them into a single gate."
		},
		{
			"id": "qiskit.circuit.library.BitwiseXorGate",
			"name": "qiskit.circuit.library.BitwiseXorGate",
			"type": "class",
			"description": "An n-qubit gate for bitwise xor-ing the input with some integer amount. The amount is xor-ed in bitstring form with the input. This gate can also represent addition by amount over the finite field GF(2). Reference Circuit: !Diagram illustrating the previously described circuit."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisDefault",
			"type": "class",
			"description": "A default decomposition for MCMT gates. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.transpiler.passes.CSPLayout",
			"name": "qiskit.transpiler.passes.CSPLayout",
			"type": "class",
			"description": "If possible, chooses a Layout as a CSP, using backtracking. If possible, chooses a Layout as a CSP, using backtracking. If not possible, does not set the layout property."
		},
		{
			"id": "qiskit.circuit.library.RCCXGate",
			"name": "qiskit.circuit.library.RCCXGate",
			"type": "class",
			"description": "The simplified Toffoli gate, also referred to as Margolus gate. The simplified Toffoli gate implements the Toffoli gate up to relative phases. This implementation requires three CX gates which is the minimal amount possible, as shown in https://arxiv.org/abs/quant-ph/0312225."
		},
		{
			"id": "qiskit.synthesis.TwoQubitWeylDecomposition",
			"name": "qiskit.synthesis.TwoQubitWeylDecomposition",
			"type": "class",
			"description": "Two-qubit Weyl decomposition. Decompose two-qubit unitary where and we stay in the “Weyl Chamber” This class avoids some problems of numerical instability near high-symmetry loci within the Weyl chamber."
		},
		{
			"id": "qiskit.circuit.library.CCZGate",
			"name": "qiskit.circuit.library.CCZGate",
			"type": "class",
			"description": "CCZ gate. This is a symmetric gate. Can be applied to a QuantumCircuit with the ccz() method. Circuit symbol: ``text q_0: ─■─ │ q_1: ─■─ │ q_2: ─■─ ` Matrix representation: In the computational basis, this gate flips the phase of the target qubit if the control qubits are in the state."
		},
		{
			"id": "qiskit.circuit.library.PauliEvolutionGate",
			"name": "qiskit.circuit.library.PauliEvolutionGate",
			"type": "class",
			"description": "Time-evolution of an operator consisting of Paulis. For an Hermitian operator consisting of Pauli terms and (real) evolution time this gate represents the unitary The evolution gates are related to the Pauli rotation gates by a factor of 2."
		},
		{
			"id": "qiskit.circuit.BreakLoopOp",
			"name": "qiskit.circuit.BreakLoopOp",
			"type": "class",
			"description": "A circuit operation which, when encountered, jumps to the end of the nearest enclosing loop. Can only be used inside loops. **Parameters** * **num\\_qubits** (*int*\")) – the number of qubits this affects. * **num\\_clbits** (*int*\")) – the number of qubits this affects."
		},
		{
			"id": "qiskit.transpiler.passes.ConstrainedReschedule",
			"name": "qiskit.transpiler.passes.ConstrainedReschedule",
			"type": "class",
			"description": "Rescheduler pass that updates node start times to conform to the hardware alignments. This pass shifts DAG node start times previously scheduled with one of the scheduling passes, e.g. ASAPScheduleAnalysis or ALAPScheduleAnalysis, so that every instruction start time satisfies alignment constraints."
		},
		{
			"id": "qiskit.circuit.library.QuadraticForm",
			"name": "qiskit.circuit.library.QuadraticForm",
			"type": "class",
			"description": "Implements a quadratic form on binary variables encoded in qubit registers. A quadratic form on binary variables is a quadratic function acting on a binary variable of bits, ."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPluginManager",
			"name": "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPluginManager",
			"type": "class",
			"description": "Class tracking the installed high-level-synthesis plugins. ## Methods ### method Returns the plugin for op_name and method_name. ### method\\_names Returns plugin methods for op\\_name. ### op\\_names Returns the names of high-level-objects with available synthesis methods."
		},
		{
			"id": "qiskit.circuit.library.PolynomialPauliRotations",
			"name": "qiskit.circuit.library.PolynomialPauliRotations",
			"type": "class",
			"description": "A circuit implementing polynomial Pauli rotations. For a polynomial , a basis state and a target qubit this operator acts as: Let n be the number of qubits representing the state, d the degree of p(x) and q\\_i the qubits, where q\\_0 is the least significant qubit."
		},
		{
			"id": "qiskit.circuit.library.MCXVChain",
			"name": "qiskit.circuit.library.MCXVChain",
			"type": "class",
			"description": "Implement the multi-controlled X gate using a V-chain of CX gates."
		},
		{
			"id": "qiskit.visualization.circuit_drawer",
			"name": "qiskit.visualization.circuit_drawer",
			"type": "function",
			"description": "Draw the quantum circuit. Use the output parameter to choose the drawing format: **text**: ASCII art TextDrawing that can be printed in the console. **mpl**: images with color rendered purely in Python using matplotlib. **latex**: high-quality images compiled via latex."
		},
		{
			"id": "qiskit.circuit.library.GMS",
			"name": "qiskit.circuit.library.GMS",
			"type": "class",
			"description": "Global Mølmer–Sørensen gate. Circuit symbol: ``text ┌───────────┐ q_0: ┤0 ├ │ │ q_1: ┤1 GMS ├ │ │ q_2: ┤2 ├ └───────────┘ ` Expanded Circuit: !Diagram illustrating the previously described circuit. The Mølmer–Sørensen gate is native to ion-trap systems."
		},
		{
			"id": "qiskit.quantum_info.Kraus",
			"name": "qiskit.quantum_info.Kraus",
			"type": "class",
			"description": "Kraus representation of a quantum channel."
		},
		{
			"id": "qiskit.circuit.library.EfficientSU2",
			"name": "qiskit.circuit.library.EfficientSU2",
			"type": "class",
			"description": "The hardware efficient SU(2) 2-local circuit. The EfficientSU2 circuit consists of layers of single qubit operations spanned by SU(2) and entanglements."
		},
		{
			"id": "qiskit.circuit.library.UCGate",
			"name": "qiskit.circuit.library.UCGate",
			"type": "class",
			"description": "Uniformly controlled gate (also called multiplexed gate). These gates can have several control qubits and a single target qubit. If the k control qubits are in the state (in the computational basis), a single-qubit unitary is applied to the target qubit."
		},
		{
			"id": "qiskit.quantum_info.PauliLindbladMap",
			"name": "qiskit.quantum_info.PauliLindbladMap",
			"type": "class",
			"description": "A Pauli Lindblad map stored in a qubit-sparse format. ## Mathematics A Pauli-Lindblad map is a linear map acting on density matrices on -qubits of the form: where is a subset of -qubit Pauli operators, and the rates, or coefficients, are real numbers."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisLine",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisLine",
			"type": "class",
			"description": "Synthesis plugin for QFT gates using linear connectivity. This plugin name is :qft.line which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. Note that the plugin mechanism is not applied if the gate is called qft but is not an instance of QFTGate."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis",
			"name": "qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis",
			"type": "class",
			"description": "A Solovay-Kitaev Qiskit unitary synthesis plugin. This plugin is invoked by transpile() when the unitary_synthesis_method parameter is set to \"sk\"."
		},
		{
			"id": "qiskit.transpiler.passes.Depth",
			"name": "qiskit.transpiler.passes.Depth",
			"type": "class",
			"description": "Calculate the depth of a DAG circuit. **Parameters** **recurse** – whether to allow recursion into control flow. If this is False (default), the pass will throw an error when control flow is present, to avoid returning a number with little meaning."
		},
		{
			"id": "qiskit.synthesis.EvolutionSynthesis",
			"name": "qiskit.synthesis.EvolutionSynthesis",
			"type": "class",
			"description": "Interface for evolution synthesis algorithms. ## Attributes ### settings Return the settings in a dictionary, which can be used to reconstruct the object. **Returns** A dictionary containing the settings of this product formula."
		},
		{
			"id": "qiskit.transpiler.preset_passmanagers",
			"name": "qiskit.transpiler.preset_passmanagers",
			"type": "module",
			"description": "Level 0 pass manager: no explicit optimization other than mapping to backend. This pass manager applies the user-given initial layout. If none is given, a trivial layout consisting of mapping the i-th virtual qubit to the i-th physical qubit is used."
		},
		{
			"id": "qiskit.quantum_info.pauli_basis",
			"name": "qiskit.quantum_info.pauli_basis",
			"type": "function",
			"description": "Return the ordered PauliList for the n-qubit Pauli basis."
		},
		{
			"id": "qiskit.transpiler.passes.CommutativeCancellation",
			"name": "qiskit.transpiler.passes.CommutativeCancellation",
			"type": "class",
			"description": "Cancel the redundant (self-adjoint) gates through commutation relations. Pass for cancelling self-inverse gates/rotations. The cancellation utilizes the commutation relations in the circuit. Gates considered include: ``python H, X, Y, Z, CX, CY, CZ ` CommutativeCancellation initializer."
		},
		{
			"id": "qiskit.circuit.library.PiecewiseLinearPauliRotations",
			"name": "qiskit.circuit.library.PiecewiseLinearPauliRotations",
			"type": "class",
			"description": "Piecewise-linearly-controlled Pauli rotations. For a piecewise linear (not necessarily continuous) function , which is defined through breakpoints, slopes and offsets as follows. Suppose the breakpoints are a subset of , where is the number of state qubits."
		},
		{
			"id": "qiskit.circuit.library.C3SXGate",
			"name": "qiskit.circuit.library.C3SXGate",
			"type": "class",
			"description": "The 3-qubit controlled sqrt-X gate. This implementation is based on Page 17 of \\[1]. **References** \\[1] Barenco et al., 1995. https://arxiv.org/pdf/quant-ph/9503016.pdf Create a new 3-qubit controlled sqrt-X gate."
		},
		{
			"id": "qiskit.transpiler.passes.ConsolidateBlocks",
			"name": "qiskit.transpiler.passes.ConsolidateBlocks",
			"type": "class",
			"description": "Replace each block of consecutive gates by a single Unitary node. Pass to consolidate sequences of uninterrupted gates acting on the same qubits into a Unitary node, to be resynthesized later, to a potentially more optimal subcircuit."
		},
		{
			"id": "qiskit.circuit.library.SXGate",
			"name": "qiskit.circuit.library.SXGate",
			"type": "class",
			"description": "The single-qubit Sqrt(X) gate (). Can be applied to a QuantumCircuit with the sx() method. Matrix representation: Circuit symbol: ``text ┌────┐ q_0: ┤ √X ├ └────┘ ` A global phase difference exists between the definitions of and . **Parameters** **label** – An optional label for the gate."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1DirtyKG24",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1DirtyKG24",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and Gidney (2024). See \\[1] for details. The plugin name is :mcx.1_dirty_kg24 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis2DirtyKG24",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis2DirtyKG24",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and Gidney (2024). See \\[1] for details. The plugin name is :mcx.2_dirty_kg24 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.SdgGate",
			"name": "qiskit.circuit.library.SdgGate",
			"type": "class",
			"description": "Single qubit S-adjoint gate (\\~Z\\*\\*0.5). It induces a phase. This is a Clifford gate and a square-root of Pauli-Z. Can be applied to a QuantumCircuit with the sdg() method. Matrix representation: Circuit symbol: ``text ┌─────┐ q_0: ┤ Sdg ├ └─────┘ ` Equivalent to a radian rotation about the Z axis."
		},
		{
			"id": "qiskit.dagcircuit.DAGDepNode",
			"name": "qiskit.dagcircuit.DAGDepNode",
			"type": "class",
			"description": "Object to represent the information at a node in the DAGDependency(). It is used as the return value from \\*\\_nodes() functions and can be supplied to functions that take a node."
		},
		{
			"id": "qiskit.providers.JobStatus",
			"name": "qiskit.providers.JobStatus",
			"type": "class",
			"description": "Class for job status enumerated type. ## Attributes ### INITIALIZING ### QUEUED ### VALIDATING ### RUNNING ### CANCELLED ### DONE ### ERROR"
		},
		{
			"id": "qiskit.circuit.library.iSwapGate",
			"name": "qiskit.circuit.library.iSwapGate",
			"type": "class",
			"description": "iSWAP gate. A 2-qubit XX+YY interaction. This is a Clifford and symmetric gate. Its action is to swap two qubit states and phase the and amplitudes by i. Can be applied to a QuantumCircuit with the iswap() method."
		},
		{
			"id": "qiskit.circuit.ForLoopOp",
			"name": "qiskit.circuit.ForLoopOp",
			"type": "class",
			"description": "A circuit operation which repeatedly executes a subcircuit (body) parameterized by a parameter loop_parameter through the set of integer values provided in indexset. **Parameters** * **indexset** (*Iterable\\*[*int*\")*]*) – A collection of integers to loop over."
		},
		{
			"id": "qiskit.circuit.library.Isometry",
			"name": "qiskit.circuit.library.Isometry",
			"type": "class",
			"description": "Decomposition of arbitrary isometries from to qubits. In particular, this allows to decompose unitaries (m=n) and to do state preparation (). The decomposition is based on \\[1]. References: \\[1] Iten et al., Quantum circuits for isometries (2016). Phys. Rev. A 93, 032318."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.TokenSwapperSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.TokenSwapperSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on the token swapper algorithm. This plugin name is :permutation.token_swapper which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. In more detail, this plugin is used to synthesize objects of type PermutationGate."
		},
		{
			"id": "qiskit.circuit.library.QFTGate",
			"name": "qiskit.circuit.library.QFTGate",
			"type": "class",
			"description": "Quantum Fourier Transform Gate. The Quantum Fourier Transform (QFT) on qubits is the operation **Parameters** **num\\_qubits** (*int*\")) – The number of qubits on which the QFT acts. ## Attributes ### base\\_class Get the base class of this instruction."
		},
		{
			"id": "qiskit.transpiler.passes.Size",
			"name": "qiskit.transpiler.passes.Size",
			"type": "class",
			"description": "Calculate the size of a DAG circuit. The result is saved in property_set['size'] as an integer. **Parameters** **recurse** – whether to allow recursion into control flow."
		},
		{
			"id": "qiskit.circuit.library.FunctionalPauliRotations",
			"name": "qiskit.circuit.library.FunctionalPauliRotations",
			"type": "class",
			"description": "Base class for functional Pauli rotations. **Parameters** * **num\\_state\\_qubits** (*int*\") *| None*) – The number of qubits representing the state . * **basis** (*str*\")) – The kind of Pauli rotation to use. Must be ‘X’, ‘Y’ or ‘Z’. * **name** (*str*\")) – The name of the circuit object."
		},
		{
			"id": "qiskit.synthesis.XXDecomposer",
			"name": "qiskit.synthesis.XXDecomposer",
			"type": "class",
			"description": "A class for optimal decomposition of 2-qubit unitaries into 2-qubit basis gates of XX type (i.e., each locally equivalent to for a possibly varying ). **Parameters** * **basis\\_fidelity** (*dict*\") *|**float*\")) – available strengths and fidelity of each."
		},
		{
			"id": "qiskit.quantum_info.CNOTDihedral",
			"name": "qiskit.quantum_info.CNOTDihedral",
			"type": "class",
			"description": "An N-qubit operator from the CNOT-Dihedral group. > The CNOT-Dihedral group is generated by the quantum gates, CXGate, TGate, and XGate. > > **Representation** > > An -qubit CNOT-Dihedral operator is stored as an affine function and a phase polynomial, based on the convention in references \\[1, 2]."
		},
		{
			"id": "qiskit.providers.JobV1",
			"name": "qiskit.providers.JobV1",
			"type": "class",
			"description": "Class to handle jobs This first version of the Backend abstract class is written to be mostly backwards compatible with the legacy providers interface. This was done to ease the transition for users and provider maintainers to the new versioned providers."
		},
		{
			"id": "qiskit.visualization.plot_state_qsphere",
			"name": "qiskit.visualization.plot_state_qsphere",
			"type": "function",
			"description": "Plot the qsphere representation of a quantum state. Here, the size of the points is proportional to the probability of the corresponding term in the state and the color represents the phase. **Parameters** * **state** (*Statevector* *or**DensityMatrix* *or ndarray*) – an N-qubit quantum state."
		},
		{
			"id": "qiskit.dagcircuit.BlockCollapser",
			"name": "qiskit.dagcircuit.BlockCollapser",
			"type": "class",
			"description": "This class implements various strategies of consolidating blocks of nodes in a DAG (direct acyclic graph). It works both with the DAGCircuit and DAGDependency DAG representations. **Parameters** **dag** (*Union\\*[*DAGCircuit**,* *DAGDependency**]*) – The input DAG."
		},
		{
			"id": "qiskit.circuit.library.TdgGate",
			"name": "qiskit.circuit.library.TdgGate",
			"type": "class",
			"description": "Single qubit T-adjoint gate (\\~Z\\*\\*0.25). It induces a phase. This is a non-Clifford gate and a fourth-root of Pauli-Z. Can be applied to a QuantumCircuit with the tdg() method."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin.high_level_synthesis_plugin_names",
			"name": "qiskit.transpiler.passes.synthesis.plugin.high_level_synthesis_plugin_names",
			"type": "function",
			"description": "Return a list of plugin names installed for a given high level object name **Parameters** **op\\_name** (*str*\")) – The operation name to find the installed plugins for."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.LayerSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.LayerSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Bravyi-Maslov method to synthesize Cliffords into layers. This plugin name is :clifford.layers which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Clifford."
		},
		{
			"id": "qiskit.circuit.library.RYGate",
			"name": "qiskit.circuit.library.RYGate",
			"type": "class",
			"description": "Single-qubit rotation about the Y axis. Can be applied to a QuantumCircuit with the ry() method. Circuit symbol: ``text ┌───────┐ q_0: ┤ Ry(ϴ) ├ └───────┘ ` Matrix representation: **Parameters** * **theta** (*ParameterValueType*) – The rotation angle."
		},
		{
			"id": "qiskit.dagcircuit.DAGDependency",
			"name": "qiskit.dagcircuit.DAGDependency",
			"type": "class",
			"description": "Object to represent a quantum circuit as a Directed Acyclic Graph (DAG) via operation dependencies (i.e. lack of commutation). The nodes in the graph are operations represented by quantum gates. The edges correspond to non-commutation between two operations (i.e. a dependency)."
		},
		{
			"id": "qiskit.result.Counts",
			"name": "qiskit.result.Counts",
			"type": "class",
			"description": "A class to store a counts result from a circuit execution. Build a counts object **Parameters** * **data** (*dict*\")) – The dictionary input for the counts. Where the keys represent a measured classical value and the value is an integer the number of shots with that result."
		},
		{
			"id": "qiskit.circuit.library.PhaseEstimation",
			"name": "qiskit.circuit.library.PhaseEstimation",
			"type": "class",
			"description": "Phase Estimation circuit. In the Quantum Phase Estimation (QPE) algorithm \\[1, 2, 3], the Phase Estimation circuit is used to estimate the phase of an eigenvalue of a unitary operator , provided with the corresponding eigenstate ."
		},
		{
			"id": "qiskit.transpiler.PassManager",
			"name": "qiskit.transpiler.PassManager",
			"type": "class",
			"description": "Manager for a set of Passes and their scheduling during transpilation. Initialize an empty pass manager object. **Parameters** * **passes** (*Task |* *list*\")*\\[Task]*) – A pass set to be added to the pass manager schedule."
		},
		{
			"id": "qiskit.circuit.library.RZGate",
			"name": "qiskit.circuit.library.RZGate",
			"type": "class",
			"description": "Single-qubit rotation about the Z axis. This is a diagonal gate. It can be implemented virtually in hardware via framechanges (i.e. at zero error and duration). Can be applied to a QuantumCircuit with the rz() method."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.FastCNOTUnitObjective",
			"name": "qiskit.synthesis.unitary.aqc.FastCNOTUnitObjective",
			"type": "class",
			"description": "Implementation of objective function and gradient calculator, which is similar to DefaultCNOTUnitObjective but several times faster. **Parameters** * **num\\_qubits** (*int*\")) – number of qubits. * **cnots** (*ndarray*\")) – a CNOT structure to be used in the optimization procedure."
		},
		{
			"id": "qiskit.primitives.SamplerResult",
			"name": "qiskit.primitives.SamplerResult",
			"type": "class",
			"description": "Result of Sampler V1. ``python result = sampler.run(circuits, params).result() ` where the i-th elements of result correspond to the circuit given by circuits[i], and the parameter values bounds by params[i]."
		},
		{
			"id": "qiskit.circuit.library.MCMT",
			"name": "qiskit.circuit.library.MCMT",
			"type": "class",
			"description": "The multi-controlled multi-target gate, for an arbitrary singly controlled target gate."
		},
		{
			"id": "qiskit.transpiler.passes",
			"name": "qiskit.transpiler.passes",
			"type": "module",
			"description": "A global instance of WrapAngleRegistry that is used by default by WrapAngles when no explicit registry is specified. See the documentation of WrapAngles for how to add entries to a registry."
		},
		{
			"id": "qiskit.circuit.library.GRZ",
			"name": "qiskit.circuit.library.GRZ",
			"type": "class",
			"description": "Global RZ gate. **Circuit symbol:** ``text ┌──────────┐ q_0: ┤0 ├ │ │ q_1: ┤1 GRZ(φ) ├ │ │ q_2: ┤2 ├ └──────────┘ ` The global RZ gate is native to atomic systems (ion traps, cold neutrals). The global RZ can be applied to multiple qubits simultaneously."
		},
		{
			"id": "qiskit.transpiler.passes.HLSConfig",
			"name": "qiskit.transpiler.passes.HLSConfig",
			"type": "class",
			"description": "The high-level-synthesis config allows to specify a list of “methods” used by HighLevelSynthesis transformation pass to synthesize different types of higher-level objects. A higher-level object is an object of type Operation (e.g., Clifford or LinearFunction)."
		},
		{
			"id": "qiskit.circuit.Operation",
			"name": "qiskit.circuit.Operation",
			"type": "class",
			"description": "Quantum operation interface. The minimal interface that any object must fulfil in order to be added to a QuantumCircuit. Concrete instances of this interface include Gate, Reset, Barrier, Measure, and operators such as Clifford."
		},
		{
			"id": "qiskit.transpiler.passes.TimeUnitConversion",
			"name": "qiskit.transpiler.passes.TimeUnitConversion",
			"type": "class",
			"description": "Choose a time unit to be used in the following time-aware passes, and make all circuit time units consistent with that. This pass will add a Instruction.duration metadata to each op whose duration is known which will be used by subsequent scheduling passes for scheduling."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.AGSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.AGSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Aaronson-Gottesman method. This plugin name is :clifford.ag which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Clifford."
		},
		{
			"id": "qiskit.visualization.plot_circuit_layout",
			"name": "qiskit.visualization.plot_circuit_layout",
			"type": "function",
			"description": "Plot the layout of a circuit transpiled for a given target backend. **Parameters** * **circuit** (*QuantumCircuit*) – Input quantum circuit. * **backend** (*Backend*) – Target backend. * **view** (*str*\")) – How to label qubits in the layout."
		},
		{
			"id": "qiskit.synthesis",
			"name": "qiskit.synthesis",
			"type": "module",
			"description": "Synthesize linear reversible circuits for all-to-all architecture using Patel, Markov and Hayes method. This function is an implementation of the Patel, Markov and Hayes algorithm from \\[1] for optimal synthesis of linear reversible circuits for all-to-all architecture, as specified by an matrix."
		},
		{
			"id": "qiskit.circuit.library.LinearPauliRotations",
			"name": "qiskit.circuit.library.LinearPauliRotations",
			"type": "class",
			"description": "Linearly-controlled X, Y or Z rotation. For a register of state qubits , a target qubit and the basis 'Y' this circuit acts as: ``text q_0: ─────────────────────────■───────── ... ────────────────────── │ . │ q_(n-1): ─────────────────────────┼───────── ..."
		},
		{
			"id": "qiskit.circuit.library.CSXGate",
			"name": "qiskit.circuit.library.CSXGate",
			"type": "class",
			"description": "Controlled-√X gate. Can be applied to a QuantumCircuit with the csx() method. Circuit symbol: ``text q_0: ──■── ┌─┴──┐ q_1: ┤ √X ├ └────┘ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.transpiler.passes.InverseCancellation",
			"name": "qiskit.transpiler.passes.InverseCancellation",
			"type": "class",
			"description": "Cancel specific Gates which are inverses of each other when they occur back-to- back. Initialize InverseCancellation pass. **Parameters** * **gates\\_to\\_cancel** – List describing the gates to cancel. Each element of the list is either a single gate or a pair of gates."
		},
		{
			"id": "qiskit.circuit.library.UCRYGate",
			"name": "qiskit.circuit.library.UCRYGate",
			"type": "class",
			"description": "Uniformly controlled Pauli-Y rotations. Implements the UCGate for the special case that all unitaries are Pauli-Y rotations, where is the rotation angle. **Parameters** **angle\\_list** (*list*\")*\\*[*float*\")*]*) – List of rotation angles ."
		},
		{
			"id": "qiskit.circuit.library.CRXGate",
			"name": "qiskit.circuit.library.CRXGate",
			"type": "class",
			"description": "Controlled-RX gate. Can be applied to a QuantumCircuit with the crx() method. Circuit symbol: ``text q_0: ────■──── ┌───┴───┐ q_1: ┤ Rx(ϴ) ├ └───────┘ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.circuit.library.WeightedSumGate",
			"name": "qiskit.circuit.library.WeightedSumGate",
			"type": "class",
			"description": "A gate to compute the weighted sum of qubit registers. Given qubit basis states and non-negative integer weights , this implements the operation where is the number of sum qubits required. This can be computed as or if the sum of the weights is 0 (then the expression in the logarithm is invalid)."
		},
		{
			"id": "qiskit.visualization.plot_gate_map",
			"name": "qiskit.visualization.plot_gate_map",
			"type": "function",
			"description": "Plots the gate map of a device. **Parameters** * **backend** (*Backend*) – The backend instance that will be used to plot the device gate map. * **figsize** (*tuple*\")) – Output figure size (wxh) in inches. * **plot\\_directed** (*bool*\")) – Plot directed coupling map."
		},
		{
			"id": "qiskit.synthesis.MatrixExponential",
			"name": "qiskit.synthesis.MatrixExponential",
			"type": "class",
			"description": "Exact operator evolution via matrix exponentiation and unitary synthesis. This class synthesis the exponential of operators by calculating their exponentially-sized matrix representation and using exact matrix exponentiation followed by unitary synthesis to obtain a circuit."
		},
		{
			"id": "qiskit.transpiler.passes.HoareOptimizer",
			"name": "qiskit.transpiler.passes.HoareOptimizer",
			"type": "class",
			"description": "This is a transpiler pass using Hoare logic circuit optimization."
		},
		{
			"id": "qiskit.circuit.library.PauliGate",
			"name": "qiskit.circuit.library.PauliGate",
			"type": "class",
			"description": "A multi-qubit Pauli gate. This gate exists for optimization purposes for the quantum statevector simulation, since applying multiple pauli gates to different qubits at once can be done via a single pass on the statevector."
		},
		{
			"id": "qiskit.synthesis.SolovayKitaevDecomposition",
			"name": "qiskit.synthesis.SolovayKitaevDecomposition",
			"type": "class",
			"description": "The Solovay Kitaev discrete decomposition algorithm. This class is called recursively by the transpiler pass, which is why it is separated. See SolovayKitaev for more information."
		},
		{
			"id": "qiskit.transpiler.passes.BasicSwap",
			"name": "qiskit.transpiler.passes.BasicSwap",
			"type": "class",
			"description": "Map (with minimum effort) a DAGCircuit onto a coupling_map adding swap gates. The basic mapper is a minimum effort to insert swap gates to map the DAG onto a coupling map. When a cx is not in the coupling map possibilities, it inserts one or more swaps in front to make it compatible."
		},
		{
			"id": "qiskit.circuit.library.GRX",
			"name": "qiskit.circuit.library.GRX",
			"type": "class",
			"description": "Global RX gate. **Circuit symbol:** ``text ┌──────────┐ q_0: ┤0 ├ │ │ q_1: ┤1 GRX(ϴ) ├ │ │ q_2: ┤2 ├ └──────────┘ ` The global RX gate is native to atomic systems (ion traps, cold neutrals). The global RX can be applied to multiple qubits simultaneously."
		},
		{
			"id": "qiskit.circuit.library.GR",
			"name": "qiskit.circuit.library.GR",
			"type": "class",
			"description": "Global R gate. Circuit symbol: ``text ┌──────────┐ q_0: ┤0 ├ │ │ q_1: ┤1 GR(ϴ,φ) ├ │ │ q_2: ┤2 ├ └──────────┘ ` The global R gate is native to atomic systems (ion traps, cold neutrals). The global R can be applied to multiple qubits simultaneously."
		},
		{
			"id": "qiskit.visualization.plot_bloch_vector",
			"name": "qiskit.visualization.plot_bloch_vector",
			"type": "function",
			"description": "Plot the Bloch sphere. Plot a Bloch sphere with the specified coordinates, that can be given in both cartesian and spherical systems."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisC04",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisC04",
			"type": "class",
			"description": "A ripple-carry adder with a carry-out bit. This plugin name is:HalfAdder.ripple_c04 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. This plugin requires at least one clean auxiliary qubit."
		},
		{
			"id": "qiskit.primitives.BaseSamplerV1",
			"name": "qiskit.primitives.BaseSamplerV1",
			"type": "class",
			"description": "Sampler V1 base class Base class of Sampler that calculates quasi-probabilities of bitstrings from quantum circuits. A sampler is initialized with an empty parameter set. The sampler is used to create a JobV1, via the qiskit.primitives.Sampler.run() method."
		},
		{
			"id": "qiskit.providers.Backend",
			"name": "qiskit.providers.Backend",
			"type": "class",
			"description": "Base common type for all versioned Backend abstract classes. Note this class should not be inherited from directly, it is intended to be used for type checking. When implementing a provider you should use the versioned abstract classes as the parent class and not this class directly."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.CNOTUnitCircuit",
			"name": "qiskit.synthesis.unitary.aqc.CNOTUnitCircuit",
			"type": "class",
			"description": "A class that represents an approximate circuit based on CNOT unit blocks. **Parameters** * **num\\_qubits** (*int*\")) – the number of qubits in this circuit. * **cnots** (*np.ndarray*) – an array of dimensions (2, L) indicating where the CNOT units will be placed."
		},
		{
			"id": "qiskit.circuit.library.real_amplitudes",
			"name": "qiskit.circuit.library.real_amplitudes",
			"type": "function",
			"description": "Construct a real-amplitudes 2-local circuit. This circuit is a heuristic trial wave function used, e.g., as ansatz in chemistry, optimization or machine learning applications. The circuit consists of alternating layers of rotations and entanglements."
		},
		{
			"id": "qiskit.circuit.library.PauliTwoDesign",
			"name": "qiskit.circuit.library.PauliTwoDesign",
			"type": "class",
			"description": "The Pauli Two-Design ansatz. This class implements a particular form of a 2-design circuit \\[1], which is frequently studied in quantum machine learning literature, such as e.g. the investigating of Barren plateaus in variational algorithms \\[2]."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.CNOTUnitObjective",
			"name": "qiskit.synthesis.unitary.aqc.CNOTUnitObjective",
			"type": "class",
			"description": "A base class for a problem definition based on CNOT unit. This class may have different subclasses for objective and gradient computations. **Parameters** * **num\\_qubits** (*int*\")) – number of qubits. * **cnots** (*np.ndarray*) – a CNOT structure to be used in the optimization procedure."
		},
		{
			"id": "qiskit.exceptions",
			"name": "qiskit.exceptions",
			"type": "module",
			"description": "Base class for errors raised by Qiskit. Set the error message."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MultiplierSynthesisR17",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MultiplierSynthesisR17",
			"type": "class",
			"description": "A QFT-based multiplier. This plugin name is:Multiplier.qft_r17 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.transpiler.passes.InstructionDurationCheck",
			"name": "qiskit.transpiler.passes.InstructionDurationCheck",
			"type": "class",
			"description": "Duration validation pass for reschedule. This pass investigates the input quantum circuit and checks if the circuit requires rescheduling for execution. Note that this pass can be triggered without scheduling."
		},
		{
			"id": "qiskit.circuit.library.CXGate",
			"name": "qiskit.circuit.library.CXGate",
			"type": "class",
			"description": "Controlled-X gate. Can be applied to a QuantumCircuit with the cx() and cnot() methods. Circuit symbol: ``text q_0: ──■── ┌─┴─┐ q_1: ┤ X ├ └───┘ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.circuit.library.RXXGate",
			"name": "qiskit.circuit.library.RXXGate",
			"type": "class",
			"description": "A parametric 2-qubit interaction (rotation about XX). This gate is symmetric, and is maximally entangling at . Can be applied to a QuantumCircuit with the rxx() method."
		},
		{
			"id": "qiskit.transpiler.passes.CountOpsLongestPath",
			"name": "qiskit.transpiler.passes.CountOpsLongestPath",
			"type": "class",
			"description": "Count the operations on the longest path in a DAGCircuit. The result is saved in property_set['count_ops_longest_path'] as an integer. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.transpiler.passes.OptimizeCliffordT",
			"name": "qiskit.transpiler.passes.OptimizeCliffordT",
			"type": "class",
			"description": "An optimization pass for Clifford+T circuits. Currently all the pass does is merging pairs of consecutive T-gates into S-gates, and pair of consecutive Tdg-gates into Sdg-gates. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.LinearAmplitudeFunctionGate",
			"name": "qiskit.circuit.library.LinearAmplitudeFunctionGate",
			"type": "class",
			"description": "A circuit implementing a (piecewise) linear function on qubit amplitudes. An amplitude function of a function is a mapping for a function , where is a qubit state. This circuit implements for piecewise linear functions ."
		},
		{
			"id": "qiskit.transpiler.passes.RemoveResetInZeroState",
			"name": "qiskit.transpiler.passes.RemoveResetInZeroState",
			"type": "class",
			"description": "Remove reset gate when the qubit is in zero state. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.transpiler.passes.Decompose",
			"name": "qiskit.transpiler.passes.Decompose",
			"type": "class",
			"description": "Expand a gate in a circuit using its decomposition rules. **Parameters** * **gates\\_to\\_decompose** – optional subset of gates to be decomposed, identified by gate label, name or type. Defaults to all gates."
		},
		{
			"id": "qiskit.transpiler.passes.UnrollCustomDefinitions",
			"name": "qiskit.transpiler.passes.UnrollCustomDefinitions",
			"type": "class",
			"description": "Unrolls instructions with custom definitions. Unrolls instructions with custom definitions. **Parameters** * **equivalence\\_library** (*EquivalenceLibrary*) – The equivalence library which will be used by the BasisTranslator pass."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisDefault",
			"type": "class",
			"description": "Synthesize a PauliEvolutionGate using the default synthesis algorithm. This plugin name is:PauliEvolution.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.HRSCumulativeMultiplier",
			"name": "qiskit.circuit.library.HRSCumulativeMultiplier",
			"type": "class",
			"description": "A multiplication circuit to store product of two input registers out-of-place. Circuit uses the approach from \\[1]."
		},
		{
			"id": "qiskit.transpiler.generate_preset_pass_manager",
			"name": "qiskit.transpiler.generate_preset_pass_manager",
			"type": "function",
			"description": "Generate a preset PassManager This function is used to quickly generate a preset pass manager. Preset pass managers are the default pass managers used by the transpile() function."
		},
		{
			"id": "qiskit.transpiler.passes.Collect2qBlocks",
			"name": "qiskit.transpiler.passes.Collect2qBlocks",
			"type": "class",
			"description": "Collect two-qubit subcircuits. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.quantum_info.get_clifford_gate_names",
			"name": "qiskit.quantum_info.get_clifford_gate_names",
			"type": "function",
			"description": "Returns the list of Clifford gate names. **Return type** list\")"
		},
		{
			"id": "qiskit.transpiler.passes.Unroll3qOrMore",
			"name": "qiskit.transpiler.passes.Unroll3qOrMore",
			"type": "class",
			"description": "Recursively expands 3q+ gates until the circuit only contains 2q or 1q gates. Initialize the Unroll3qOrMore pass **Parameters** * **target** (*Target*) – The target object representing the compilation target."
		},
		{
			"id": "qiskit.circuit.library.BitFlipOracleGate",
			"name": "qiskit.circuit.library.BitFlipOracleGate",
			"type": "class",
			"description": "Implements a bit-flip oracle The Bit-flip Oracle Gate object constructs circuits for any arbitrary input logical expressions. A logical expression is composed of logical operators & (logical AND), | (logical OR), \\~ (logical NOT), and ^ (logical XOR). as well as symbols for literals (variables)."
		},
		{
			"id": "qiskit.providers.Options",
			"name": "qiskit.providers.Options",
			"type": "class",
			"description": "Base options object This class is what all backend options are based on. The properties of the class are intended to be all dynamically adjustable so that a user can reconfigure the backend on demand."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisDefault",
			"type": "class",
			"description": "The default synthesis plugin for a multi-controlled X gate. This plugin name is :mcx.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.z_feature_map",
			"name": "qiskit.circuit.library.z_feature_map",
			"type": "function",
			"description": "The first order Pauli Z-evolution circuit."
		},
		{
			"id": "qiskit.circuit.library.ZZFeatureMap",
			"name": "qiskit.circuit.library.ZZFeatureMap",
			"type": "class",
			"description": "Second-order Pauli-Z evolution circuit."
		},
		{
			"id": "qiskit.circuit.library.UCRXGate",
			"name": "qiskit.circuit.library.UCRXGate",
			"type": "class",
			"description": "Uniformly controlled Pauli-X rotations. Implements the UCGate for the special case that all unitaries are Pauli-X rotations, where is the rotation angle. **Parameters** **angle\\_list** (*list*\")*\\*[*float*\")*]*) – List of rotation angles ."
		},
		{
			"id": "qiskit.transpiler.passes.SabrePreLayout",
			"name": "qiskit.transpiler.passes.SabrePreLayout",
			"type": "class",
			"description": "Choose a starting layout to use for additional Sabre layout trials. ## Property Set Values Written **sabre_starting_layouts (list[Layout])** An optional list of Layout objects to use for additional Sabre layout trials."
		},
		{
			"id": "qiskit.transpiler.AnalysisPass",
			"name": "qiskit.transpiler.AnalysisPass",
			"type": "class",
			"description": "An analysis pass: change property set, not DAG. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.result.ResultError",
			"name": "qiskit.result.ResultError",
			"type": "exception",
			"description": "Exceptions raised due to errors in result output. It may be better for the Qiskit API to raise this exception. **Parameters** **error** (*dict*\")) – This is the error record as it comes back from the API."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisFull",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisFull",
			"type": "class",
			"description": "Synthesis plugin for QFT gates using all-to-all connectivity. This plugin name is :qft.full which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. Note that the plugin mechanism is not applied if the gate is called qft but is not an instance of QFTGate."
		},
		{
			"id": "qiskit.circuit.library.QFT",
			"name": "qiskit.circuit.library.QFT",
			"type": "class",
			"description": "Quantum Fourier Transform Circuit. The Quantum Fourier Transform (QFT) on qubits is the operation The circuit that implements this transformation can be implemented using Hadamard gates on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a layer of Swap gates."
		},
		{
			"id": "qiskit.circuit.ParameterVector",
			"name": "qiskit.circuit.ParameterVector",
			"type": "class",
			"description": "A container of many related Parameter objects. This class is faster to construct than constructing many Parameter objects individually, and the individual names of the parameters will all share a common stem (the name of the vector)."
		},
		{
			"id": "qiskit.transpiler.passes.FullAncillaAllocation",
			"name": "qiskit.transpiler.passes.FullAncillaAllocation",
			"type": "class",
			"description": "Allocate all idle nodes from the coupling map or target as ancilla on the layout. A pass for allocating all idle physical qubits (those that exist in coupling map or target but not the dag circuit) as ancilla. It will also choose new virtual qubits to correspond to those physical ancilla."
		},
		{
			"id": "qiskit.result.QuasiDistribution",
			"name": "qiskit.result.QuasiDistribution",
			"type": "class",
			"description": "A dict-like class for representing quasi-probabilities. Builds a quasiprobability distribution object. The quasiprobability values might include floating-point errors."
		},
		{
			"id": "qiskit.circuit.Annotation",
			"name": "qiskit.circuit.Annotation",
			"type": "class",
			"description": "An arbitrary annotation for instructions. The annotation framework is a new and evolving component of Qiskit. We expect the functionality of this and its first-class support within the transpiler to expand as we get more evidence of how it is used."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisDefault",
			"type": "class",
			"description": "A ripple-carry adder with a carry-in and a carry-out bit. This plugin name is:FullAdder.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.transpiler.passes.UnrollForLoops",
			"name": "qiskit.transpiler.passes.UnrollForLoops",
			"type": "class",
			"description": "UnrollForLoops transpilation pass unrolls for-loops when possible. Things like for x in {0, 3, 4} {rx(x) qr[1];} will turn into rx(0) qr[1]; rx(3) qr[1]; rx(4) qr[1];. The UnrollForLoops unrolls only one level of block depth. No inner loop will be considered by max_target_depth."
		},
		{
			"id": "qiskit.circuit.IfElseOp",
			"name": "qiskit.circuit.IfElseOp",
			"type": "class",
			"description": "A circuit operation which executes a program (true_body) if a provided condition (condition) evaluates to true, and optionally evaluates another program (false_body) otherwise. If provided, false_body must be of the same num_qubits and num_clbits as true_body."
		},
		{
			"id": "qiskit.transpiler.passes.LitinskiTransformation",
			"name": "qiskit.transpiler.passes.LitinskiTransformation",
			"type": "class",
			"description": "Applies Litinski transform to a circuit. The transform applies to a circuit containing Clifford + RZ-rotation gates (including T and Tdg), and moves Clifford gates to the end of the circuit, while changing rotation gates to multi-qubit rotations (represented using PauliEvolution gates)."
		},
		{
			"id": "qiskit.circuit.library.random_bitwise_xor",
			"name": "qiskit.circuit.library.random_bitwise_xor",
			"type": "function",
			"description": "Create a random BitwiseXorGate. **Parameters** * **num\\_qubits** (*int*\")) – the width of circuit. * **seed** (*int*\")) – random seed in case a random xor is requested. **Return type** *BitwiseXorGate*"
		},
		{
			"id": "qiskit.circuit.library.NLocal",
			"name": "qiskit.circuit.library.NLocal",
			"type": "class",
			"description": "The n-local circuit class. The structure of the n-local circuit are alternating rotation and entanglement layers. In both layers, parameterized circuit-blocks act on the circuit in a defined way."
		},
		{
			"id": "qiskit.synthesis.LieTrotter",
			"name": "qiskit.synthesis.LieTrotter",
			"type": "class",
			"description": "The Lie-Trotter product formula. The Lie-Trotter formula approximates the exponential of two non-commuting operators with products of their exponentials up to a second order error: In this implementation, the operators are provided as sum terms of a Pauli operator."
		},
		{
			"id": "qiskit.transpiler.InstructionDurations",
			"name": "qiskit.transpiler.InstructionDurations",
			"type": "class",
			"description": "Helper class to provide durations of instructions for scheduling. It stores durations (gate lengths) and dt to be used at the scheduling stage of transpiling. It can be constructed from backend or instruction_durations, which is an argument of transpile()."
		},
		{
			"id": "qiskit.providers.Job",
			"name": "qiskit.providers.Job",
			"type": "class",
			"description": "Base common type for all versioned Job abstract classes. Note this class should not be inherited from directly, it is intended to be used for type checking. When implementing a provider you should use the versioned abstract classes as the parent class and not this class directly."
		},
		{
			"id": "qiskit.circuit.library.IntegerComparator",
			"name": "qiskit.circuit.library.IntegerComparator",
			"type": "class",
			"description": "Integer Comparator. Operator compares basis states against a classically given integer of fixed value and flips a target qubit if (or depending on the parameter geq): This operation is based on two’s complement implementation of binary subtraction but only uses carry bits and no actual result bits."
		},
		{
			"id": "qiskit.circuit.library.YGate",
			"name": "qiskit.circuit.library.YGate",
			"type": "class",
			"description": "The single-qubit Pauli-Y gate (). Can be applied to a QuantumCircuit with the y() method. Matrix representation: Circuit symbol: ``text ┌───┐ q_0: ┤ Y ├ └───┘ ` Equivalent to a radian rotation about the Y axis. A global phase difference exists between the definitions of and ."
		},
		{
			"id": "qiskit.transpiler.passes.CommutativeInverseCancellation",
			"name": "qiskit.transpiler.passes.CommutativeInverseCancellation",
			"type": "class",
			"description": "Cancel pairs of inverse gates exploiting commutation relations. **Parameters** * **matrix\\_based** – If True, uses matrix representations to check whether two operations are inverse of each other."
		},
		{
			"id": "qiskit.transpiler.WrapAngleRegistry",
			"name": "qiskit.transpiler.WrapAngleRegistry",
			"type": "class",
			"description": "Registry of Angle Wrapping function This class internally contains a mapping of instruction names from a Target to callbacks for wrapping angles that are outside the specified bounds. ## Methods ### add\\_wrapper ### substitute\\_angle\\_bounds Get a replacement circuit for"
		},
		{
			"id": "qiskit.circuit.library.CHGate",
			"name": "qiskit.circuit.library.CHGate",
			"type": "class",
			"description": "Controlled-Hadamard gate. Applies a Hadamard on the target qubit if the control is in the state. Can be applied to a QuantumCircuit with the ch() method."
		},
		{
			"id": "qiskit.visualization.plot_state_paulivec",
			"name": "qiskit.visualization.plot_state_paulivec",
			"type": "function",
			"description": "Plot the Pauli-vector representation of a quantum state as bar graph. The Pauli-vector of a density matrix is defined by the expectation of each possible tensor product of single-qubit Pauli operators (including the identity), that is This function plots the coefficients as bar graph."
		},
		{
			"id": "qiskit.circuit.library.RYYGate",
			"name": "qiskit.circuit.library.RYYGate",
			"type": "class",
			"description": "A parametric 2-qubit interaction (rotation about YY). This gate is symmetric, and is maximally entangling at . Can be applied to a QuantumCircuit with the ryy() method."
		},
		{
			"id": "qiskit.passmanager",
			"name": "qiskit.passmanager",
			"type": "module",
			"description": "Pass manager error. Set the error message."
		},
		{
			"id": "qiskit.synthesis.TwoQubitBasisDecomposer",
			"name": "qiskit.synthesis.TwoQubitBasisDecomposer",
			"type": "class",
			"description": "A class for decomposing 2-qubit unitaries into minimal number of uses of a 2-qubit basis gate. **Parameters** * **gate** (*Gate*) – Two-qubit gate to be used in the KAK decomposition. * **basis\\_fidelity** (*float*\")) – Fidelity to be assumed for applications of KAK Gate. Defaults to 1.0."
		},
		{
			"id": "qiskit.circuit.library.evolved_operator_ansatz",
			"name": "qiskit.circuit.library.evolved_operator_ansatz",
			"type": "function",
			"description": "Construct an ansatz out of operator evolutions. For a set of operators and repetitions (reps), this circuit is defined as where the exponentials are expanded using the product formula specified by evolution."
		},
		{
			"id": "qiskit.circuit.library.InnerProductGate",
			"name": "qiskit.circuit.library.InnerProductGate",
			"type": "class",
			"description": "A 2n-qubit Boolean function that computes the inner product of two n-qubit vectors over . This implementation is a phase oracle which computes the following transform."
		},
		{
			"id": "qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation",
			"name": "qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation",
			"type": "class",
			"description": "Optimizes 1Q gate strings interrupted by 2Q gates by commuting the components and resynthesizing the results. The commutation rules are stored in commutation_table."
		},
		{
			"id": "qiskit.circuit.CommutationChecker",
			"name": "qiskit.circuit.CommutationChecker",
			"type": "class",
			"description": "Check commutations of two operations. Two unitaries and on qubits commute if where and we set to to account for round-off errors on few-qubit systems. This metric is chosen for consistency with other closeness checks in Qiskit. When possible, commutation relations are queried from a lookup table."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNDirtyI15",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNDirtyI15",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Iten et al. (2016). See \\[1] for details. This plugin name is :mcx.n_dirty_i15 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.primitives.EstimatorResult",
			"name": "qiskit.primitives.EstimatorResult",
			"type": "class",
			"description": "Result of Estimator V1. ``python result = estimator.run(circuits, observables, params).result() ` where the i-th elements of result correspond to the circuit and observable given by circuits[i], observables[i], and the parameter values bounds by params[i]."
		},
		{
			"id": "qiskit.passmanager.BasePassManager",
			"name": "qiskit.passmanager.BasePassManager",
			"type": "class",
			"description": "Pass manager base class. Initialize an empty pass manager object. **Parameters** * **tasks** (*Task |* *list*\")*\\[Task]*) – A pass set to be added to the pass manager schedule. * **max\\_iteration** (*int*\")) – The maximum number of iterations the schedule will be looped if the condition is not met."
		},
		{
			"id": "qiskit.circuit.library.HiddenLinearFunction",
			"name": "qiskit.circuit.library.HiddenLinearFunction",
			"type": "class",
			"description": "Circuit to solve the hidden linear function problem. The 2D Hidden Linear Function problem is determined by a 2D adjacency matrix A, where only elements that are nearest-neighbor on a grid have non-zero entries. Each row/column corresponds to one binary variable ."
		},
		{
			"id": "qiskit.synthesis.TwoQubitControlledUDecomposer",
			"name": "qiskit.synthesis.TwoQubitControlledUDecomposer",
			"type": "class",
			"description": "Decompose two-qubit unitary in terms of a desired gate that is locally equivalent to an RXXGate. Initialize the KAK decomposition. **Parameters** * **rxx\\_equivalent\\_gate** (*Type**\\*[*Gate**]*) – Gate that is locally equivalent to an RXXGate: gate."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisR25",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisR25",
			"type": "class",
			"description": "A ripple-carry adder with a carry-out bit with no ancillary qubits. This plugin name is:HalfAdder.ripple_r25 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.LayerLnnSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.LayerLnnSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Bravyi-Maslov method to synthesize Cliffords into layers, with each layer synthesized adhering to LNN connectivity. This plugin name is :clifford.lnn which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.transpiler.passes.MergeAdjacentBarriers",
			"name": "qiskit.transpiler.passes.MergeAdjacentBarriers",
			"type": "class",
			"description": "Return a circuit with any adjacent barriers merged together. Only barriers which can be merged without affecting the barrier structure of the DAG will be merged. Not all redundant barriers will necessarily be merged, only adjacent barriers are merged."
		},
		{
			"id": "qiskit.transpiler.passes.GatesInBasis",
			"name": "qiskit.transpiler.passes.GatesInBasis",
			"type": "class",
			"description": "Check if all gates in a DAG are in a given set of gates Initialize the GatesInBasis pass. **Parameters** * **basis\\_gates** (*list*\")) – The list of strings representing the set of basis gates. * **target** (*Target*) – The target representing the backend."
		},
		{
			"id": "qiskit.passmanager.FlowControllerLinear",
			"name": "qiskit.passmanager.FlowControllerLinear",
			"type": "class",
			"description": "A standard flow controller that runs tasks one after the other. Create new flow controller. **Parameters** * **options** (*dict*\")*\\*[*str*\")*, Any] | None*) – Option for this flow controller. * **tasks** (*Task | Iterable\\[Task]*) – ## Attributes ### passes Alias of tasks for backward compatibility."
		},
		{
			"id": "qiskit.circuit.random",
			"name": "qiskit.circuit.random",
			"type": "module",
			"description": "Generate random circuit of arbitrary size and form. This function will generate a random circuit by randomly selecting gates from the set of standard gates in qiskit.circuit.library.standard_gates."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.ACGSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.ACGSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on the Alon, Chung, Graham method. This plugin name is :permutation.acg which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Permutation."
		},
		{
			"id": "qiskit.transpiler.passes.OptimizeCliffords",
			"name": "qiskit.transpiler.passes.OptimizeCliffords",
			"type": "class",
			"description": "Combine consecutive Cliffords over the same qubits. This serves as an example of extra capabilities enabled by storing Cliffords natively on the circuit. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.transpiler.passes.UnitarySynthesis",
			"name": "qiskit.transpiler.passes.UnitarySynthesis",
			"type": "class",
			"description": "Synthesize gates according to their basis gates. Synthesize unitaries over some basis gates. This pass can approximate 2-qubit unitaries given some gate fidelities (via target). More approximation can be forced by setting a heuristic dial approximation_degree."
		},
		{
			"id": "qiskit.transpiler.passes.TemplateOptimization",
			"name": "qiskit.transpiler.passes.TemplateOptimization",
			"type": "class",
			"description": "Class for the template optimization pass. **Parameters** * **template\\_list** (*list*\")*\\*[*QuantumCircuit**()]*) – list of the different template circuit to apply."
		},
		{
			"id": "qiskit.dagcircuit.DAGOutNode",
			"name": "qiskit.dagcircuit.DAGOutNode",
			"type": "class",
			"description": "Object to represent an outgoing wire node in the DAGCircuit. ## Attributes ### wire"
		},
		{
			"id": "qiskit.circuit.library.iqp",
			"name": "qiskit.circuit.library.iqp",
			"type": "function",
			"description": "Instantaneous quantum polynomial time (IQP) circuit. The circuit consists of a column of Hadamard gates, a column of powers of T gates, a sequence of powers of CS gates (up to of them), and a final column of Hadamard gates, as introduced in \\[1]. The circuit is parameterized by an interactions matrix."
		},
		{
			"id": "qiskit.circuit.library.RealAmplitudes",
			"name": "qiskit.circuit.library.RealAmplitudes",
			"type": "class",
			"description": "The real-amplitudes 2-local circuit. The RealAmplitudes circuit is a heuristic trial wave function used as Ansatz in chemistry applications or classification circuits in machine learning. The circuit consists of alternating layers of rotations and entanglements."
		},
		{
			"id": "qiskit.transpiler.passes.CommutationAnalysis",
			"name": "qiskit.transpiler.passes.CommutationAnalysis",
			"type": "class",
			"description": "Analysis pass to find commutation relations between DAG nodes. This sets property_set['commutation_set'] to a dictionary that describes the commutation relations on a given wire: all the gates on a wire are grouped into a set of gates that commute."
		},
		{
			"id": "qiskit.circuit.library.PermutationGate",
			"name": "qiskit.circuit.library.PermutationGate",
			"type": "class",
			"description": "A gate that permutes qubits. Return a permutation gate. **Parameters** **pattern** (*list*\")*\\*[*int*\")*]*) – permutation pattern, describing which qubits occupy the positions 0, 1, 2, etc. after applying the permutation, that is pattern[k] = m when the permutation maps qubit m to position k."
		},
		{
			"id": "qiskit.transpiler.passes.ResetAfterMeasureSimplification",
			"name": "qiskit.transpiler.passes.ResetAfterMeasureSimplification",
			"type": "class",
			"description": "This pass replaces reset after measure with a conditional X gate. This optimization is suitable for use on IBM Quantum systems where the reset operation is performed by a measurement followed by a conditional x-gate. It might not be desirable on other backends if reset is implemented differently."
		},
		{
			"id": "qiskit.visualization",
			"name": "qiskit.visualization",
			"type": "module",
			"description": "For visualization specific errors. Set the error message."
		},
		{
			"id": "qiskit.primitives",
			"name": "qiskit.primitives",
			"type": "module",
			"description": "qiskit.primitives The primitives are computational building blocks to be used in larger applications whose input units, called primitive unified blocs (PUBs), require quantum resources to efficiently produce outputs for."
		},
		{
			"id": "qiskit.dagcircuit.BlockSplitter",
			"name": "qiskit.dagcircuit.BlockSplitter",
			"type": "class",
			"description": "Splits a block of nodes into sub-blocks over disjoint qubits. The implementation is based on the Disjoint Set Union data structure. ## Methods ### find\\_leader Find in DSU. ### run Splits block of nodes into sub-blocks over disjoint qubits. ### union\\_leaders Union in DSU."
		},
		{
			"id": "qiskit.circuit.library.CSwapGate",
			"name": "qiskit.circuit.library.CSwapGate",
			"type": "class",
			"description": "Controlled-SWAP gate, also known as the Fredkin gate. Can be applied to a QuantumCircuit with the cswap() and fredkin() methods. Circuit symbol: ``text q_0: ─■─ │ q_1: ─X─ │ q_2: ─X─ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.transpiler.PassManagerConfig",
			"name": "qiskit.transpiler.PassManagerConfig",
			"type": "class",
			"description": "Pass Manager Configuration. Initialize a PassManagerConfig object **Parameters** * **initial\\_layout** (*Layout*) – Initial position of virtual qubits on physical qubits. * **basis\\_gates** (*list*\")) – List of basis gate names to unroll to."
		},
		{
			"id": "qiskit.passmanager.BaseController",
			"name": "qiskit.passmanager.BaseController",
			"type": "class",
			"description": "Base class of controller. A controller is built with a collection of pass manager tasks, and a subclass provides a custom logic to choose next task to run. Note a controller can be nested into another controller, and a controller itself doesn’t provide any subroutine to modify the input IR."
		},
		{
			"id": "qiskit.passmanager.ConditionalController",
			"name": "qiskit.passmanager.ConditionalController",
			"type": "class",
			"description": "A flow controller runs the pipeline once if the condition is true, or does nothing if the condition is false. Create new flow controller. **Parameters** * **options** (*dict*\")*\\*[*str*\")*, Any] | None*) – Option for this flow controller."
		},
		{
			"id": "qiskit.circuit.library.EvolvedOperatorAnsatz",
			"name": "qiskit.circuit.library.EvolvedOperatorAnsatz",
			"type": "class",
			"description": "The evolved operator ansatz. **Parameters** * **operators** (*BaseOperator |* *QuantumCircuit* *|**list*\") *| None*) – The operators to evolve. If a circuit is passed, we assume it implements an already evolved operator and thus the circuit is not evolved again."
		},
		{
			"id": "qiskit.quantum_info.Stinespring",
			"name": "qiskit.quantum_info.Stinespring",
			"type": "class",
			"description": "Stinespring representation of a quantum channel. The Stinespring representation of a quantum channel is a rectangular matrix such that the evolution of a DensityMatrix is given by where is the partial_trace() over subsystem 2."
		},
		{
			"id": "qiskit.circuit.library.U3Gate",
			"name": "qiskit.circuit.library.U3Gate",
			"type": "class",
			"description": "Generic single-qubit rotation gate with 3 Euler angles. This gate is deprecated."
		},
		{
			"id": "qiskit.quantum_info.ScalarOp",
			"name": "qiskit.quantum_info.ScalarOp",
			"type": "class",
			"description": "Scalar identity operator class. This is a symbolic representation of an scalar identity operator on multiple subsystems."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names",
			"name": "qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names",
			"type": "function",
			"description": "Return a list of installed unitary synthesis plugin names **Returns** A list of the installed unitary synthesis plugin names. The plugin names are valid values for the transpile() kwarg unitary_synthesis_method. **Return type** list\")"
		},
		{
			"id": "qiskit.utils",
			"name": "qiskit.utils",
			"type": "module",
			"description": "Dynamically insert the deprecation message into func’s docstring. **Parameters** * **func** (*Callable*) – The function to modify. * **msg** (*str*\")) – The full deprecation message. * **since** (*str*\") *| None*) – The version the deprecation started at."
		},
		{
			"id": "qiskit.transpiler.passes.SetLayout",
			"name": "qiskit.transpiler.passes.SetLayout",
			"type": "class",
			"description": "Set the layout property to the given layout. This pass associates a physical qubit (int) to each virtual qubit of the circuit (Qubit) in increasing order. SetLayout initializer. **Parameters** **layout** (*Layout* *or List\\*[*int*\")*]*) – the layout to set."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNoAuxHP24",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNoAuxHP24",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Huang and Palsberg. See \\[1] for details. This plugin name is :mcx.noaux_hp24 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.AND",
			"name": "qiskit.circuit.library.AND",
			"type": "class",
			"description": "A circuit implementing the logical AND operation on a number of qubits. For the AND operation the state is interpreted as True. The result qubit is flipped, if the state of all variable qubits is True."
		},
		{
			"id": "qiskit.transpiler.passes.Layout2qDistance",
			"name": "qiskit.transpiler.passes.Layout2qDistance",
			"type": "class",
			"description": "Evaluate how good the layout selection was. Saves in property_set['layout_score'] (or the property name in property\\_name) the sum of distances for each circuit CX. The lower the number, the better the selection. Therefore, 0 is a perfect layout selection. No CX direction is considered."
		},
		{
			"id": "qiskit.circuit.library.CSGate",
			"name": "qiskit.circuit.library.CSGate",
			"type": "class",
			"description": "Controlled-S gate. Can be applied to a QuantumCircuit with the cs() method. Circuit symbol: ``text q_0: ──■── ┌─┴─┐ q_1: ┤ S ├ └───┘ ` Matrix representation: Create new CS gate. ## Attributes ### base\\_class Get the base class of this instruction."
		},
		{
			"id": "qiskit.circuit.library.QuadraticFormGate",
			"name": "qiskit.circuit.library.QuadraticFormGate",
			"type": "class",
			"description": "Implements a quadratic form on binary variables encoded in qubit registers. A quadratic form on binary variables is a quadratic function acting on a binary variable of bits, ."
		},
		{
			"id": "qiskit.transpiler.passes.FixedPoint",
			"name": "qiskit.transpiler.passes.FixedPoint",
			"type": "class",
			"description": "Check if a property reached a fixed point. A dummy analysis pass that checks if a property reached a fixed point. The result is saved in property_set['_fixed_point'] as a boolean. FixedPoint initializer."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin",
			"name": "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin",
			"type": "class",
			"description": "Abstract unitary synthesis plugin class This abstract class defines the interface for unitary synthesis plugins. ## Attributes ### max\\_qubits Return the maximum number of qubits the unitary synthesis plugin supports."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisDefault",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisDefault",
			"type": "class",
			"description": "The default modular adder (no carry in, no carry out qubit) synthesis. This plugin name is:ModularAdder.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.GraphState",
			"name": "qiskit.circuit.library.GraphState",
			"type": "class",
			"description": "Circuit to prepare a graph state. Given a graph G = (V, E), with the set of vertices V and the set of edges E, the corresponding graph state is defined as Such a state can be prepared by first preparing all qubits in the state, then applying a gate for each corresponding graph edge."
		},
		{
			"id": "qiskit.circuit.library.PolynomialPauliRotationsGate",
			"name": "qiskit.circuit.library.PolynomialPauliRotationsGate",
			"type": "class",
			"description": "A gate implementing polynomial Pauli rotations. For a polynomial , a basis state and a target qubit this operator acts as: Let n be the number of qubits representing the state, d the degree of p(x) and q\\_i the qubits, where q\\_0 is the least significant qubit."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.AQC",
			"name": "qiskit.synthesis.unitary.aqc.AQC",
			"type": "class",
			"description": "A generic implementation of the Approximate Quantum Compiler. This implementation is agnostic of the underlying implementation of the approximate circuit, objective, and optimizer."
		},
		{
			"id": "qiskit.transpiler.passes.VF2PostLayout",
			"name": "qiskit.transpiler.passes.VF2PostLayout",
			"type": "class",
			"description": "A pass for improving an existing Layout after transpilation of a circuit onto a Coupling graph, as a subgraph isomorphism problem, solved by VF2++."
		},
		{
			"id": "qiskit.converters",
			"name": "qiskit.converters",
			"type": "module",
			"description": "Build an Instruction object from a QuantumCircuit. The instruction is anonymous (not tied to a named quantum register), and so can be inserted into another circuit. The instruction will have the same string name as the circuit. **Parameters** * **circuit** (*QuantumCircuit*) – the input circuit."
		},
		{
			"id": "qiskit.circuit.library.Permutation",
			"name": "qiskit.circuit.library.Permutation",
			"type": "class",
			"description": "An n\\_qubit circuit that permutes qubits. The class qiskit.circuit.library.generalized_gates.permutation.Permutation is deprecated as of Qiskit 2.1. It will be removed in Qiskit 3.0. Use PermutationGate instead. **Parameters** * **num\\_qubits** (*int*\")) – circuit width."
		},
		{
			"id": "qiskit.circuit.library.CRYGate",
			"name": "qiskit.circuit.library.CRYGate",
			"type": "class",
			"description": "Controlled-RY gate. Can be applied to a QuantumCircuit with the cry() method. Circuit symbol: ``text q_0: ────■──── ┌───┴───┐ q_1: ┤ Ry(ϴ) ├ └───────┘ ` Matrix representation: In Qiskit’s convention, higher qubit indices are more significant (little endian convention)."
		},
		{
			"id": "qiskit.circuit.library.CU1Gate",
			"name": "qiskit.circuit.library.CU1Gate",
			"type": "class",
			"description": "Controlled-U1 gate. This is a diagonal and symmetric gate that induces a phase on the state of the target qubit, depending on the control state. This gate is deprecated."
		},
		{
			"id": "qiskit.primitives.BaseSamplerV2",
			"name": "qiskit.primitives.BaseSamplerV2",
			"type": "class",
			"description": "Base class for SamplerV2 implementations. A Sampler returns samples of quantum circuit outputs. Implementations of this BaseSamplerV2 interface must define their own run() method, which is designed to take the following inputs: > * **pubs: list of pubs (Primitive Unified Blocs)."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1CleanKG24",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1CleanKG24",
			"type": "class",
			"description": "Synthesis plugin for a multi-controlled X gate based on the paper by Khattar and Gidney (2024). See \\[1] for details. The plugin name is :mcx.1_clean_kg24 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.circuit.library.IGate",
			"name": "qiskit.circuit.library.IGate",
			"type": "class",
			"description": "Identity gate. Identity gate corresponds to a single-qubit gate wait cycle, and should not be optimized or unrolled (it is an opaque gate). Can be applied to a QuantumCircuit with the i() and id() methods."
		},
		{
			"id": "qiskit.quantum_info.PhasedQubitSparsePauli",
			"name": "qiskit.quantum_info.PhasedQubitSparsePauli",
			"type": "class",
			"description": "A Pauli operator stored in a qubit-sparse format. ## Representation A Pauli operator is a tensor product of single-qubit Pauli operators of the form , for and an integer called the phase exponent."
		},
		{
			"id": "qiskit.visualization.plot_bloch_multivector",
			"name": "qiskit.visualization.plot_bloch_multivector",
			"type": "function",
			"description": "Plot a Bloch sphere for each qubit. Each component of the Bloch sphere labeled as ‘qubit i’ represents the expected value of the corresponding Pauli operator acting only on that qubit, that is, the expected value of , where is the number of qubits, and is the identity operator."
		},
		{
			"id": "qiskit.visualization.plot_distribution",
			"name": "qiskit.visualization.plot_distribution",
			"type": "function",
			"description": "Plot a distribution from input sampled data. **Parameters** * **data** (*list*\") *or**dict*\")) – This is either a list of dictionaries or a single dict containing the values to represent (ex \\{‘001’: 130}) * **figsize** (*tuple*\")) – Figure size in inches."
		},
		{
			"id": "qiskit.circuit.library.phase_estimation",
			"name": "qiskit.circuit.library.phase_estimation",
			"type": "function",
			"description": "Phase Estimation circuit. In the Quantum Phase Estimation (QPE) algorithm \\[1, 2, 3], the Phase Estimation circuit is used to estimate the phase of an eigenvalue of a unitary operator , provided with the corresponding eigenstate ."
		},
		{
			"id": "qiskit.providers.fake_provider.GenericBackendV2",
			"name": "qiskit.providers.fake_provider.GenericBackendV2",
			"type": "class",
			"description": "Generic BackendV2 implementation with a configurable constructor. This class will return a BackendV2 instance that runs on a local simulator (in the spirit of fake backends) and contains all the necessary information to test backend-interfacing components, such as the transpiler."
		},
		{
			"id": "qiskit.dagcircuit.BlockCollector",
			"name": "qiskit.dagcircuit.BlockCollector",
			"type": "class",
			"description": "This class implements various strategies of dividing a DAG (direct acyclic graph) into blocks of nodes that satisfy certain criteria. It works both with the DAGCircuit and DAGDependency representations of a DAG, where DagDependency takes into account commutativity between nodes."
		},
		{
			"id": "qiskit.circuit.library.HGate",
			"name": "qiskit.circuit.library.HGate",
			"type": "class",
			"description": "Single-qubit Hadamard gate. This gate is a pi rotation about the X+Z axis, and has the effect of changing computation basis from to and vice-versa. Can be applied to a QuantumCircuit with the h() method."
		},
		{
			"id": "qiskit.transpiler.passes.RemoveBarriers",
			"name": "qiskit.transpiler.passes.RemoveBarriers",
			"type": "class",
			"description": "Return a circuit with any barrier removed. This transformation is not semantics preserving."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisV95",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisV95",
			"type": "class",
			"description": "A ripple-carry adder, modulo . This plugin name is:ModularAdder.ripple_v95 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. For an adder on 2 registers with qubits each, this plugin requires at least clean auxiliary qubit."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.GreedySynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.GreedySynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the greedy synthesis Bravyi-Hu-Maslov-Shaydulin method. This plugin name is :clifford.greedy which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Clifford."
		},
		{
			"id": "qiskit.transpiler.passes.CheckGateDirection",
			"name": "qiskit.transpiler.passes.CheckGateDirection",
			"type": "class",
			"description": "Check if the two-qubit gates follow the right direction with respect to the coupling map. CheckGateDirection initializer. **Parameters** * **coupling\\_map** (*CouplingMap*) – Directed graph representing a coupling map. * **target** (*Target*) – The backend target to use for this pass."
		},
		{
			"id": "qiskit.transpiler.passes.ContractIdleWiresInControlFlow",
			"name": "qiskit.transpiler.passes.ContractIdleWiresInControlFlow",
			"type": "class",
			"description": "Remove idle qubits from control-flow operations of a DAGCircuit. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.circuit.library.unitary_overlap",
			"name": "qiskit.circuit.library.unitary_overlap",
			"type": "function",
			"description": "Circuit that returns the overlap between two unitaries . The input quantum circuits must represent unitary operations, since they must be invertible."
		},
		{
			"id": "qiskit.synthesis.unitary.aqc.DefaultCNOTUnitObjective",
			"name": "qiskit.synthesis.unitary.aqc.DefaultCNOTUnitObjective",
			"type": "class",
			"description": "A naive implementation of the objective function based on CNOT units. **Parameters** * **num\\_qubits** (*int*\")) – number of qubits. * **cnots** (*np.ndarray*) – a CNOT structure to be used in the optimization procedure."
		},
		{
			"id": "qiskit.transpiler.passes.Error",
			"name": "qiskit.transpiler.passes.Error",
			"type": "class",
			"description": "Error pass to be called when an error happens. Error pass. **Parameters** * **msg** (*str*\") *| Callable\\\\[*[*PropertySet**],* *str*\")*]*) – Error message, if not provided a generic error will be used."
		},
		{
			"id": "qiskit.circuit.library.OrGate",
			"name": "qiskit.circuit.library.OrGate",
			"type": "class",
			"description": "A gate representing the logical OR operation on a number of qubits. For the OR operation the state is interpreted as True. The result qubit is flipped, if the state of any variable qubit is True. The OR is implemented using a multi-open-controlled X gate (i.e."
		},
		{
			"id": "qiskit.circuit.library.MCXRecursive",
			"name": "qiskit.circuit.library.MCXRecursive",
			"type": "class",
			"description": "Implement the multi-controlled X gate using recursion. Using a single clean ancilla qubit, the multi-controlled X gate is split into four sub-registers, each one of them uses the V-chain method. The method is based on Lemma 9 of \\[2], first shown in Lemma 7.3 of \\[1]. **References** 1."
		},
		{
			"id": "qiskit.transpiler.passes.RemoveIdentityEquivalent",
			"name": "qiskit.transpiler.passes.RemoveIdentityEquivalent",
			"type": "class",
			"description": "Remove gates with negligible effects. Removes gates whose effect is close to an identity operation up to a global phase and up to the specified tolerance. Parameterized gates are not considered by this pass."
		},
		{
			"id": "qiskit.result",
			"name": "qiskit.result",
			"type": "module",
			"description": "Marginalize counts from an experiment over some indices of interest. **Parameters** * **result** (*dict*\") *|**Result*) – result to be marginalized (a Result object or a dict(str, int) of counts). * **indices** (*List*\")*\\*[*int*\")*] | None*) – The bit positions of interest to marginalize over."
		},
		{
			"id": "qiskit.circuit.library.PhaseGate",
			"name": "qiskit.circuit.library.PhaseGate",
			"type": "class",
			"description": "Single-qubit rotation about the Z axis. This is a diagonal gate. It can be implemented virtually in hardware via framechanges (i.e. at zero error and duration). Can be applied to a QuantumCircuit with the p() method."
		},
		{
			"id": "qiskit.circuit.ControlledGate",
			"name": "qiskit.circuit.ControlledGate",
			"type": "class",
			"description": "Controlled unitary gate. Create a new ControlledGate. In the new gate the first num_ctrl_qubits of the gate are the controls. **Parameters** * **name** (*str*\")) – The name of the gate. * **num\\_qubits** (*int*\")) – The number of qubits the gate acts on."
		},
		{
			"id": "qiskit.circuit.library.IntegerComparatorGate",
			"name": "qiskit.circuit.library.IntegerComparatorGate",
			"type": "class",
			"description": "Perform a (or ) on a qubit register against a classical integer."
		},
		{
			"id": "qiskit.transpiler.passes.ContainsInstruction",
			"name": "qiskit.transpiler.passes.ContainsInstruction",
			"type": "class",
			"description": "An analysis pass to detect if the DAG contains a specific instruction. This pass takes in a single instruction name for example 'delay' and will set the property set contains_delay to True if the DAG contains that instruction and False if it does not. ContainsInstruction initializer."
		},
		{
			"id": "qiskit.circuit.library.hidden_linear_function",
			"name": "qiskit.circuit.library.hidden_linear_function",
			"type": "function",
			"description": "Circuit to solve the hidden linear function problem. The 2D Hidden Linear Function problem is determined by a 2D adjacency matrix A, where only elements that are nearest-neighbor on a grid have non-zero entries. Each row/column corresponds to one binary variable ."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisVChain",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisVChain",
			"type": "class",
			"description": "A V-chain based synthesis for MCMTGate. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.quantum_info.PTM",
			"name": "qiskit.quantum_info.PTM",
			"type": "class",
			"description": "Pauli Transfer Matrix (PTM) representation of a Quantum Channel. The PTM representation of an -qubit quantum channel is an -qubit SuperOp defined with respect to vectorization in the Pauli basis instead of column-vectorization."
		},
		{
			"id": "qiskit.compiler",
			"name": "qiskit.compiler",
			"type": "module",
			"description": "Transpile one or more circuits, according to some desired transpilation targets. Transpilation is potentially done in parallel using multiprocessing when circuits is a list with > 1 QuantumCircuit object, depending on the local environment and configuration."
		},
		{
			"id": "qiskit.circuit.library.zz_feature_map",
			"name": "qiskit.circuit.library.zz_feature_map",
			"type": "function",
			"description": "Second-order Pauli-Z evolution circuit."
		},
		{
			"id": "qiskit.transpiler.passes.Commuting2qGateRouter",
			"name": "qiskit.transpiler.passes.Commuting2qGateRouter",
			"type": "class",
			"description": "A class to swap route one or more commuting gates to the coupling map. This pass routes blocks of commuting two-qubit gates encapsulated as Commuting2qBlock instructions. This pass will not apply to other instructions. The mapping to the coupling map is done using swap strategies, see SwapStrategy."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.BMSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.BMSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Bravyi-Maslov method. The method only works on Cliffords with at most 3 qubits, for which it constructs the optimal CX cost decomposition."
		},
		{
			"id": "qiskit.circuit.library.GraphStateGate",
			"name": "qiskit.circuit.library.GraphStateGate",
			"type": "class",
			"description": "A gate representing a graph state. Given a graph G = (V, E), with the set of vertices V and the set of edges E, the corresponding graph state is defined as Such a state can be prepared by first preparing all qubits in the state, then applying a gate for each corresponding graph edge."
		},
		{
			"id": "qiskit.visualization.plot_error_map",
			"name": "qiskit.visualization.plot_error_map",
			"type": "function",
			"description": "Plots the error map of a given backend. **Parameters** * **backend** (*Backend*) – Given backend. * **figsize** (*tuple*\")) – Figure size in inches. * **show\\_title** (*bool*\")) – Show the title or not."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPluginManager",
			"name": "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPluginManager",
			"type": "class",
			"description": "Unitary Synthesis plugin manager class This class tracks the installed plugins, it has a single property, ext_plugins which contains a list of stevedore plugin objects."
		},
		{
			"id": "qiskit.quantum_info.Pauli",
			"name": "qiskit.quantum_info.Pauli",
			"type": "class",
			"description": "N-qubit Pauli operator."
		},
		{
			"id": "qiskit.circuit.library.ExactReciprocal",
			"name": "qiskit.circuit.library.ExactReciprocal",
			"type": "class",
			"description": "Exact reciprocal The class qiskit.circuit.library.arithmetic.exact_reciprocal.ExactReciprocal is deprecated as of Qiskit 2.2. It will be removed in Qiskit 3.0. Use the class qiskit.circuit.library.ExactReciprocalGate instead."
		},
		{
			"id": "qiskit.circuit.ParameterVectorElement",
			"name": "qiskit.circuit.ParameterVectorElement",
			"type": "class",
			"description": "An element of a ParameterVector. There is very little reason to ever construct this class directly. Objects of this type are automatically constructed efficiently as part of creating a ParameterVector. ## Attributes ### index Get the index of this element in the parent vector."
		},
		{
			"id": "qiskit.circuit.library.FourierChecking",
			"name": "qiskit.circuit.library.FourierChecking",
			"type": "class",
			"description": "Fourier checking circuit. The circuit for the Fourier checking algorithm, introduced in \\[1], involves a layer of Hadamards, the function , another layer of Hadamards, the function , followed by a final layer of Hadamards."
		},
		{
			"id": "qiskit.circuit.library.RZXGate",
			"name": "qiskit.circuit.library.RZXGate",
			"type": "class",
			"description": "A parametric 2-qubit interaction (rotation about ZX). This gate is maximally entangling at . The cross-resonance gate (CR) for superconducting qubits implements a ZX interaction (however other terms are also present in an experiment). Can be applied to a QuantumCircuit with the rzx() method."
		},
		{
			"id": "qiskit.dagcircuit.DAGNode",
			"name": "qiskit.dagcircuit.DAGNode",
			"type": "class",
			"description": "Parent class for DAGOpNode, DAGInNode, and DAGOutNode."
		},
		{
			"id": "qiskit.circuit.library.grover_operator",
			"name": "qiskit.circuit.library.grover_operator",
			"type": "function",
			"description": "Construct the Grover operator. Grover’s search algorithm \\[1, 2] consists of repeated applications of the so-called Grover operator used to amplify the amplitudes of the desired output states."
		},
		{
			"id": "qiskit.transpiler.StagedPassManager",
			"name": "qiskit.transpiler.StagedPassManager",
			"type": "class",
			"description": "A pass manager pipeline built from individual stages. This class enables building a compilation pipeline out of fixed stages. Each StagedPassManager defines a list of stages which are executed in a fixed order, and each stage is defined as a standalone PassManager instance."
		},
		{
			"id": "qiskit.circuit.library.RVGate",
			"name": "qiskit.circuit.library.RVGate",
			"type": "class",
			"description": "Rotation around arbitrary rotation axis where is angle of rotation in radians. Can be applied to a QuantumCircuit with the rv() method."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisXGate",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisXGate",
			"type": "class",
			"description": "A synthesis for MCMTGate with X gate as the base gate. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.quantum_info.Operator",
			"name": "qiskit.quantum_info.Operator",
			"type": "class",
			"description": "Qiskit API documentation for qiskit.quantum_info.Operator"
		},
		{
			"id": "qiskit.transpiler.passes.DAGLongestPath",
			"name": "qiskit.transpiler.passes.DAGLongestPath",
			"type": "class",
			"description": "Return the longest path in a DAGCircuit as a list of DAGOpNodes, DAGInNodes, and DAGOutNodes. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.Initialize",
			"name": "qiskit.circuit.library.Initialize",
			"type": "class",
			"description": "Complex amplitude initialization. Class that initializes some flexible collection of qubit registers, implemented by calling the StatePreparation class. Note that Initialize is an Instruction and not a Gate since it contains a reset instruction, which is not unitary."
		},
		{
			"id": "qiskit.circuit.library.PhaseOracleGate",
			"name": "qiskit.circuit.library.PhaseOracleGate",
			"type": "class",
			"description": "Implements a phase oracle. The Phase Oracle Gate object constructs circuits for any arbitrary input logical expressions. A logical expression is composed of logical operators & (logical AND), | (logical OR), \\~ (logical NOT), and ^ (logical XOR). as well as symbols for literals (variables)."
		},
		{
			"id": "qiskit.circuit.library.StatePreparation",
			"name": "qiskit.circuit.library.StatePreparation",
			"type": "class",
			"description": "Complex amplitude state preparation. Class that implements the (complex amplitude) state preparation of some flexible collection of qubit registers. **Parameters** * **params** (*str*\") *|**list*\") *|**int*\") *|**Statevector*) – * Statevector: Statevector to initialize to."
		},
		{
			"id": "qiskit.transpiler.passes.DAGFixedPoint",
			"name": "qiskit.transpiler.passes.DAGFixedPoint",
			"type": "class",
			"description": "Check if the DAG has reached a fixed point. A dummy analysis pass that checks if the DAG a fixed point (the DAG is not modified anymore). The result is saved in property_set['dag_fixed_point'] as a boolean. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.circuit.library.XXMinusYYGate",
			"name": "qiskit.circuit.library.XXMinusYYGate",
			"type": "class",
			"description": "XX-YY interaction gate. A 2-qubit parameterized XX-YY interaction. Its action is to induce a coherent rotation by some angle between and ."
		},
		{
			"id": "qiskit.transpiler.Target",
			"name": "qiskit.transpiler.Target",
			"type": "class",
			"description": "The intent of the Target object is to inform Qiskit’s compiler about the constraints of a particular backend so the compiler can compile an input circuit to something that works and is optimized for a device."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisV95",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisV95",
			"type": "class",
			"description": "A ripple-carry adder with a carry-in and a carry-out bit. This plugin name is:FullAdder.ripple_v95 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. For an adder on 2 registers with qubits each, this plugin requires at least clean auxiliary qubits."
		},
		{
			"id": "qiskit.circuit.library.ZFeatureMap",
			"name": "qiskit.circuit.library.ZFeatureMap",
			"type": "class",
			"description": "The first order Pauli Z-evolution circuit."
		},
		{
			"id": "qiskit.transpiler.TranspileLayout",
			"name": "qiskit.transpiler.TranspileLayout",
			"type": "class",
			"description": "Layout attributes for the output circuit from transpiler. The transpiler is unitary-preserving up to the “initial layout” and “final layout” permutations. The initial layout permutation is caused by setting and applying the initial layout during the Layout stage."
		},
		{
			"id": "qiskit.result.Result",
			"name": "qiskit.result.Result",
			"type": "class",
			"description": "Model for Results. ### backend\\_name backend name. **Type** str\") ### backend\\_version backend version, in the form X.Y.Z. **Type** str\") ### job\\_id unique execution id from the backend. **Type** str\") ### success True if complete input executed correctly."
		},
		{
			"id": "qiskit.transpiler.passes.PadDynamicalDecoupling",
			"name": "qiskit.transpiler.passes.PadDynamicalDecoupling",
			"type": "class",
			"description": "Dynamical decoupling insertion pass. This pass works on a scheduled, physical circuit. It scans the circuit for idle periods of time (i.e. those containing delay instructions) and inserts a DD sequence of gates in those spots."
		},
		{
			"id": "qiskit.synthesis.OneQubitEulerDecomposer",
			"name": "qiskit.synthesis.OneQubitEulerDecomposer",
			"type": "class",
			"description": "A class for decomposing 1-qubit unitaries into Euler angle rotations. The resulting decomposition is parameterized by 3 Euler rotation angle parameters , and a phase parameter . The value of the parameters for an input unitary depends on the decomposition basis."
		},
		{
			"id": "qiskit.dagcircuit",
			"name": "qiskit.dagcircuit",
			"type": "module",
			"description": "Base class for errors raised by the DAGCircuit object. Set the error message."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.MultiplierSynthesisH18",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.MultiplierSynthesisH18",
			"type": "class",
			"description": "A cumulative multiplier based on controlled adders. This plugin name is:Multiplier.cumulative_h18 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.visualization.pass_manager_drawer",
			"name": "qiskit.visualization.pass_manager_drawer",
			"type": "function",
			"description": "Draws the pass manager. This function needs pydot, which in turn needs Graphviz to be installed."
		},
		{
			"id": "qiskit.circuit.library.n_local",
			"name": "qiskit.circuit.library.n_local",
			"type": "function",
			"description": "Construct an n-local variational circuit. The structure of the n-local circuit are alternating rotation and entanglement layers. In both layers, parameterized circuit-blocks act on the circuit in a defined way."
		},
		{
			"id": "qiskit.primitives.BaseEstimatorV1",
			"name": "qiskit.primitives.BaseEstimatorV1",
			"type": "class",
			"description": "Base class for EstimatorV1 implementations. Note that the reference estimator in Qiskit follows the EstimatorV2 interface specifications instead. An estimator calculates expectation values for provided quantum circuit and observable combinations."
		},
		{
			"id": "qiskit.transpiler.passes.Width",
			"name": "qiskit.transpiler.passes.Width",
			"type": "class",
			"description": "Calculate the width of a DAG circuit. The result is saved in property_set['width'] as an integer that contains the number of qubits + the number of clbits. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass."
		},
		{
			"id": "qiskit.visualization.dag_drawer",
			"name": "qiskit.visualization.dag_drawer",
			"type": "function",
			"description": "Plot the directed acyclic graph (dag) to represent operation dependencies in a quantum circuit. This function calls the graphviz_draw()\") function from the rustworkx package to draw the DAG. **Parameters** * **dag** (*DAGCircuit* *or**DAGDependency*) – The dag to draw."
		},
		{
			"id": "qiskit.circuit.library.fourier_checking",
			"name": "qiskit.circuit.library.fourier_checking",
			"type": "function",
			"description": "Fourier checking circuit. The circuit for the Fourier checking algorithm, introduced in \\[1], involves a layer of Hadamards, the function , another layer of Hadamards, the function , followed by a final layer of Hadamards."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin",
			"name": "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin",
			"type": "class",
			"description": "Abstract high-level synthesis plugin class. This abstract class defines the interface for high-level synthesis plugins. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.circuit.library.DiagonalGate",
			"name": "qiskit.circuit.library.DiagonalGate",
			"type": "class",
			"description": "A generic diagonal quantum gate. Matrix form: Diagonal gates are useful as representations of Boolean functions, as they can map from to space. For example a phase oracle can be seen as a diagonal gate with on the diagonals."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisD00",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisD00",
			"type": "class",
			"description": "A QFT-based adder, modulo . This plugin name is:ModularAdder.qft_d00 which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Operation."
		},
		{
			"id": "qiskit.primitives.BasePrimitiveJob",
			"name": "qiskit.primitives.BasePrimitiveJob",
			"type": "class",
			"description": "Primitive job abstract base class. Initializes the primitive job. **Parameters** * **job\\_id** (*str*\")) – A unique id in the context of the primitive used to run the job. * **kwargs** – Any key value metadata to associate with this job. ## Methods ### cancel Attempt to cancel the job."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesis2s",
			"name": "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesis2s",
			"type": "class",
			"description": "An integer comparison based on 2s complement. ## Methods ### run Run synthesis for the given Operation. **Parameters** * **high\\_level\\_object** (*Operation*) – The Operation to synthesize to a DAGCircuit object."
		},
		{
			"id": "qiskit.circuit.library.OR",
			"name": "qiskit.circuit.library.OR",
			"type": "class",
			"description": "A circuit implementing the logical OR operation on a number of qubits. For the OR operation the state is interpreted as True. The result qubit is flipped, if the state of any variable qubit is True. The OR is implemented using a multi-open-controlled X gate (i.e."
		},
		{
			"id": "qiskit.qobj.GateCalibration",
			"name": "qiskit.qobj.GateCalibration",
			"type": "class",
			"description": "Each calibration specifies a unique gate by name, qubits and params, and contains the Pulse instructions to implement it. Initialize a single gate calibration. Instructions may reference waveforms which should be made available in the pulse\\_library. **Parameters** * **name** (*str*\")) – Gate name."
		},
		{
			"id": "qiskit.providers.fake_provider.Fake7QPulseV1",
			"name": "qiskit.providers.fake_provider.Fake7QPulseV1",
			"type": "class",
			"description": "* basis\\_gates: [\"id\", \"rz\", \"sx\", \"x\", \"cx\", \"reset\"] * **scheduled instructions:** \\# {'u3', 'id', 'measure', 'u2', 'x', 'u1', 'sx', 'rz'} for all individual qubits # {'cx'} for all edges # {'measure'} for (0, 1, 2, 3, 4, 5, 6) FakeBackend initializer."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.BMSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.BMSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Bravyi-Maslov method. The method only works on Cliffords with at most 3 qubits, for which it constructs the optimal CX cost decomposition."
		},
		{
			"id": "qiskit.qobj.QasmQobjInstruction",
			"name": "qiskit.qobj.QasmQobjInstruction",
			"type": "class",
			"description": "A class representing a single instruction in an QasmQobj Experiment. Instantiate a new QasmQobjInstruction object."
		},
		{
			"id": "qiskit.pulse.library.Gaussian",
			"name": "qiskit.pulse.library.Gaussian",
			"type": "class",
			"description": "A lifted and truncated pulse envelope shaped according to the Gaussian function whose mean is centered at the center of the pulse (duration / 2): where is the gaussian waveform without lifting or amplitude scaling, and . Create new pulse instance."
		},
		{
			"id": "qiskit.circuit.AncillaQubit",
			"name": "qiskit.circuit.AncillaQubit",
			"type": "class",
			"description": "A qubit used as ancillary qubit. Creates a qubit. **Parameters** * **register** (*QuantumRegister*) – Optional. A quantum register containing the bit. * **index** (*int*\")) – Optional. The index of the bit in its containing register."
		},
		{
			"id": "qiskit.pulse.instructions.Acquire",
			"name": "qiskit.pulse.instructions.Acquire",
			"type": "class",
			"description": "The Acquire instruction is used to trigger the ADC associated with a particular qubit; e.g. instantiated with AcquireChannel(0), the Acquire command will trigger data collection for the channel associated with qubit 0 readout."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.TokenSwapperSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.TokenSwapperSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on the token swapper algorithm. This plugin name is :permutation.token_swapper which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. In more detail, this plugin is used to synthesize objects of type PermutationGate."
		},
		{
			"id": "qiskit.pulse.library.GaussianDeriv",
			"name": "qiskit.pulse.library.GaussianDeriv",
			"type": "function",
			"description": "An unnormalized Gaussian derivative pulse. The Gaussian function is centered around the halfway point of the pulse, and the envelope of the pulse is given by: where , and . **Parameters** * **duration** (*int*\") *| ParameterValueType*) – Pulse length in terms of the sampling period dt."
		},
		{
			"id": "qiskit.pulse.transforms.AlignLeft",
			"name": "qiskit.pulse.transforms.AlignLeft",
			"type": "class",
			"description": "Align instructions in as-soon-as-possible manner. Instructions are placed at earliest available timeslots. Create new left-justified context. ## Attributes ### is\\_sequential ## Methods ### align Reallocate instructions according to the policy. Only top-level sub-schedules are aligned."
		},
		{
			"id": "qiskit.pulse.instructions.Delay",
			"name": "qiskit.pulse.instructions.Delay",
			"type": "class",
			"description": "A blocking instruction with no other effect. The delay is used for aligning and scheduling other instructions."
		},
		{
			"id": "qiskit.providers.fake_provider.Fake27QPulseV1",
			"name": "qiskit.providers.fake_provider.Fake27QPulseV1",
			"type": "class",
			"description": "* basis\\_gates: [\"id\", \"rz\", \"sx\", \"x\", \"cx\", \"reset\"] * **scheduled instructions:** \\# {'id', 'rz', 'u2', 'x', 'u3', 'sx', 'measure', 'u1'} for all individual qubits # {'cx'} for all edges # {'measure'} for (0, …, 26) FakeBackend initializer."
		},
		{
			"id": "qiskit.pulse.instructions.Snapshot",
			"name": "qiskit.pulse.instructions.Snapshot",
			"type": "class",
			"description": "An instruction targeted for simulators, to capture a moment in the simulation. Create new snapshot. **Parameters** * **label** (*str*\")) – Snapshot label which is used to identify the snapshot in the output."
		},
		{
			"id": "qiskit.transpiler.passes.AlignMeasures",
			"name": "qiskit.transpiler.passes.AlignMeasures",
			"type": "class",
			"description": "Measurement alignment. This is a control electronics aware optimization pass. In many quantum computing architectures gates (instructions) are implemented with shaped analog stimulus signals."
		},
		{
			"id": "qiskit.pulse.instructions.SetPhase",
			"name": "qiskit.pulse.instructions.SetPhase",
			"type": "class",
			"description": "The set phase instruction sets the phase of the proceeding pulses on that channel to phase radians. In particular, a PulseChannel creates pulses of the form The SetPhase instruction sets to the instruction’s phase operand."
		},
		{
			"id": "qiskit.pulse.instructions.ShiftFrequency",
			"name": "qiskit.pulse.instructions.ShiftFrequency",
			"type": "class",
			"description": "Shift the channel frequency away from the current frequency. Creates a new shift frequency instruction. **Parameters** * **frequency** (*float*\") *|**ParameterExpression*) – Frequency shift of the channel in Hz. * **channel** (*PulseChannel*) – The channel this instruction operates on."
		},
		{
			"id": "qiskit.pulse.channels.SnapshotChannel",
			"name": "qiskit.pulse.channels.SnapshotChannel",
			"type": "class",
			"description": "Snapshot channels are used to specify instructions for simulators. Create new snapshot channel. ## Attributes ### index Return the index of this channel. The index is a label for a control signal line typically mapped trivially to a qubit index."
		},
		{
			"id": "qiskit.result.CorrelatedReadoutMitigator",
			"name": "qiskit.result.CorrelatedReadoutMitigator",
			"type": "class",
			"description": "N-qubit readout error mitigator. Mitigates expectation_value() and quasi_probabilities(). The mitigation\\_matrix should be calibrated using qiskit experiments. This mitigation method should be used in case the readout errors of the qubits are assumed to be correlated."
		},
		{
			"id": "qiskit.transpiler.passes.StochasticSwap",
			"name": "qiskit.transpiler.passes.StochasticSwap",
			"type": "class",
			"description": "Map a DAGCircuit onto a coupling\\_map adding swap gates. Uses a randomized algorithm. **Notes** 1. Measurements may occur and be followed by swaps that result in repeated measurement of the same qubit."
		},
		{
			"id": "qiskit.providers.models.Command",
			"name": "qiskit.providers.models.Command",
			"type": "class",
			"description": "Class representing a Command. ### name Pulse command name."
		},
		{
			"id": "qiskit.providers.BackendV1",
			"name": "qiskit.providers.BackendV1",
			"type": "class",
			"description": "Abstract class for Backends This abstract class is to be used for all Backend objects created by a provider. There are several classes of information contained in a Backend. The first are the attributes of the class itself. These should be used to defined the immutable characteristics of the backend."
		},
		{
			"id": "qiskit.providers.fake_provider.Fake20QV1",
			"name": "qiskit.providers.fake_provider.Fake20QV1",
			"type": "class",
			"description": "A fake backend with the following characteristics: * num\\_qubits: 20 * coupling\\_map: > ``text > 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 > ↕ ↕ > 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 > ↕ ↕ ↕ > 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 > ↕ ↕ > 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 > ` * basis\\_gates: [\"id\", \"u1\", \"u2\", \"u3\", \"cx\"] FakeBackend initializer."
		},
		{
			"id": "qiskit.pulse.channels.DriveChannel",
			"name": "qiskit.pulse.channels.DriveChannel",
			"type": "class",
			"description": "Drive channels transmit signals to qubits which enact gate operations. Channel class. **Parameters** **index** – Index of channel. ## Attributes ### index Return the index of this channel. The index is a label for a control signal line typically mapped trivially to a qubit index."
		},
		{
			"id": "qiskit.circuit.Qubit",
			"name": "qiskit.circuit.Qubit",
			"type": "class",
			"description": "Implement a quantum bit. Creates a qubit. **Parameters** * **register** (*QuantumRegister*) – Optional. A quantum register containing the bit. * **index** (*int*\")) – Optional. The index of the bit in its containing register."
		},
		{
			"id": "qiskit.circuit.Register",
			"name": "qiskit.circuit.Register",
			"type": "class",
			"description": "Implement a generic register. This class should not be instantiated directly. This is just a superclass for ClassicalRegister and QuantumRegister. Create a new generic register. Either the size or the bits argument must be provided."
		},
		{
			"id": "qiskit.providers.models",
			"name": "qiskit.providers.models",
			"type": "module",
			"description": "qiskit.providers.models Qiskit schema-conformant objects used by the backends and providers."
		},
		{
			"id": "qiskit.circuit.ClassicalRegister",
			"name": "qiskit.circuit.ClassicalRegister",
			"type": "class",
			"description": "Implement a classical register. Create a new generic register. Either the size or the bits argument must be provided. If size is not None, the register will be pre-populated with bits of the correct type. **Parameters** * **size** (*int*\")) – Optional. The number of bits to include in the register."
		},
		{
			"id": "qiskit.transpiler.passes.NormalizeRXAngle",
			"name": "qiskit.transpiler.passes.NormalizeRXAngle",
			"type": "class",
			"description": "Normalize theta parameter of RXGate instruction. The parameter normalization is performed with following steps. 1\\) Wrap RX Gate theta into \\[0, pi]. When theta is negative value, the gate is decomposed into the following sequence."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.GreedySynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.GreedySynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the greedy synthesis Bravyi-Hu-Maslov-Shaydulin method. This plugin name is :clifford.greedy which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Clifford."
		},
		{
			"id": "qiskit.qobj.PulseQobjConfig",
			"name": "qiskit.qobj.PulseQobjConfig",
			"type": "class",
			"description": "A configuration for a Pulse Qobj. Instantiate a PulseQobjConfig object. **Parameters** * **meas\\_level** (*int*\")) – The measurement level to use. * **meas\\_return** (*int*\")) – The level of measurement information to return."
		},
		{
			"id": "qiskit.pulse.InstructionScheduleMap",
			"name": "qiskit.pulse.InstructionScheduleMap",
			"type": "class",
			"description": "Mapping from QuantumCircuit qiskit.circuit.Instruction names and qubits to Schedule s. In particular, the mapping is formatted as type: ``python Dict[str, Dict[Tuple[int], Schedule]] ` where the first key is the name of a circuit instruction (e.g."
		},
		{
			"id": "qiskit.primitives.BackendSampler",
			"name": "qiskit.primitives.BackendSampler",
			"type": "class",
			"description": "A BaseSampler implementation that provides an interface for leveraging the sampler interface from any backend. This class provides a sampler interface from any backend and doesn’t do any measurement mitigation, it just computes the probability distribution from the counts."
		},
		{
			"id": "qiskit.qobj.QobjExperimentHeader",
			"name": "qiskit.qobj.QobjExperimentHeader",
			"type": "class",
			"description": "A class representing a header dictionary for a Qobj Experiment. Instantiate a new Qobj dict field object. **Parameters** **kwargs** – arbitrary keyword arguments that can be accessed as attributes of the object. ## Methods ### from\\_dict Create a new QobjHeader object from a dictionary."
		},
		{
			"id": "qiskit.primitives.BackendEstimator",
			"name": "qiskit.primitives.BackendEstimator",
			"type": "class",
			"description": "Evaluates expectation value using Pauli rotation gates. The BackendEstimator class is a generic implementation of the BaseEstimator interface that is used to wrap a BackendV2 (or BackendV1) object in the BaseEstimator API."
		},
		{
			"id": "qiskit.pulse.channels.AcquireChannel",
			"name": "qiskit.pulse.channels.AcquireChannel",
			"type": "class",
			"description": "Acquire channels are used to collect data. Channel class. **Parameters** **index** – Index of channel. ## Attributes ### index Return the index of this channel. The index is a label for a control signal line typically mapped trivially to a qubit index."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeOpenPulse2Q",
			"name": "qiskit.providers.fake_provider.FakeOpenPulse2Q",
			"type": "class",
			"description": "A fake 2 qubit backend for pulse test. FakeBackend initializer."
		},
		{
			"id": "qiskit.transpiler.passes.ConvertConditionsToIfOps",
			"name": "qiskit.transpiler.passes.ConvertConditionsToIfOps",
			"type": "class",
			"description": "Convert instructions whose condition attribute is set to a non-None value into the equivalent single-statement IfElseBlock. This is a simple pass aimed at easing the conversion from the old style of using InstructionSet.c_if() into the new style of using more complex conditional logic."
		},
		{
			"id": "qiskit.providers.models.GateProperties",
			"name": "qiskit.providers.models.GateProperties",
			"type": "class",
			"description": "Class representing a gate’s properties ### qubits qubits. ### gate gate. ### parameters parameters."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.KMSSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.KMSSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on the Kutin, Moulton, Smithline method. This plugin name is :permutation.kms which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Permutation."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.LayerLnnSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.LayerLnnSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Bravyi-Maslov method to synthesize Cliffords into layers, with each layer synthesized adhering to LNN connectivity. This plugin name is :clifford.lnn which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis."
		},
		{
			"id": "qiskit.pulse.transforms.AlignEquispaced",
			"name": "qiskit.pulse.transforms.AlignEquispaced",
			"type": "class",
			"description": "Align instructions with equispaced interval within a specified duration. Instructions played on different channels are also arranged in a sequence. This alignment is convenient to create dynamical decoupling sequences such as PDD. Create new equispaced context."
		},
		{
			"id": "qiskit.transpiler.passes.ValidatePulseGates",
			"name": "qiskit.transpiler.passes.ValidatePulseGates",
			"type": "class",
			"description": "Check custom gate length. This is a control electronics aware analysis pass. Quantum gates (instructions) are often implemented with shaped analog stimulus signals."
		},
		{
			"id": "qiskit.providers.models.QasmBackendConfiguration",
			"name": "qiskit.providers.models.QasmBackendConfiguration",
			"type": "class",
			"description": "Class representing an OpenQASM 2.0 Backend Configuration. ### backend\\_name backend name. ### backend\\_version backend version in the form X.Y.Z. ### n\\_qubits number of qubits. ### basis\\_gates list of basis gates names on the backend. ### gates list of basis gates on the backend."
		},
		{
			"id": "qiskit.providers.BackendV2Converter",
			"name": "qiskit.providers.BackendV2Converter",
			"type": "class",
			"description": "A converter class that takes a BackendV1 instance and wraps it in a BackendV2 interface. This class implements the BackendV2 interface and is used to enable common access patterns between BackendV1 and BackendV2."
		},
		{
			"id": "qiskit.pulse.transforms.AlignFunc",
			"name": "qiskit.pulse.transforms.AlignFunc",
			"type": "class",
			"description": "Allocate instructions at position specified by callback function. The position is specified for each instruction of index j as a fractional coordinate in \\[0, 1] within the specified duration. Instructions played on different channels are also arranged in a sequence."
		},
		{
			"id": "qiskit.circuit.Bit",
			"name": "qiskit.circuit.Bit",
			"type": "class",
			"description": "Implement a generic bit. This class should not be instantiated directly. This is just a superclass for Clbit and Qubit. Create a new generic bit."
		},
		{
			"id": "qiskit.qobj",
			"name": "qiskit.qobj",
			"type": "module",
			"description": "qiskit.qobj"
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.LayerSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.LayerSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Bravyi-Maslov method to synthesize Cliffords into layers. This plugin name is :clifford.layers which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Clifford."
		},
		{
			"id": "qiskit.scheduler",
			"name": "qiskit.scheduler",
			"type": "module",
			"description": "Configuration for pulse scheduling. Container for information needed to schedule a QuantumCircuit into a pulse Schedule. **Parameters** * **inst\\_map** (*InstructionScheduleMap*) – The schedule definition of all gates supported on a backend."
		},
		{
			"id": "qiskit.circuit.Delay",
			"name": "qiskit.circuit.Delay",
			"type": "class",
			"description": "Do nothing and just delay/wait/idle for a specified duration. Create new delay instruction. ## Attributes ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit.qobj.QasmQobjExperiment",
			"name": "qiskit.qobj.QasmQobjExperiment",
			"type": "class",
			"description": "An OpenQASM 2 Qobj Experiment. Each instance of this class is used to represent an OpenQASM 2 experiment as part of a larger OpenQASM 2 qobj. Instantiate a QasmQobjExperiment."
		},
		{
			"id": "qiskit.pulse.library.Drag",
			"name": "qiskit.pulse.library.Drag",
			"type": "class",
			"description": "The Derivative Removal by Adiabatic Gate (DRAG) pulse is a standard Gaussian pulse with an additional Gaussian derivative component and lifting applied."
		},
		{
			"id": "qiskit.providers.models.BackendStatus",
			"name": "qiskit.providers.models.BackendStatus",
			"type": "class",
			"description": "Class representing Backend Status."
		},
		{
			"id": "qiskit.providers.models.PulseDefaults",
			"name": "qiskit.providers.models.PulseDefaults",
			"type": "class",
			"description": "Description of default settings for Pulse systems. These are instructions or settings that may be good starting points for the Pulse user. The user may modify these defaults for custom scheduling. Validate and reformat transport layer inputs to initialize."
		},
		{
			"id": "qiskit.pulse.library.Sin",
			"name": "qiskit.pulse.library.Sin",
			"type": "function",
			"description": "A sinusoidal pulse. The envelope of the pulse is given by: where . **Parameters** * **duration** (*int*\") *|**ParameterExpression*) – Pulse length in terms of the sampling period dt. * **amp** (*float*\") *|**ParameterExpression*) – The magnitude of the amplitude of the sinusoidal wave."
		},
		{
			"id": "qiskit.result.LocalReadoutMitigator",
			"name": "qiskit.result.LocalReadoutMitigator",
			"type": "class",
			"description": "1-qubit tensor product readout error mitigator. Mitigates expectation_value() and quasi_probabilities(). The mitigator should either be calibrated using qiskit experiments, or calculated directly from the backend properties."
		},
		{
			"id": "qiskit.qobj.PulseQobjExperimentConfig",
			"name": "qiskit.qobj.PulseQobjExperimentConfig",
			"type": "class",
			"description": "A config for a single Pulse experiment in the qobj. Instantiate a PulseQobjExperimentConfig object. **Parameters** * **qubit\\_lo\\_freq** (*List\\*[*float*\")*]*) – List of qubit LO frequencies in GHz. * **meas\\_lo\\_freq** (*List\\*[*float*\")*]*) – List of meas readout LO frequencies in GHz."
		},
		{
			"id": "qiskit.providers.models.Nduv",
			"name": "qiskit.providers.models.Nduv",
			"type": "class",
			"description": "Class representing name-date-unit-value ### date date. ### name name. ### unit unit. ### value value."
		},
		{
			"id": "qiskit.pulse.library.Constant",
			"name": "qiskit.pulse.library.Constant",
			"type": "class",
			"description": "A simple constant pulse, with an amplitude value and a duration: Create new pulse instance. **Parameters** * **duration** – Pulse length in terms of the sampling period dt. * **amp** – The magnitude of the amplitude of the square envelope."
		},
		{
			"id": "qiskit.providers.fake_provider.Fake1Q",
			"name": "qiskit.providers.fake_provider.Fake1Q",
			"type": "class",
			"description": "A fake 1Q backend. 0 ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used. These are used to control the run() method. ### version ## Methods ### configuration Return the backend configuration."
		},
		{
			"id": "qiskit.pulse.library.Sawtooth",
			"name": "qiskit.pulse.library.Sawtooth",
			"type": "function",
			"description": "A sawtooth pulse. The envelope of the pulse is given by: where , , and is the floor operation. **Parameters** * **duration** (*int*\") *|**ParameterExpression*) – Pulse length in terms of the sampling period dt."
		},
		{
			"id": "qiskit.providers.models.BackendProperties",
			"name": "qiskit.providers.models.BackendProperties",
			"type": "class",
			"description": "Class representing backend properties This holds backend properties measured by the provider. All properties which are provided optionally. These properties may describe qubits, gates, or other general properties of the backend. Initialize a BackendProperties instance."
		},
		{
			"id": "qiskit.qobj.PulseQobjExperiment",
			"name": "qiskit.qobj.PulseQobjExperiment",
			"type": "class",
			"description": "A Pulse Qobj Experiment. Each instance of this class is used to represent an individual Pulse experiment as part of a larger Pulse Qobj. Instantiate a PulseQobjExperiment."
		},
		{
			"id": "qiskit.transpiler.passes.ALAPSchedule",
			"name": "qiskit.transpiler.passes.ALAPSchedule",
			"type": "class",
			"description": "ALAP Scheduling pass, which schedules the **stop** time of instructions as late as possible. See BaseSchedulerTransform for the detailed behavior of the control flow operation, i.e. c_if. The class qiskit.transpiler.passes.scheduling.alap.ALAPSchedule is pending deprecation as of qiskit 0.21.0."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.PMHSynthesisLinearFunction",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.PMHSynthesisLinearFunction",
			"type": "class",
			"description": "Linear function synthesis plugin based on the Patel-Markov-Hayes method. This plugin name is :linear_function.pmh which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given LinearFunction."
		},
		{
			"id": "qiskit.circuit.classicalfunction",
			"name": "qiskit.circuit.classicalfunction",
			"type": "module",
			"description": "qiskit.circuit.classicalfunction"
		},
		{
			"id": "qiskit.circuit.classicalfunction.ClassicalFunction",
			"name": "qiskit.circuit.classicalfunction.ClassicalFunction",
			"type": "class",
			"description": "Represent a classical function and its logic network. Creates a ClassicalFunction from Python source code in source. The code should be a single function with types. **Parameters** * **source** (*str*\")) – Python code with type hints. * **name** (*str*\")) – Optional. Default: “*classicalfunction*”."
		},
		{
			"id": "qiskit.circuit.classicalfunction.BooleanExpression",
			"name": "qiskit.circuit.classicalfunction.BooleanExpression",
			"type": "class",
			"description": "The Boolean Expression gate. **Parameters** * **expression** (*str*\")) – The logical expression string. * **name** (*str*\")) – Optional. Instruction gate name. Otherwise part of the expression is going to be used. * **var\\_order** (*list*\")) – A list with the order in which variables will be created."
		},
		{
			"id": "qiskit.pulse.channels.MeasureChannel",
			"name": "qiskit.pulse.channels.MeasureChannel",
			"type": "class",
			"description": "Measure channels transmit measurement stimulus pulses for readout. Channel class. **Parameters** **index** – Index of channel. ## Attributes ### index Return the index of this channel. The index is a label for a control signal line typically mapped trivially to a qubit index."
		},
		{
			"id": "qiskit.pulse.library.Waveform",
			"name": "qiskit.pulse.library.Waveform",
			"type": "class",
			"description": "A pulse specified completely by complex-valued samples; each sample is played for the duration of the backend cycle-time, dt. Create new sample pulse command. **Parameters** * **samples** (*np.ndarray |* *list*\")*\\*[*complex*\")*]*) – Complex array of the samples in the pulse envelope."
		},
		{
			"id": "qiskit.qobj.PulseQobj",
			"name": "qiskit.qobj.PulseQobj",
			"type": "class",
			"description": "A Pulse Qobj. Instantiate a new Pulse Qobj Object. Each Pulse Qobj object is used to represent a single payload that will be passed to a Qiskit provider. It mirrors the Qobj the published Qobj specification for Pulse experiments."
		},
		{
			"id": "qiskit.pulse.instructions.Reference",
			"name": "qiskit.pulse.instructions.Reference",
			"type": "class",
			"description": "Pulse compiler directive that refers to a subroutine. If a pulse program uses the same subset of instructions multiple times, then using the Reference class may significantly reduce the memory footprint of the program. This instruction only stores the set of strings to identify the subroutine."
		},
		{
			"id": "qiskit.pulse.instructions.RelativeBarrier",
			"name": "qiskit.pulse.instructions.RelativeBarrier",
			"type": "class",
			"description": "Pulse RelativeBarrier directive. Create a relative barrier directive. The barrier directive blocks instructions within the same schedule as the barrier on channels contained within this barrier from moving through the barrier in time."
		},
		{
			"id": "qiskit.pulse.library.gaussian_square_echo",
			"name": "qiskit.pulse.library.gaussian_square_echo",
			"type": "function",
			"description": "An echoed Gaussian square pulse with an active tone overlaid on it. The Gaussian Square Echo pulse is composed of three pulses."
		},
		{
			"id": "qiskit.qobj.QasmQobj",
			"name": "qiskit.qobj.QasmQobj",
			"type": "class",
			"description": "An OpenQASM 2 Qobj. Instantiate a new OpenQASM 2 Qobj Object. Each OpenQASM 2 Qobj object is used to represent a single payload that will be passed to a Qiskit provider. It mirrors the Qobj the published Qobj specification for OpenQASM experiments."
		},
		{
			"id": "qiskit.pulse.library.Cos",
			"name": "qiskit.pulse.library.Cos",
			"type": "function",
			"description": "A cosine pulse. The envelope of the pulse is given by: where . **Parameters** * **duration** (*int*\") *|**ParameterExpression*) – Pulse length in terms of the sampling period dt. * **amp** (*float*\") *|**ParameterExpression*) – The magnitude of the amplitude of the cosine wave."
		},
		{
			"id": "qiskit.transpiler.passes.DynamicalDecoupling",
			"name": "qiskit.transpiler.passes.DynamicalDecoupling",
			"type": "class",
			"description": "Dynamical decoupling insertion pass. This pass works on a scheduled, physical circuit. It scans the circuit for idle periods of time (i.e. those containing delay instructions) and inserts a DD sequence of gates in those spots."
		},
		{
			"id": "qiskit.circuit.library.Barrier",
			"name": "qiskit.circuit.library.Barrier",
			"type": "class",
			"description": "Barrier instruction. A barrier is a visual indicator of the grouping of a circuit section. It also acts as a directive for circuit compilation to separate pieces of a circuit so that any optimizations or re-writes are constrained to only act between barriers. Create new barrier instruction."
		},
		{
			"id": "qiskit.pulse",
			"name": "qiskit.pulse",
			"type": "module",
			"description": "The smallest schedulable unit: a single instruction. It has a fixed duration and specified channels. Instruction initializer. **Parameters** * **operands** (*tuple*\")) – The argument list. * **name** (*str*\") *| None*) – Optional display name for this instruction."
		},
		{
			"id": "qiskit.providers.models.JobStatus",
			"name": "qiskit.providers.models.JobStatus",
			"type": "class",
			"description": "Model for JobStatus. ### job\\_id backend job\\_id. **Type** str\") ### status status of the job. **Type** str\") ### status\\_msg status message. **Type** str\") ## Methods ### from\\_dict Create a new JobStatus object from a dictionary."
		},
		{
			"id": "qiskit.providers.fake_provider.Fake5QV1",
			"name": "qiskit.providers.fake_provider.Fake5QV1",
			"type": "class",
			"description": "A fake backend with the following characteristics: * num\\_qubits: 5 * coupling\\_map: > ``text > 1 > / | > 0 - 2 - 3 > | / > 4 > ` * basis\\_gates: [\"id\", \"rz\", \"sx\", \"x\", \"cx\", \"reset\"] FakeBackend initializer."
		},
		{
			"id": "qiskit.circuit.ControlModifier",
			"name": "qiskit.circuit.ControlModifier",
			"type": "class",
			"description": "Control modifier: specifies that the operation is controlled by num_ctrl_qubits and has control state ctrl_state. ## Attributes ### ctrl\\_state ### num\\_ctrl\\_qubits"
		},
		{
			"id": "qiskit.circuit.PowerModifier",
			"name": "qiskit.circuit.PowerModifier",
			"type": "class",
			"description": "Power modifier: specifies that the operation is raised to the power power. ## Attributes ### power"
		},
		{
			"id": "qiskit.pulse.channels.MemorySlot",
			"name": "qiskit.pulse.channels.MemorySlot",
			"type": "class",
			"description": "Memory slot channels represent classical memory storage. Channel class. **Parameters** **index** – Index of channel. ## Attributes ### index Return the index of this channel. The index is a label for a control signal line typically mapped trivially to a qubit index."
		},
		{
			"id": "qiskit.qobj.PulseQobjInstruction",
			"name": "qiskit.qobj.PulseQobjInstruction",
			"type": "class",
			"description": "A class representing a single instruction in an PulseQobj Experiment. Instantiate a new PulseQobjInstruction object. **Parameters** * **name** (*str*\")) – The name of the instruction * **t0** (*int*\")) – Pulse start time in integer **dt** units."
		},
		{
			"id": "qiskit.primitives.Sampler",
			"name": "qiskit.primitives.Sampler",
			"type": "class",
			"description": "Sampler class. Sampler is a reference implementation of BaseSampler. **Run Options** * **shots** (None or int) – The number of shots. If None, it calculates the probabilities. Otherwise, it samples from multinomial distributions."
		},
		{
			"id": "qiskit.qobj.QasmQobjConfig",
			"name": "qiskit.qobj.QasmQobjConfig",
			"type": "class",
			"description": "A configuration for an OpenQASM 2 Qobj. Model for RunConfig. **Parameters** * **shots** (*int*\")) – the number of shots."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.BasicSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.BasicSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on sorting. This plugin name is :permutation.basic which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Permutation."
		},
		{
			"id": "qiskit.pulse.Schedule",
			"name": "qiskit.pulse.Schedule",
			"type": "class",
			"description": "A quantum program *schedule* with exact time constraints for its instructions, operating over all input signal *channels* and supporting special syntaxes for building. Pulse program representation for the original Qiskit Pulse model \\[1]."
		},
		{
			"id": "qiskit.pulse.instructions.TimeBlockade",
			"name": "qiskit.pulse.instructions.TimeBlockade",
			"type": "class",
			"description": "Pulse TimeBlockade directive. This instruction is intended to be used internally within the pulse builder, to convert Schedule into ScheduleBlock."
		},
		{
			"id": "qiskit.providers.fake_provider.Fake127QPulseV1",
			"name": "qiskit.providers.fake_provider.Fake127QPulseV1",
			"type": "class",
			"description": "Qiskit API documentation for qiskit.providers.fake_provider.Fake127QPulseV1"
		},
		{
			"id": "qiskit.primitives.Estimator",
			"name": "qiskit.primitives.Estimator",
			"type": "class",
			"description": "Reference implementation of BaseEstimator. **Run Options** * **shots** (None or int) – The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation."
		},
		{
			"id": "qiskit.qobj.QobjHeader",
			"name": "qiskit.qobj.QobjHeader",
			"type": "class",
			"description": "A class used to represent a dictionary header in Qobj objects. Instantiate a new Qobj dict field object. **Parameters** **kwargs** – arbitrary keyword arguments that can be accessed as attributes of the object. ## Methods ### from\\_dict Create a new QobjHeader object from a dictionary."
		},
		{
			"id": "qiskit.circuit.InverseModifier",
			"name": "qiskit.circuit.InverseModifier",
			"type": "class",
			"description": "Inverse modifier: specifies that the operation is inverted."
		},
		{
			"id": "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho",
			"name": "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho",
			"type": "class",
			"description": "Creates calibrations for RZXGate(theta) by stretching and compressing Gaussian square pulses in the CX gate."
		},
		{
			"id": "qiskit.result.BaseReadoutMitigator",
			"name": "qiskit.result.BaseReadoutMitigator",
			"type": "class",
			"description": "Base readout error mitigator class. ## Methods ### expectation\\_value Calculate the expectation value of a diagonal Hermitian operator. **Parameters** * **data** (*Counts*) – Counts object to be mitigated. * **diagonal** (*Callable*\") *|**dict*\") *|**str*\") *|**ndarray*\")) – the diagonal operator."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.DefaultSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.DefaultSynthesisClifford",
			"type": "class",
			"description": "The default clifford synthesis plugin. For N \\ 3 qubits this is done using the general non-optimal greedy compilation routine from reference by Bravyi, Hu, Maslov, Shaydulin."
		},
		{
			"id": "qiskit.pulse.instructions.Play",
			"name": "qiskit.pulse.instructions.Play",
			"type": "class",
			"description": "This instruction is responsible for applying a pulse on a channel. The pulse specifies the exact time dynamics of the output signal envelope for a limited time. The output is modulated by a phase and frequency which are controlled by separate instructions."
		},
		{
			"id": "qiskit.transpiler.passes.PulseGates",
			"name": "qiskit.transpiler.passes.PulseGates",
			"type": "class",
			"description": "Pulse gate adding pass. This pass adds gate calibrations from the supplied InstructionScheduleMap to a quantum circuit. This pass checks each DAG circuit node and acquires a corresponding schedule from the instruction schedule map object that may be provided by the target backend."
		},
		{
			"id": "qiskit.assembler.RunConfig",
			"name": "qiskit.assembler.RunConfig",
			"type": "class",
			"description": "Class for Run Configuration."
		},
		{
			"id": "qiskit.pulse.library.SymbolicPulse",
			"name": "qiskit.pulse.library.SymbolicPulse",
			"type": "class",
			"description": "The pulse representation model with parameters and symbolic expressions. A symbolic pulse instance can be defined with an envelope and parameter constraints. Envelope and parameter constraints should be provided as symbolic expressions."
		},
		{
			"id": "qiskit.providers.Provider",
			"name": "qiskit.providers.Provider",
			"type": "class",
			"description": "Base common type for all versioned Provider abstract classes. Note this class should not be inherited from directly, it is intended to be used for type checking. When implementing a provider you should use the versioned abstract classes as the parent class and not this class directly."
		},
		{
			"id": "qiskit.transpiler.passes.RZXCalibrationBuilder",
			"name": "qiskit.transpiler.passes.RZXCalibrationBuilder",
			"type": "class",
			"description": "Creates calibrations for RZXGate(theta) by stretching and compressing Gaussian square pulses in the CX gate. This is done by retrieving (for a given pair of qubits) the CX schedule in the instruction schedule map of the backend defaults."
		},
		{
			"id": "qiskit.pulse.library.Square",
			"name": "qiskit.pulse.library.Square",
			"type": "function",
			"description": "A square wave pulse. The envelope of the pulse is given by: where , and is the sign function with the convention . **Parameters** * **duration** (*int*\") *| ParameterValueType*) – Pulse length in terms of the sampling period dt."
		},
		{
			"id": "qiskit.providers.models.PulseBackendConfiguration",
			"name": "qiskit.providers.models.PulseBackendConfiguration",
			"type": "class",
			"description": "Static configuration state for an OpenPulse enabled backend. This contains information about the set up of the device which can be useful for building Pulse programs. Initialize a backend configuration that contains all the extra configuration that is made available for OpenPulse backends."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.unitary_synthesis.DefaultUnitarySynthesis",
			"name": "qiskit.transpiler.passes.synthesis.unitary_synthesis.DefaultUnitarySynthesis",
			"type": "class",
			"description": "The default unitary synthesis plugin."
		},
		{
			"id": "qiskit.pulse.ScheduleBlock",
			"name": "qiskit.pulse.ScheduleBlock",
			"type": "class",
			"description": "Time-ordered sequence of instructions with alignment context. ScheduleBlock supports lazy scheduling of context instructions, i.e. their timeslots is always generated at runtime. This indicates we can parametrize instruction durations as well as other parameters."
		},
		{
			"id": "qiskit.circuit.Clbit",
			"name": "qiskit.circuit.Clbit",
			"type": "class",
			"description": "Implement a classical bit. Creates a classical bit. **Parameters** * **register** (*ClassicalRegister*) – Optional. A classical register containing the bit. * **index** (*int*\")) – Optional. The index of the bit in its containing register."
		},
		{
			"id": "qiskit.qobj.QasmQobjExperimentConfig",
			"name": "qiskit.qobj.QasmQobjExperimentConfig",
			"type": "class",
			"description": "Configuration for a single OpenQASM 2 experiment in the qobj. **Parameters** * **calibrations** (*QasmExperimentCalibrations*) – Information required for Pulse gates. * **qubit\\_lo\\_freq** (*List\\*[*float*\")*]*) – List of qubit LO frequencies in GHz."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeOpenPulse3Q",
			"name": "qiskit.providers.fake_provider.FakeOpenPulse3Q",
			"type": "class",
			"description": "Trivial extension of the FakeOpenPulse2Q. FakeBackend initializer."
		},
		{
			"id": "qiskit.pulse.instructions.ShiftPhase",
			"name": "qiskit.pulse.instructions.ShiftPhase",
			"type": "class",
			"description": "The shift phase instruction updates the modulation phase of proceeding pulses played on the same Channel. It is a relative increase in phase determined by the phase operand."
		},
		{
			"id": "qiskit.pulse.channels.RegisterSlot",
			"name": "qiskit.pulse.channels.RegisterSlot",
			"type": "class",
			"description": "Classical resister slot channels represent classical registers (low-latency classical memory). Channel class. **Parameters** **index** – Index of channel. ## Attributes ### index Return the index of this channel. The index is a label for a control signal line typically mapped trivially to a qubit index."
		},
		{
			"id": "qiskit.providers.ProviderV1",
			"name": "qiskit.providers.ProviderV1",
			"type": "class",
			"description": "Base class for a Backend Provider. ## Attributes ### version ## Methods ### backends Return a list of backends matching the specified filtering. **Parameters** * **name** (*str*\")) – name of the backend. * **\\*\\*kwargs** – dict used for filtering."
		},
		{
			"id": "qiskit.primitives.BaseEstimator",
			"name": "qiskit.primitives.BaseEstimator",
			"type": "attribute",
			"description": "alias of BaseEstimatorV1"
		},
		{
			"id": "qiskit.transpiler.passes.RXCalibrationBuilder",
			"name": "qiskit.transpiler.passes.RXCalibrationBuilder",
			"type": "class",
			"description": "Add single-pulse RX calibrations that are bootstrapped from the SX calibration. Requirement: NormalizeRXAngles pass (one of the optimization passes). It is recommended to place this pass in the post-optimization stage of a passmanager."
		},
		{
			"id": "qiskit.transpiler.passes.EchoRZXWeylDecomposition",
			"name": "qiskit.transpiler.passes.EchoRZXWeylDecomposition",
			"type": "class",
			"description": "Rewrite two-qubit gates using the Weyl decomposition. This transpiler pass rewrites two-qubit gates in terms of echoed cross-resonance gates according to the Weyl decomposition. A two-qubit gate will be replaced with at most six non-echoed RZXGates. Each pair of RZXGates forms an echoed RZXGate."
		},
		{
			"id": "qiskit.pulse.library.Triangle",
			"name": "qiskit.pulse.library.Triangle",
			"type": "function",
			"description": "A triangle wave pulse. The envelope of the pulse is given by: where , and is a sawtooth wave with the same frequency as the triangle wave, but a phase shifted by . **Parameters** * **duration** (*int*\") *|**ParameterExpression*) – Pulse length in terms of the sampling period dt."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.ACGSynthesisPermutation",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.ACGSynthesisPermutation",
			"type": "class",
			"description": "The permutation synthesis plugin based on the Alon, Chung, Graham method. This plugin name is :permutation.acg which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Permutation."
		},
		{
			"id": "qiskit.primitives.BaseSampler",
			"name": "qiskit.primitives.BaseSampler",
			"type": "attribute",
			"description": "alias of BaseSamplerV1"
		},
		{
			"id": "qiskit.providers.models.GateConfig",
			"name": "qiskit.providers.models.GateConfig",
			"type": "class",
			"description": "Class representing a Gate Configuration ### name the gate name as it will be referred to in OpenQASM. ### parameters variable names for the gate parameters (if any). ### qasm\\_def definition of this gate in terms of OpenQASM 2 primitives U and CX."
		},
		{
			"id": "qiskit.circuit.AncillaRegister",
			"name": "qiskit.circuit.AncillaRegister",
			"type": "class",
			"description": "Implement an ancilla register. Create a new generic register. Either the size or the bits argument must be provided. If size is not None, the register will be pre-populated with bits of the correct type. **Parameters** * **size** (*int*\")) – Optional. The number of bits to include in the register."
		},
		{
			"id": "qiskit.transpiler.passes.ASAPSchedule",
			"name": "qiskit.transpiler.passes.ASAPSchedule",
			"type": "class",
			"description": "ASAP Scheduling pass, which schedules the start time of instructions as early as possible.. See BaseSchedulerTransform for the detailed behavior of the control flow operation, i.e. c_if. This base class has been superseded by ASAPScheduleAnalysis and the new scheduling workflow."
		},
		{
			"id": "qiskit.pulse.channels.ControlChannel",
			"name": "qiskit.pulse.channels.ControlChannel",
			"type": "class",
			"description": "Control channels provide supplementary control over the qubit to the drive channel. These are often associated with multi-qubit gate operations. They may not map trivially to a particular qubit index. Channel class. **Parameters** **index** – Index of channel."
		},
		{
			"id": "qiskit.pulse.library.SechDeriv",
			"name": "qiskit.pulse.library.SechDeriv",
			"type": "function",
			"description": "An unnormalized sech derivative pulse. The sech function is centered around the halfway point of the pulse, and the envelope of the pulse is given by: where , , and is a derivative with respect to x."
		},
		{
			"id": "qiskit.circuit.QuantumRegister",
			"name": "qiskit.circuit.QuantumRegister",
			"type": "class",
			"description": "Implement a quantum register. Create a new generic register. Either the size or the bits argument must be provided. If size is not None, the register will be pre-populated with bits of the correct type. **Parameters** * **size** (*int*\")) – Optional. The number of bits to include in the register."
		},
		{
			"id": "qiskit.circuit.classicalfunction.ClassicalFunctionParseError",
			"name": "qiskit.circuit.classicalfunction.ClassicalFunctionParseError",
			"type": "exception",
			"description": "ClassicalFunction compiler parse error. The classicalfunction function fails at parsing time. Set the error message."
		},
		{
			"id": "qiskit.pulse.library.Sech",
			"name": "qiskit.pulse.library.Sech",
			"type": "function",
			"description": "An unnormalized sech pulse. The sech function is centered around the halfway point of the pulse, and the envelope of the pulse is given by: where , and . If zero\\_ends is set to True, the output y is modified: .."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.KMSSynthesisLinearFunction",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.KMSSynthesisLinearFunction",
			"type": "class",
			"description": "Linear function synthesis plugin based on the Kutin-Moulton-Smithline method. This plugin name is :linear_function.kms which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given LinearFunction."
		},
		{
			"id": "qiskit.providers.convert_to_target",
			"name": "qiskit.providers.convert_to_target",
			"type": "function",
			"description": "Decode transpiler target from backend data set. This function generates ` Target ` instance from intermediate legacy objects such as BackendProperties and PulseDefaults. These objects are usually components of the legacy BackendV1 model."
		},
		{
			"id": "qiskit.transpiler.passes.CXCancellation",
			"name": "qiskit.transpiler.passes.CXCancellation",
			"type": "class",
			"description": "Cancel back-to-back cx gates in dag. ## Attributes ### is\\_analysis\\_pass Check if the pass is an analysis pass. If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.AGSynthesisClifford",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.AGSynthesisClifford",
			"type": "class",
			"description": "Clifford synthesis plugin based on the Aaronson-Gottesman method. This plugin name is :clifford.ag which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given Clifford."
		},
		{
			"id": "qiskit.pulse.transforms.AlignSequential",
			"name": "qiskit.pulse.transforms.AlignSequential",
			"type": "class",
			"description": "Align instructions sequentially. Instructions played on different channels are also arranged in a sequence. No buffer time is inserted in between instructions. Create new sequential context. ## Attributes ### is\\_sequential ## Methods ### align Reallocate instructions according to the policy."
		},
		{
			"id": "qiskit.qobj.QobjMeasurementOption",
			"name": "qiskit.qobj.QobjMeasurementOption",
			"type": "class",
			"description": "An individual measurement option. Instantiate a new QobjMeasurementOption object. **Parameters** * **name** (*str*\")) – The name of the measurement option * **params** (*list*\")) – The parameters of the measurement option."
		},
		{
			"id": "qiskit.circuit.library.Measure",
			"name": "qiskit.circuit.library.Measure",
			"type": "class",
			"description": "Quantum measurement in the computational basis. Create new measurement instruction. ## Attributes ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit.circuit.classicalfunction.ClassicalFunctionCompilerTypeError",
			"name": "qiskit.circuit.classicalfunction.ClassicalFunctionCompilerTypeError",
			"type": "exception",
			"description": "ClassicalFunction compiler type error. The classicalfunction function fails at type checking time. Set the error message."
		},
		{
			"id": "qiskit.providers.models.UchannelLO",
			"name": "qiskit.providers.models.UchannelLO",
			"type": "class",
			"description": "Class representing a U Channel LO ### q Qubit that scale corresponds too. ### scale Scale factor for qubit frequency. Initialize a UchannelLOSchema object **Parameters** * **q** (*int*\")) – Qubit that scale corresponds too. Must be >= 0. * **scale** (*complex*\")) – Scale factor for qubit frequency."
		},
		{
			"id": "qiskit.pulse.instructions.SetFrequency",
			"name": "qiskit.pulse.instructions.SetFrequency",
			"type": "class",
			"description": "Set the channel frequency. This instruction operates on PulseChannel s. A PulseChannel creates pulses of the form Here, is the frequency of the channel. The instruction SetFrequency allows the user to set the value of ."
		},
		{
			"id": "qiskit.pulse.library.GaussianSquare",
			"name": "qiskit.pulse.library.GaussianSquare",
			"type": "class",
			"description": "A square pulse with a Gaussian shaped risefall on both sides lifted such that its first sample is zero. Exactly one of the risefall_sigma_ratio and width parameters has to be specified."
		},
		{
			"id": "qiskit.pulse.transforms.AlignRight",
			"name": "qiskit.pulse.transforms.AlignRight",
			"type": "class",
			"description": "Align instructions in as-late-as-possible manner. Instructions are placed at latest available timeslots. Create new right-justified context. ## Attributes ### is\\_sequential ## Methods ### align Reallocate instructions according to the policy. Only top-level sub-schedules are aligned."
		},
		{
			"id": "qiskit.assembler",
			"name": "qiskit.assembler",
			"type": "module",
			"description": "Assembles a list of circuits into a qobj that can be run on the backend."
		},
		{
			"id": "qiskit.qobj.PulseLibraryItem",
			"name": "qiskit.qobj.PulseLibraryItem",
			"type": "class",
			"description": "An item in a pulse library. Instantiate a pulse library item. **Parameters** * **name** (*str*\")) – A name for the pulse. * **samples** (*list*\")*\\*[*complex*\")*]*) – A list of complex values defining pulse shape. ## Methods ### from\\_dict Create a new PulseLibraryItem object from a dictionary."
		},
		{
			"id": "qiskit.providers.models.BackendConfiguration",
			"name": "qiskit.providers.models.BackendConfiguration",
			"type": "class",
			"description": "Backwards compat shim representing an abstract backend configuration."
		},
		{
			"id": "qiskit.pulse.library.GaussianSquareDrag",
			"name": "qiskit.pulse.library.GaussianSquareDrag",
			"type": "function",
			"description": "A square pulse with a Drag shaped rise and fall This pulse shape is similar to GaussianSquare but uses Drag for its rise and fall instead of Gaussian."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.DefaultSynthesisLinearFunction",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.DefaultSynthesisLinearFunction",
			"type": "class",
			"description": "The default linear function synthesis plugin. This plugin name is :linear_function.default which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. ## Methods ### run Run synthesis for the given LinearFunction."
		},
		{
			"id": "qiskit.qobj.QasmExperimentCalibrations",
			"name": "qiskit.qobj.QasmExperimentCalibrations",
			"type": "class",
			"description": "A container for any calibrations data. The gates attribute contains a list of GateCalibrations. Initialize a container for calibrations. **Parameters** **gates** (*list*\")*(**GateCalibration**)*) – ## Methods ### from\\_dict Create a new GateCalibration object from a dictionary."
		},
		{
			"id": "qiskit.circuit.library.Reset",
			"name": "qiskit.circuit.library.Reset",
			"type": "class",
			"description": "Qubit reset. Create new reset instruction. ## Attributes ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit.transpiler.passes.LightCone",
			"name": "qiskit.transpiler.passes.LightCone",
			"type": "class",
			"description": "Remove the gates that do not affect the outcome of a measurement on a circuit. Pass for computing the light-cone of an observable or measurement. The Pass can handle either an observable one would like to measure or a measurement on a set of qubits."
		},
		{
			"id": "qiskit.primitives.Shaped",
			"name": "qiskit.primitives.Shaped",
			"type": "class",
			"description": "Protocol that defines what it means to be a shaped object. Note that static type checkers will classify numpy.ndarray as being Shaped. Moreover, since this protocol is runtime-checkable, we will even have isinstance(, Shaped) == True."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.QFTSynthesisFull",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.QFTSynthesisFull",
			"type": "class",
			"description": "Synthesis plugin for QFT gates using all-to-all connectivity. This plugin name is :qft.full which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. Note that the plugin mechanism is not applied if the gate is called qft but is not an instance of QFTGate."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.high_level_synthesis.QFTSynthesisLine",
			"name": "qiskit.transpiler.passes.synthesis.high_level_synthesis.QFTSynthesisLine",
			"type": "class",
			"description": "Synthesis plugin for QFT gates using linear connectivity. This plugin name is :qft.line which can be used as the key on an HLSConfig object to use this method with HighLevelSynthesis. Note that the plugin mechanism is not applied if the gate is called qft but is not an instance of QFTGate."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.clifford_unitary_synth_plugin.CliffordUnitarySynthesis",
			"name": "qiskit.transpiler.passes.synthesis.clifford_unitary_synth_plugin.CliffordUnitarySynthesis",
			"type": "class",
			"description": "A Clifford unitary synthesis plugin. The plugin is invoked by the UnitarySynthesis transpiler pass when the parameter method is set to \"clifford\"."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeVigo",
			"name": "qiskit.providers.fake_provider.FakeVigo",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.gradients.DerivativeBase",
			"name": "qiskit.opflow.gradients.DerivativeBase",
			"type": "class",
			"description": "Deprecated: Base class for differentiating opflow objects. Converter for differentiating opflow objects and handling things like properly differentiating combo\\_fn’s and enforcing product rules when operator coefficients are parameterized."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeQuito",
			"name": "qiskit.providers.fake_provider.FakeQuito",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.AmplitudeAmplifier",
			"name": "qiskit.algorithms.AmplitudeAmplifier",
			"type": "class",
			"description": "The interface for amplification algorithms. ## Methods ### amplify Run the amplification algorithm. **Parameters** **amplification\\_problem** (*AmplificationProblem*) – The amplification problem. **Returns** The result as a AmplificationResult, where e.g."
		},
		{
			"id": "qiskit.algorithms.gradients.QFI",
			"name": "qiskit.algorithms.gradients.QFI",
			"type": "class",
			"description": "Computes the Quantum Fisher Information (QFI) given a pure, parameterized quantum state. QFI is defined as: **Parameters** * **qgt** (*BaseQGT*) – The quantum geometric tensor used to compute the QFI. * **options** (*Options* *| None*) – Backend runtime options used for circuit execution."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeRueschlikon",
			"name": "qiskit.providers.fake_provider.FakeRueschlikon",
			"type": "class",
			"description": "A fake 16 qubit backend. ``text 1 → 2 → 3 → 4 ← 5 ← 6 → 7 ← 8 ↓ ↑ ↓ ↓ ↑ ↓ ↓ ↑ 0 ← 15 → 14 ← 13 ← 12 → 11 → 10 ← 9 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used."
		},
		{
			"id": "qiskit.algorithms.optimizers.QNSPSA",
			"name": "qiskit.algorithms.optimizers.QNSPSA",
			"type": "class",
			"description": "The Quantum Natural SPSA (QN-SPSA) optimizer. The QN-SPSA optimizer \\[1] is a stochastic optimizer that belongs to the family of gradient descent methods."
		},
		{
			"id": "qiskit.opflow.converters",
			"name": "qiskit.opflow.converters",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.opflow.state_fns.DictStateFn",
			"name": "qiskit.opflow.state_fns.DictStateFn",
			"type": "class",
			"description": "Deprecated: A class for state functions and measurements which are defined by a lookup table, stored in a dict. The class qiskit.opflow.state_fns.dict_state_fn.DictStateFn is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.algorithms.gradients.SPSASamplerGradient",
			"name": "qiskit.algorithms.gradients.SPSASamplerGradient",
			"type": "class",
			"description": "Compute the gradients of the sampling probability by the Simultaneous Perturbation Stochastic Approximation (SPSA) \\[1]. **Reference:** \\[1] J. C. Spall, Adaptive stochastic approximation by the simultaneous perturbation method in IEEE Transactions on Automatic Control, vol. 45, no. 10, pp."
		},
		{
			"id": "qiskit.algorithms.eigensolvers.NumPyEigensolverResult",
			"name": "qiskit.algorithms.eigensolvers.NumPyEigensolverResult",
			"type": "class",
			"description": "NumPy eigensolver result. ## Attributes ### aux\\_operators\\_evaluated Return the aux operator expectation values. These values are in fact tuples formatted as (mean, metadata). ### eigenstates Return eigenstates. ### eigenvalues Return the eigenvalues."
		},
		{
			"id": "qiskit.algorithms.eigensolvers.EigensolverResult",
			"name": "qiskit.algorithms.eigensolvers.EigensolverResult",
			"type": "class",
			"description": "Eigensolver result. ## Attributes ### aux\\_operators\\_evaluated Return the aux operator expectation values. These values are in fact tuples formatted as (mean, metadata). ### eigenvalues Return the eigenvalues. ## Methods ### combine Any property from the argument that exists in the receiver is updated."
		},
		{
			"id": "qiskit.algorithms.optimizers.Minimizer",
			"name": "qiskit.algorithms.optimizers.Minimizer",
			"type": "class",
			"description": "Callable Protocol for minimizer. This interface is based on SciPy’s optimize module. > This protocol defines a callable taking the following parameters: > > > **fun** > > > > The objective function to minimize (for example the energy in the case of the VQE)."
		},
		{
			"id": "qiskit.opflow.primitive_ops",
			"name": "qiskit.opflow.primitive_ops",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.algorithms.IterativeAmplitudeEstimationResult",
			"name": "qiskit.algorithms.IterativeAmplitudeEstimationResult",
			"type": "class",
			"description": "The IterativeAmplitudeEstimation result object. ## Attributes ### alpha Return the confidence level . ### circuit\\_results Return the circuit results. Can be a statevector or counts dictionary. ### confidence\\_interval Return the confidence interval for the amplitude (95% interval by default)."
		},
		{
			"id": "qiskit.opflow.evolutions.EvolutionBase",
			"name": "qiskit.opflow.evolutions.EvolutionBase",
			"type": "class",
			"description": "Deprecated: A base for Evolution converters. Evolutions are converters which traverse an Operator tree, replacing any EvolvedOp e with a Schrodinger equation-style evolution CircuitOp equalling or approximating the matrix exponential of -i \\* the Operator contained inside (e.primitive)."
		},
		{
			"id": "qiskit.opflow.converters.ConverterBase",
			"name": "qiskit.opflow.converters.ConverterBase",
			"type": "class",
			"description": "Deprecated: Converters take an Operator and return a new Operator, generally isomorphic in some way with the first, but with certain desired properties. For example, a converter may accept CircuitOp and return a SummedOp of PauliOps representing the circuit unitary."
		},
		{
			"id": "qiskit.algorithms.gradients.FiniteDiffEstimatorGradient",
			"name": "qiskit.algorithms.gradients.FiniteDiffEstimatorGradient",
			"type": "class",
			"description": "Compute the gradients of the expectation values by finite difference method \\[1]. **Reference:** \\[1] Finite difference method **Parameters** * **estimator** (*BaseEstimator*) – The estimator used to compute the gradients."
		},
		{
			"id": "qiskit.algorithms.SciPyImaginaryEvolver",
			"name": "qiskit.algorithms.SciPyImaginaryEvolver",
			"type": "class",
			"description": "Classical Evolver for imaginary time evolution. Evolves an initial state for an imaginary time under a Hamiltonian , as provided in the evolution_problem. Note that the precision of the evolver does not depend on the number of timesteps taken."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBelem",
			"name": "qiskit.providers.fake_provider.FakeBelem",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeLagosV2",
			"name": "qiskit.providers.fake_provider.FakeLagosV2",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMumbaiV2",
			"name": "qiskit.providers.fake_provider.FakeMumbaiV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.GroverResult",
			"name": "qiskit.algorithms.GroverResult",
			"type": "class",
			"description": "Grover Result. ## Attributes ### assignment The post-processed value of the most likely bitstring. **Returns** The output of the post_processing function of the respective AmplificationProblem, where the input is the top_measurement."
		},
		{
			"id": "qiskit.algorithms.TimeEvolutionProblem",
			"name": "qiskit.algorithms.TimeEvolutionProblem",
			"type": "class",
			"description": "Time evolution problem class. This class is the input to time evolution algorithms and must contain information on the total evolution time, a quantum state to be evolved and under which Hamiltonian the state is evolved. ### hamiltonian The Hamiltonian under which to evolve the system."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBoeblingenV2",
			"name": "qiskit.providers.fake_provider.FakeBoeblingenV2",
			"type": "class",
			"description": "A fake Boeblingen V2 backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.visualization.circuit.qcstyle.DefaultStyle",
			"name": "qiskit.visualization.circuit.qcstyle.DefaultStyle",
			"type": "class",
			"description": "Creates a Default Style dictionary **Style Dict Details** The style dict contains numerous options that define the style of the output circuit visualization. The style dict is used by the mpl or latex output."
		},
		{
			"id": "qiskit.algorithms.eigensolvers.NumPyEigensolver",
			"name": "qiskit.algorithms.eigensolvers.NumPyEigensolver",
			"type": "class",
			"description": "The NumPy eigensolver algorithm. The NumPy Eigensolver computes up to the first eigenvalues of a complex-valued square matrix of dimension , with ."
		},
		{
			"id": "qiskit.algorithms.optimizers.TNC",
			"name": "qiskit.algorithms.optimizers.TNC",
			"type": "class",
			"description": "Truncated Newton (TNC) optimizer. TNC uses a truncated Newton algorithm to minimize a function with variables subject to bounds. This algorithm uses gradient information; it is also called Newton Conjugate-Gradient."
		},
		{
			"id": "qiskit.algorithms.VQD",
			"name": "qiskit.algorithms.VQD",
			"type": "class",
			"description": "Deprecated: Variational Quantum Deflation algorithm. The VQD class has been superseded by the qiskit.algorithms.eigensolvers.VQD class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.opflow.primitive_ops.TaperedPauliSumOp",
			"name": "qiskit.opflow.primitive_ops.TaperedPauliSumOp",
			"type": "class",
			"description": "Deprecated: Class for PauliSumOp after tapering The class qiskit.opflow.primitive_ops.tapered_pauli_sum_op.TaperedPauliSumOp is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational.RealVariationalPrinciple",
			"name": "qiskit.algorithms.time_evolvers.variational.RealVariationalPrinciple",
			"type": "class",
			"description": "Class for a Real Variational Principle. The real variant means that we consider real time dynamics. **Parameters** * **qgt** (*BaseQGT*) – Instance of a class used to compute the GQT. * **gradient** (*BaseEstimatorGradient*) – Instance of a class used to compute the state gradient."
		},
		{
			"id": "qiskit.algorithms.optimizers.DIRECT_L_RAND",
			"name": "qiskit.algorithms.optimizers.DIRECT_L_RAND",
			"type": "class",
			"description": "DIviding RECTangles Locally-biased Randomized optimizer. DIRECT-L RAND is the “locally biased” variant with some randomization in near-tie decisions. See also DIRECT_L NLopt global optimizer, derivative-free."
		},
		{
			"id": "qiskit.algorithms.ImaginaryEvolver",
			"name": "qiskit.algorithms.ImaginaryEvolver",
			"type": "class",
			"description": "Deprecated: Interface for Quantum Imaginary Time Evolution. The ImaginaryEvolver interface has been superseded by the qiskit.algorithms.time_evolvers.ImaginaryTimeEvolver interface. This interface will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.opflow.OperatorBase",
			"name": "qiskit.opflow.OperatorBase",
			"type": "class",
			"description": "Deprecated: A base class for all Operators: PrimitiveOps, StateFns, ListOps, etc. Operators are defined as functions which take one complex binary function to another."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.MinimumEigensolverResult",
			"name": "qiskit.algorithms.minimum_eigensolvers.MinimumEigensolverResult",
			"type": "class",
			"description": "Minimum eigensolver result. ## Attributes ### aux\\_operators\\_evaluated The aux operator expectation values. These values are in fact tuples formatted as (mean, (variance, shots)). ### eigenvalue The computed minimum eigenvalue."
		},
		{
			"id": "qiskit.algorithms.AmplitudeEstimatorResult",
			"name": "qiskit.algorithms.AmplitudeEstimatorResult",
			"type": "class",
			"description": "The results object for amplitude estimation algorithms. ## Attributes ### circuit\\_results Return the circuit results. Can be a statevector or counts dictionary. ### confidence\\_interval Return the confidence interval for the amplitude (95% interval by default)."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBackendV2",
			"name": "qiskit.providers.fake_provider.FakeBackendV2",
			"type": "class",
			"description": "A mock backend that doesn’t implement run() to test compatibility with Terra internals. The class qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0. Use the qiskit.providers.basic\\_provider.GenericBackendV2 class instead."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeAuckland",
			"name": "qiskit.providers.fake_provider.FakeAuckland",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow",
			"name": "qiskit.opflow",
			"type": "module",
			"description": "Deprecated: Compute commutator of op\\_a and op\\_b. The function qiskit.opflow.utils.commutator() is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.algorithms.optimizers.OptimizerState",
			"name": "qiskit.algorithms.optimizers.OptimizerState",
			"type": "class",
			"description": "Base class representing the state of the optimizer. This class stores the current state of the optimizer, given by the current point and (optionally) information like the function value, the gradient or the number of function evaluations."
		},
		{
			"id": "qiskit.opflow.converters.TwoQubitReduction",
			"name": "qiskit.opflow.converters.TwoQubitReduction",
			"type": "class",
			"description": "Deprecated: Two qubit reduction converter which eliminates the central and last qubit in a list of Pauli that has diagonal operators (Z,I) at those positions."
		},
		{
			"id": "qiskit.providers.fake_provider.FakePoughkeepsieV2",
			"name": "qiskit.providers.fake_provider.FakePoughkeepsieV2",
			"type": "class",
			"description": "A fake Poughkeepsie backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.pulse.library.ParametricPulse",
			"name": "qiskit.pulse.library.ParametricPulse",
			"type": "class",
			"description": "The abstract superclass for parametric pulses. This class was superseded by SymbolicPulse and is deprecated. It will be removed in Qiskit 1.0 because of the poor flexibility for defining a new waveform type and serializing it through the qiskit.qpy framework."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational.ImaginaryVariationalPrinciple",
			"name": "qiskit.algorithms.time_evolvers.variational.ImaginaryVariationalPrinciple",
			"type": "class",
			"description": "Abstract class for an Imaginary Variational Principle. The imaginary variant means that we consider imaginary time dynamics. **Parameters** * **qgt** (*BaseQGT*) – Instance of a class used to compute the GQT."
		},
		{
			"id": "qiskit.opflow.state_fns.OperatorStateFn",
			"name": "qiskit.opflow.state_fns.OperatorStateFn",
			"type": "class",
			"description": "Deprecated: A class for state functions and measurements which are defined by a density Operator, stored using an OperatorBase. The class qiskit.opflow.state_fns.operator_state_fn.OperatorStateFn is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.algorithms.AmplitudeEstimation",
			"name": "qiskit.algorithms.AmplitudeEstimation",
			"type": "class",
			"description": "The Quantum Phase Estimation-based Amplitude Estimation algorithm. This class implements the original Quantum Amplitude Estimation (QAE) algorithm, introduced by \\[1]."
		},
		{
			"id": "qiskit.algorithms.optimizers.BOBYQA",
			"name": "qiskit.algorithms.optimizers.BOBYQA",
			"type": "class",
			"description": "Bound Optimization BY Quadratic Approximation algorithm. BOBYQA finds local solutions to nonlinear, non-convex minimization problems with optional bound constraints, without requirement of derivatives of the objective function. Uses skquant.opt installed with pip install scikit-quant."
		},
		{
			"id": "qiskit.opflow.list_ops.SummedOp",
			"name": "qiskit.opflow.list_ops.SummedOp",
			"type": "class",
			"description": "Deprecated: A class for lazily representing sums of Operators. Often Operators cannot be efficiently added to one another, but may be manipulated further so that they can be later."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational.RealMcLachlanPrinciple",
			"name": "qiskit.algorithms.time_evolvers.variational.RealMcLachlanPrinciple",
			"type": "class",
			"description": "Class for a Real McLachlan’s Variational Principle. It aims to minimize the distance between both sides of the Schrödinger equation with a quantum state given as a parametrized trial state. The principle leads to a system of linear equations handled by a linear solver."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeProviderForBackendV2",
			"name": "qiskit.providers.fake_provider.FakeProviderForBackendV2",
			"type": "class",
			"description": "Fake provider containing fake V2 backends. Only filtering backends by name is implemented. This class contains all fake V2 backends available in the qiskit.providers.fake_provider. The class qiskit.providers.fake_provider.fake_provider.FakeProviderForBackendV2 is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.opflow.list_ops.ListOp",
			"name": "qiskit.opflow.list_ops.ListOp",
			"type": "class",
			"description": "Deprecated: A Class for manipulating List Operators, and parent class to SummedOp, ComposedOp and TensoredOp."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeRochesterV2",
			"name": "qiskit.providers.fake_provider.FakeRochesterV2",
			"type": "class",
			"description": "A fake Rochester backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.optimizers.L_BFGS_B",
			"name": "qiskit.algorithms.optimizers.L_BFGS_B",
			"type": "class",
			"description": "Limited-memory BFGS Bound optimizer. The target goal of Limited-memory Broyden-Fletcher-Goldfarb-Shanno Bound (L-BFGS-B) is to minimize the value of a differentiable scalar function ."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational.VariationalPrinciple",
			"name": "qiskit.algorithms.time_evolvers.variational.VariationalPrinciple",
			"type": "class",
			"description": "A Variational Principle class. It determines the time propagation of parameters in a quantum state provided as a parametrized quantum circuit (ansatz). ### qgt Instance of a class used to compute the GQT. **Type** BaseQGT ### gradient Instance of a class used to compute the state gradient."
		},
		{
			"id": "qiskit.providers.basicaer.BasicAerProvider",
			"name": "qiskit.providers.basicaer.BasicAerProvider",
			"type": "class",
			"description": "Provider for Basic Aer backends. The class qiskit.providers.basicaer.basicaerprovider.BasicAerProvider is deprecated as of qiskit 0.46.0. It will be removed in Qiskit 1.0.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeValenciaV2",
			"name": "qiskit.providers.fake_provider.FakeValenciaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.Eigensolver",
			"name": "qiskit.algorithms.Eigensolver",
			"type": "class",
			"description": "Deprecated: Eigensolver Interface. The Eigensolver interface has been superseded by the qiskit.algorithms.eigensolvers.Eigensolver interface. This interface will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBurlington",
			"name": "qiskit.providers.fake_provider.FakeBurlington",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.trotterization",
			"name": "qiskit.algorithms.time_evolvers.trotterization",
			"type": "module",
			"description": "This package contains Trotterization-based Quantum Real Time Evolution algorithm. It is compliant with the new Quantum Time Evolution Framework and makes use of qiskit.synthesis.evolution.ProductFormula and PauliEvolutionGate implementations."
		},
		{
			"id": "qiskit.opflow.gradients.CircuitGradient",
			"name": "qiskit.opflow.gradients.CircuitGradient",
			"type": "class",
			"description": "Deprecated: Circuit to gradient operator converter. Converter for changing parameterized circuits into operators whose evaluation yields the gradient with respect to the circuit parameters."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeCambridge",
			"name": "qiskit.providers.fake_provider.FakeCambridge",
			"type": "class",
			"description": "A fake Cambridge backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 06 ↕ ↕ 07 ↔ 08 ↔ 09 ↔ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↔ 15 ↕ ↕ ↕ 16 17 18 ↕ ↕ ↕ 19 ↔ 20 ↔ 21 ↔ 22 ↔ 23 ↔ 24 ↔ 25 ↔ 26 ↔ 27 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.evolutions.Trotter",
			"name": "qiskit.opflow.evolutions.Trotter",
			"type": "class",
			"description": "Deprecated: Simple Trotter expansion, composing the evolution circuits of each Operator in the sum together reps times and dividing the evolution time of each by reps. The class qiskit.opflow.evolutions.trotterizations.trotter.Trotter is deprecated as of qiskit-terra 0.24.0."
		},
		{
			"id": "qiskit.algorithms.AmplitudeEstimator",
			"name": "qiskit.algorithms.AmplitudeEstimator",
			"type": "class",
			"description": "The Amplitude Estimation interface. ## Methods ### estimate Run the amplitude estimation algorithm. **Parameters** **estimation\\_problem** (*EstimationProblem*) – An EstimationProblem containing all problem-relevant information such as the state preparation and the objective qubits."
		},
		{
			"id": "qiskit.algorithms.gradients",
			"name": "qiskit.algorithms.gradients",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.providers.basicaer",
			"name": "qiskit.providers.basicaer",
			"type": "module",
			"description": "qiskit.providers.basicaer The qiskit.providers.basicaer module is deprecated as of Qiskit 0.46 and will be removed in Qiskit 1.0. Its functionality has been replaced by the new qiskit.providers.basic_provider module and the qiskit.quantum_info module. A module of Python-based quantum simulators."
		},
		{
			"id": "qiskit.algorithms.optimizers.NFT",
			"name": "qiskit.algorithms.optimizers.NFT",
			"type": "class",
			"description": "Nakanishi-Fujii-Todo algorithm. See https://arxiv.org/abs/1903.12166 Built out using scipy framework, for details, please refer to https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html."
		},
		{
			"id": "qiskit.algorithms.state_fidelities.StateFidelityResult",
			"name": "qiskit.algorithms.state_fidelities.StateFidelityResult",
			"type": "class",
			"description": "This class stores the result of StateFidelity computations. ## Attributes ### fidelities List of truncated fidelity values for each pair of input circuits, ensured to be in \\[0,1]."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeKolkata",
			"name": "qiskit.providers.fake_provider.FakeKolkata",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.evolutions.QDrift",
			"name": "qiskit.opflow.evolutions.QDrift",
			"type": "class",
			"description": "Deprecated: The QDrift Trotterization method, which selects each each term in the Trotterization randomly, with a probability proportional to its weight. Based on the work of Earl Campbell in https://arxiv.org/abs/1811.08017."
		},
		{
			"id": "qiskit.opflow.gradients.Gradient",
			"name": "qiskit.opflow.gradients.Gradient",
			"type": "class",
			"description": "Deprecated: Convert an operator expression to the first-order gradient. The class qiskit.opflow.gradients.gradient.Gradient is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.passmanager.FlowController",
			"name": "qiskit.passmanager.FlowController",
			"type": "class",
			"description": "A legacy factory for other flow controllers. This class is primarily for compatibility with legacy versions of Qiskit, and in general, you should prefer simply instantiating the controller you want, and adding it to the relevant PassManager or other controller. Its use is deprecated."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeLimaV2",
			"name": "qiskit.providers.fake_provider.FakeLimaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMelbourne",
			"name": "qiskit.providers.fake_provider.FakeMelbourne",
			"type": "class",
			"description": "A fake 14 qubit backend. ``text 0 ← 1 → 2 → 3 ← 4 ← 5 → 6 ↑ ↑ ↑ ↓ ↓ ↓ 13 → 12 ← 11 → 10 ← 9 → 8 ← 7 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used. These are used to control the run()` method."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeLima",
			"name": "qiskit.providers.fake_provider.FakeLima",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.optimizers.GSLS",
			"name": "qiskit.algorithms.optimizers.GSLS",
			"type": "class",
			"description": "Gaussian-smoothed Line Search. An implementation of the line search algorithm described in https://arxiv.org/pdf/1905.01332.pdf, using gradient approximation based on Gaussian-smoothed samples on a sphere. This component has some function that is normally random."
		},
		{
			"id": "qiskit.providers.basicaer.BasicAerError",
			"name": "qiskit.providers.basicaer.BasicAerError",
			"type": "exception",
			"description": "Base class for errors raised by Basic Aer. Set the error message. The class qiskit.providers.basicaer.exceptions.BasicAerError is deprecated as of qiskit 0.46.0. It will be removed in Qiskit 1.0.0. The qiskit.providers.basicaer module has been superseded by qiskit.providers.basic\\_provider."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeHanoiV2",
			"name": "qiskit.providers.fake_provider.FakeHanoiV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.eigensolvers",
			"name": "qiskit.algorithms.eigensolvers",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.algorithms.gradients.EstimatorGradientResult",
			"name": "qiskit.algorithms.gradients.EstimatorGradientResult",
			"type": "class",
			"description": "Result of EstimatorGradient. ## Attributes ### gradients The gradients of the expectation values. ### metadata Additional information about the job. ### options Primitive runtime options for the execution of the job."
		},
		{
			"id": "qiskit.algorithms.optimizers.GradientDescent",
			"name": "qiskit.algorithms.optimizers.GradientDescent",
			"type": "class",
			"description": "The gradient descent minimization routine. For a function and an initial point , the standard (or “vanilla”) gradient descent method is an iterative scheme to find the minimum of by updating the parameters in the direction of the negative gradient of for a small learning rate ."
		},
		{
			"id": "qiskit.algorithms.PVQDResult",
			"name": "qiskit.algorithms.PVQDResult",
			"type": "class",
			"description": "The result object for the p-VQD algorithm. **Parameters** * **evolved\\_state** (*QuantumCircuit*) – An evolved quantum state."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMumbai",
			"name": "qiskit.providers.fake_provider.FakeMumbai",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeValencia",
			"name": "qiskit.providers.fake_provider.FakeValencia",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.expectations.CVaRExpectation",
			"name": "qiskit.opflow.expectations.CVaRExpectation",
			"type": "class",
			"description": "Deprecated: Compute the Conditional Value at Risk (CVaR) expectation value. The standard approach to calculating the expectation value of a Hamiltonian w\\.r.t. a state is to take the sample mean of the measurement outcomes. This corresponds to an estimator of the energy."
		},
		{
			"id": "qiskit.opflow.state_fns.StateFn",
			"name": "qiskit.opflow.state_fns.StateFn",
			"type": "class",
			"description": "Deprecated: A class for representing state functions and measurements."
		},
		{
			"id": "qiskit.opflow.expectations.AerPauliExpectation",
			"name": "qiskit.opflow.expectations.AerPauliExpectation",
			"type": "class",
			"description": "An Expectation converter for using Aer’s operator snapshot to take expectations of quantum state circuits over Pauli observables. The class qiskit.opflow.expectations.aer_pauli_expectation.AerPauliExpectation is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeRome",
			"name": "qiskit.providers.fake_provider.FakeRome",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.HamiltonianPhaseEstimationResult",
			"name": "qiskit.algorithms.HamiltonianPhaseEstimationResult",
			"type": "class",
			"description": "Store and manipulate results from running HamiltonianPhaseEstimation. This API of this class is nearly the same as PhaseEstimatorResult, differing only in the presence of an additional keyword argument in the methods."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeAlmaden",
			"name": "qiskit.providers.fake_provider.FakeAlmaden",
			"type": "class",
			"description": "A fake Almaden backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.AdaptVQE",
			"name": "qiskit.algorithms.minimum_eigensolvers.AdaptVQE",
			"type": "class",
			"description": "The Adaptive Variational Quantum Eigensolver algorithm. AdaptVQE is a quantum algorithm which creates a compact ansatz from a set of evolution operators. It iteratively extends the ansatz circuit, by selecting the building block that leads to the largest gradient from a set of candidates."
		},
		{
			"id": "qiskit.opflow.state_fns.SparseVectorStateFn",
			"name": "qiskit.opflow.state_fns.SparseVectorStateFn",
			"type": "class",
			"description": "Deprecated: A class for sparse state functions and measurements in vector representation. This class uses scipy.sparse.spmatrix for the internal representation. The class qiskit.opflow.state_fns.sparse_vector_state_fn.SparseVectorStateFn is deprecated as of qiskit 0.24.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeYorktown",
			"name": "qiskit.providers.fake_provider.FakeYorktown",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 1 / | 0 - 2 - 3 | / 4 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.evolutions.PauliTrotterEvolution",
			"name": "qiskit.opflow.evolutions.PauliTrotterEvolution",
			"type": "class",
			"description": "Deprecated: An Evolution algorithm replacing exponentiated sums of Paulis by changing them each to the Z basis, rotating with an rZ, changing back, and Trotterizing."
		},
		{
			"id": "qiskit.opflow.expectations.PauliExpectation",
			"name": "qiskit.opflow.expectations.PauliExpectation",
			"type": "class",
			"description": "An Expectation converter for Pauli-basis observables by changing Pauli measurements to a diagonal (\\{Z, I}^n) basis and appending circuit post-rotations to the measured state function."
		},
		{
			"id": "qiskit.opflow.evolutions",
			"name": "qiskit.opflow.evolutions",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.providers.fake_provider.FakeArmonk",
			"name": "qiskit.providers.fake_provider.FakeArmonk",
			"type": "class",
			"description": "A fake 1 qubit backend. ``text 0 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeParis",
			"name": "qiskit.providers.fake_provider.FakeParis",
			"type": "class",
			"description": "A fake Paris backend. ``text 06 17 ↕ ↕ 00 ↔ 01 ↔ 04 ↔ 07 ↔ 10 ↔ 12 ↔ 15 ↔ 18 ↔ 20 ↔ 23 ↕ ↕ ↕ 02 13 24 ↕ ↕ ↕ 03 ↔ 05 ↔ 08 ↔ 11 ↔ 14 ↔ 16 ↔ 19 ↔ 22 ↔ 25 ↔ 26 ↕ ↕ 09 20 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeLondonV2",
			"name": "qiskit.providers.fake_provider.FakeLondonV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.primitive_ops.PauliSumOp",
			"name": "qiskit.opflow.primitive_ops.PauliSumOp",
			"type": "class",
			"description": "Deprecated: Class for Operators backed by Terra’s SparsePauliOp class. The class qiskit.opflow.primitive_ops.pauli_sum_op.PauliSumOp is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver",
			"name": "qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver",
			"type": "class",
			"description": "The NumPy minimum eigensolver algorithm. **Parameters** **filter\\_criterion** (*FilterType | None*) – Callable that allows to filter eigenvalues/eigenstates. The minimum eigensolver is only searching over feasible states and returns an eigenstate that has the smallest eigenvalue among feasible states."
		},
		{
			"id": "qiskit.algorithms.eigensolvers.Eigensolver",
			"name": "qiskit.algorithms.eigensolvers.Eigensolver",
			"type": "class",
			"description": "The eigensolver interface. Algorithms that can compute eigenvalues for an operator may implement this interface to allow different algorithms to be used interchangeably. ## Methods ### compute\\_eigenvalues Computes the minimum eigenvalue. The operator and aux_operators are supplied here."
		},
		{
			"id": "qiskit.algorithms.gradients.QGTResult",
			"name": "qiskit.algorithms.gradients.QGTResult",
			"type": "class",
			"description": "Result of QGT. ## Attributes ### qgts The QGT. ### derivative\\_type The type of derivative. ### metadata Additional information about the job. ### options Primitive runtime options for the execution of the job."
		},
		{
			"id": "qiskit.transpiler.passes.CrosstalkAdaptiveSchedule",
			"name": "qiskit.transpiler.passes.CrosstalkAdaptiveSchedule",
			"type": "class",
			"description": "Crosstalk mitigation through adaptive instruction scheduling. CrosstalkAdaptiveSchedule initializer. The class qiskit.transpiler.passes.optimization.crosstalk_adaptive_schedule.CrosstalkAdaptiveSchedule is deprecated as of qiskit 0.46. It will be removed in the 1.0.0 release."
		},
		{
			"id": "qiskit.algorithms.VQDResult",
			"name": "qiskit.algorithms.VQDResult",
			"type": "class",
			"description": "Deprecated: VQD Result. The VQDResult class has been superseded by the qiskit.algorithms.eigensolvers.VQDResult class. This class will be deprecated in a future release and subsequently removed after that. The class qiskit.algorithms.eigen_solvers.vqd.VQDResult is deprecated as of qiskit-terra 0.24.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeAthens",
			"name": "qiskit.providers.fake_provider.FakeAthens",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeProvider",
			"name": "qiskit.providers.fake_provider.FakeProvider",
			"type": "class",
			"description": "Fake provider containing fake V1 backends. Only filtering backends by name is implemented. This class contains all fake V1 backends available in the qiskit.providers.fake_provider. The class qiskit.providers.fake_provider.fake_provider.FakeProvider is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMontrealV2",
			"name": "qiskit.providers.fake_provider.FakeMontrealV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.optimizers.SLSQP",
			"name": "qiskit.algorithms.optimizers.SLSQP",
			"type": "class",
			"description": "Sequential Least SQuares Programming optimizer. SLSQP minimizes a function of several variables with any combination of bounds, equality and inequality constraints. The method wraps the SLSQP Optimization subroutine originally implemented by Dieter Kraft."
		},
		{
			"id": "qiskit.algorithms.PhaseEstimationScale",
			"name": "qiskit.algorithms.PhaseEstimationScale",
			"type": "class",
			"description": "Set and use a bound on eigenvalues of a Hermitian operator in order to ensure phases are in the desired range and to convert measured phases into eigenvectors. The bound is set when constructing this class. Then the method scale is used to find the factor by which to scale the operator."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational.ForwardEulerSolver",
			"name": "qiskit.algorithms.time_evolvers.variational.ForwardEulerSolver",
			"type": "class",
			"description": "Forward Euler ODE solver. Forward Euler ODE solver that implements an interface from SciPy. **Parameters** * **function** (*Callable*\")) – Right-hand side of the system. The calling signature is fun(t, y)."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeTorontoV2",
			"name": "qiskit.providers.fake_provider.FakeTorontoV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.primitive_ops.Z2Symmetries",
			"name": "qiskit.opflow.primitive_ops.Z2Symmetries",
			"type": "class",
			"description": "Deprecated: Z2 Symmetries The class qiskit.opflow.primitive_ops.tapered_pauli_sum_op.Z2Symmetries is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeRochester",
			"name": "qiskit.providers.fake_provider.FakeRochester",
			"type": "class",
			"description": "A fake Rochester backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.gradients.QFIBase",
			"name": "qiskit.opflow.gradients.QFIBase",
			"type": "class",
			"description": "Deprecated: Base class for Quantum Fisher Information (QFI). Compute the Quantum Fisher Information (QFI) given a pure, parameterized quantum state. The QFI is: > \\[QFI]kl= Re\\[〈∂kψ|∂lψ〉−〈∂kψ|ψ〉〈ψ|∂lψ〉] \\* 4. The class qiskit.opflow.gradients.qfi_base.QFIBase is deprecated as of qiskit-terra 0.24.0."
		},
		{
			"id": "qiskit.pulse.instructions.Call",
			"name": "qiskit.pulse.instructions.Call",
			"type": "class",
			"description": "Pulse Call instruction. The Call instruction represents the calling of a referenced subroutine (schedule). It enables code reuse both within the pulse representation and hardware (if supported). Define new subroutine. Inline subroutine is mutable. This requires special care for modification."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeJohannesburg",
			"name": "qiskit.providers.fake_provider.FakeJohannesburg",
			"type": "class",
			"description": "A fake Johannesburg backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.optimizers.AQGD",
			"name": "qiskit.algorithms.optimizers.AQGD",
			"type": "class",
			"description": "Analytic Quantum Gradient Descent (AQGD) with Epochs optimizer. Performs gradient descent optimization with a momentum term, analytic gradients, and customized step length schedule for parameterized quantum gates, i.e. Pauli Rotations. See, for example: * K. Mitarai, M. Negoro, M. Kitagawa, and K. Fujii."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeCasablancaV2",
			"name": "qiskit.providers.fake_provider.FakeCasablancaV2",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.utils.QuantumInstance",
			"name": "qiskit.utils.QuantumInstance",
			"type": "class",
			"description": "Deprecated: Quantum Backend including execution setting. Quantum Instance holds a Qiskit Terra backend as well as configuration for circuit transpilation and execution. When provided to an Aqua algorithm the algorithm will execute the circuits it needs to run using the instance."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeNairobiV2",
			"name": "qiskit.providers.fake_provider.FakeNairobiV2",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeWashingtonV2",
			"name": "qiskit.providers.fake_provider.FakeWashingtonV2",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.SamplingMinimumEigensolver",
			"name": "qiskit.algorithms.minimum_eigensolvers.SamplingMinimumEigensolver",
			"type": "class",
			"description": "The Sampling Minimum Eigensolver Interface. ## Methods ### compute\\_minimum\\_eigenvalue Compute the minimum eigenvalue of a diagonal operator. **Parameters** * **operator** (*BaseOperator |* *PauliSumOp*) – Diagonal qubit operator."
		},
		{
			"id": "qiskit.opflow.gradients",
			"name": "qiskit.opflow.gradients",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBogota",
			"name": "qiskit.providers.fake_provider.FakeBogota",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeCambridgeV2",
			"name": "qiskit.providers.fake_provider.FakeCambridgeV2",
			"type": "class",
			"description": "A fake Cambridge backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 06 ↕ ↕ 07 ↔ 08 ↔ 09 ↔ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↔ 15 ↕ ↕ ↕ 16 17 18 ↕ ↕ ↕ 19 ↔ 20 ↔ 21 ↔ 22 ↔ 23 ↔ 24 ↔ 25 ↔ 26 ↔ 27 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit.algorithms.optimizers.P_BFGS",
			"name": "qiskit.algorithms.optimizers.P_BFGS",
			"type": "class",
			"description": "Parallelized Limited-memory BFGS optimizer. P-BFGS is a parallelized version of L_BFGS_B with which it shares the same parameters. P-BFGS can be useful when the target hardware is a quantum simulator running on a classical machine."
		},
		{
			"id": "qiskit.algorithms.eigensolvers.VQDResult",
			"name": "qiskit.algorithms.eigensolvers.VQDResult",
			"type": "class",
			"description": "VQD Result. ## Attributes ### aux\\_operators\\_evaluated Return the aux operator expectation values. These values are in fact tuples formatted as (mean, metadata). ### cost\\_function\\_evals Returns number of cost optimizer evaluations ### eigenvalues Return the eigenvalues."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBurlingtonV2",
			"name": "qiskit.providers.fake_provider.FakeBurlingtonV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSingapore",
			"name": "qiskit.providers.fake_provider.FakeSingapore",
			"type": "class",
			"description": "A fake Singapore backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBackend5QV2",
			"name": "qiskit.providers.fake_provider.FakeBackend5QV2",
			"type": "class",
			"description": "A mock backend that doesn’t implement run() to test compatibility with Terra internals. The class qiskit.providers.fake_provider.fake_backend_v2.FakeBackend5QV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0. Use the qiskit.providers.basic\\_provider.GenericBackendV2 class instead."
		},
		{
			"id": "qiskit.algorithms.RealEvolver",
			"name": "qiskit.algorithms.RealEvolver",
			"type": "class",
			"description": "Deprecated: Interface for Quantum Real Time Evolution. The RealEvolver interface has been superseded by the qiskit.algorithms.time_evolvers.RealTimeEvolver interface. This interface will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeManhattanV2",
			"name": "qiskit.providers.fake_provider.FakeManhattanV2",
			"type": "class",
			"description": "A fake Manhattan backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.utils.mitigation.TensoredMeasFitter",
			"name": "qiskit.utils.mitigation.TensoredMeasFitter",
			"type": "class",
			"description": "Deprecated: Measurement correction fitter for a tensored calibration. Initialize a measurement calibration matrix from the results of running the circuits returned by measurement\\_calibration\\_circuits. This class is not a public API. The internals are not stable and will likely change."
		},
		{
			"id": "qiskit.algorithms",
			"name": "qiskit.algorithms",
			"type": "module",
			"description": "For Algorithm specific errors. Set the error message."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.QAOA",
			"name": "qiskit.algorithms.minimum_eigensolvers.QAOA",
			"type": "class",
			"description": "The Quantum Approximate Optimization Algorithm (QAOA). QAOA is a well-known algorithm for finding approximate solutions to combinatorial-optimization problems \\[1]. The QAOA implementation directly extends SamplingVQE and inherits its optimization structure."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSydneyV2",
			"name": "qiskit.providers.fake_provider.FakeSydneyV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.TrotterQRTE",
			"name": "qiskit.algorithms.TrotterQRTE",
			"type": "class",
			"description": "Deprecated: Quantum Real Time Evolution using Trotterization. The TrotterQRTE class has been superseded by the qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.algorithms.state_fidelities.BaseStateFidelity",
			"name": "qiskit.algorithms.state_fidelities.BaseStateFidelity",
			"type": "class",
			"description": "An interface to calculate state fidelities (state overlaps) for pairs of (parametrized) quantum circuits."
		},
		{
			"id": "qiskit.opflow.evolutions.TrotterizationFactory",
			"name": "qiskit.opflow.evolutions.TrotterizationFactory",
			"type": "class",
			"description": "Deprecated: A factory for conveniently creating TrotterizationBase instances. ## Methods ### build A factory for conveniently creating TrotterizationBase instances."
		},
		{
			"id": "qiskit.providers.basicaer.UnitarySimulatorPy",
			"name": "qiskit.providers.basicaer.UnitarySimulatorPy",
			"type": "class",
			"description": "Python implementation of a unitary simulator. The class qiskit.providers.basicaer.unitary_simulator.UnitarySimulatorPy is deprecated as of qiskit 0.46.0. It will be removed in Qiskit 1.0.0. The qiskit.providers.basicaer module has been superseded by qiskit.providers.basic\\_provider."
		},
		{
			"id": "qiskit.providers.basicaer.StatevectorSimulatorPy",
			"name": "qiskit.providers.basicaer.StatevectorSimulatorPy",
			"type": "class",
			"description": "Python statevector simulator. The class qiskit.providers.basicaer.statevector_simulator.StatevectorSimulatorPy is deprecated as of qiskit 0.46.0. It will be removed in Qiskit 1.0.0. The qiskit.providers.basicaer module has been superseded by qiskit.providers.basic\\_provider."
		},
		{
			"id": "qiskit.algorithms.gradients.SamplerGradientResult",
			"name": "qiskit.algorithms.gradients.SamplerGradientResult",
			"type": "class",
			"description": "Result of SamplerGradient. ## Attributes ### gradients The gradients of the sample probabilities. ### metadata Additional information about the job. ### options Primitive runtime options for the execution of the job."
		},
		{
			"id": "qiskit.algorithms.Grover",
			"name": "qiskit.algorithms.Grover",
			"type": "class",
			"description": "Grover’s Search algorithm. If you want to learn more about the theory behind Grover’s Search algorithm, check out the Qiskit Textbook. or the Qiskit Tutorials for more concrete how-to examples."
		},
		{
			"id": "qiskit.opflow.state_fns",
			"name": "qiskit.opflow.state_fns",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.algorithms.gradients.SPSAEstimatorGradient",
			"name": "qiskit.algorithms.gradients.SPSAEstimatorGradient",
			"type": "class",
			"description": "Compute the gradients of the expectation value by the Simultaneous Perturbation Stochastic Approximation (SPSA) \\[1]. **Reference:** \\[1] J. C. Spall, Adaptive stochastic approximation by the simultaneous perturbation method in IEEE Transactions on Automatic Control, vol. 45, no. 10, pp."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeOurense",
			"name": "qiskit.providers.fake_provider.FakeOurense",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeJakartaV2",
			"name": "qiskit.providers.fake_provider.FakeJakartaV2",
			"type": "class",
			"description": "A fake 7 qubit V2 backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.transpiler.passes.NoiseAdaptiveLayout",
			"name": "qiskit.transpiler.passes.NoiseAdaptiveLayout",
			"type": "class",
			"description": "Choose a noise-adaptive Layout based on current calibration data for the backend. > This pass associates a physical qubit (int) to each virtual qubit of the circuit (Qubit), using calibration data."
		},
		{
			"id": "qiskit.opflow.evolutions.EvolvedOp",
			"name": "qiskit.opflow.evolutions.EvolvedOp",
			"type": "class",
			"description": "Deprecated: Class for wrapping Operator Evolutions for compilation (convert) by an EvolutionBase method later, essentially acting as a placeholder. Note that EvolvedOp is a weird case of PrimitiveOp."
		},
		{
			"id": "qiskit.tools",
			"name": "qiskit.tools",
			"type": "module",
			"description": "' mode='w' encoding='utf-8'>, line_discipline='\\r')\"> Monitor the status of a Job instance. **Parameters** * **job** (*BaseJob*) – Job to monitor. * **interval** (*int*\")) – Time interval between status queries. * **quiet** (*bool*\")) – If True, do not print status messages."
		},
		{
			"id": "qiskit.algorithms.IterativePhaseEstimation",
			"name": "qiskit.algorithms.IterativePhaseEstimation",
			"type": "class",
			"description": "Run the Iterative quantum phase estimation (QPE) algorithm. Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the eigenvalue as a number in using the iterative phase estimation algorithm. **\\[1]: Dobsicek et al."
		},
		{
			"id": "qiskit.algorithms.optimizers.Optimizer",
			"name": "qiskit.algorithms.optimizers.Optimizer",
			"type": "class",
			"description": "Base class for optimization algorithm. Initialize the optimization algorithm, setting the support level for \\_gradient\\_support\\_level, \\_bound\\_support\\_level, \\_initial\\_point\\_support\\_level, and empty options."
		},
		{
			"id": "qiskit.algorithms.optimizers.OptimizerSupportLevel",
			"name": "qiskit.algorithms.optimizers.OptimizerSupportLevel",
			"type": "class",
			"description": "Support Level enum for features such as bounds, gradient and initial point ## Attributes ### not\\_supported ### ignored ### supported ### required"
		},
		{
			"id": "qiskit.visualization.pulse.IQXStandard",
			"name": "qiskit.visualization.pulse.IQXStandard",
			"type": "class",
			"description": "Standard pulse stylesheet. * Generate stepwise waveform envelope with latex pulse names. * Apply phase modulation to waveforms. * Plot frame change symbol with formatted operand values. * Show chart name with scaling factor. * Show snapshot and barrier. * Do not show acquire channels."
		},
		{
			"id": "qiskit.algorithms.gradients.BaseQGT",
			"name": "qiskit.algorithms.gradients.BaseQGT",
			"type": "class",
			"description": "Base class to computes the Quantum Geometric Tensor (QGT) given a pure, parameterized quantum state. QGT is defined as: **Parameters** * **estimator** (*BaseEstimator*) – The estimator used to compute the QGT."
		},
		{
			"id": "qiskit.algorithms.gradients.LinCombEstimatorGradient",
			"name": "qiskit.algorithms.gradients.LinCombEstimatorGradient",
			"type": "class",
			"description": "Compute the gradients of the expectation values. This method employs a linear combination of unitaries \\[1]."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeLondon",
			"name": "qiskit.providers.fake_provider.FakeLondon",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeTokyo",
			"name": "qiskit.providers.fake_provider.FakeTokyo",
			"type": "class",
			"description": "A fake 20 qubit backend."
		},
		{
			"id": "qiskit.opflow.list_ops.ComposedOp",
			"name": "qiskit.opflow.list_ops.ComposedOp",
			"type": "class",
			"description": "Deprecated: A class for lazily representing compositions of Operators. Often Operators cannot be efficiently composed with one another, but may be manipulated further so that they can be composed later."
		},
		{
			"id": "qiskit.extensions.Snapshot",
			"name": "qiskit.extensions.Snapshot",
			"type": "class",
			"description": "Simulator snapshot instruction. Create new snapshot instruction. The class qiskit.extensions.simulator.snapshot.Snapshot is deprecated as of qiskit 0.45.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.algorithms.optimizers.SNOBFIT",
			"name": "qiskit.algorithms.optimizers.SNOBFIT",
			"type": "class",
			"description": "Stable Noisy Optimization by Branch and FIT algorithm. SnobFit is used for the optimization of derivative-free, noisy objective functions providing robust and fast solutions of problems with continuous variables varying within bound. Uses skquant.opt installed with pip install scikit-quant."
		},
		{
			"id": "qiskit.visualization.pulse.IQXDebugging",
			"name": "qiskit.visualization.pulse.IQXDebugging",
			"type": "class",
			"description": "Pulse stylesheet for pulse programmers. Show details of instructions. \\# TODO: add more generators * Generate stepwise waveform envelope with latex pulse names. * Generate annotation for waveform height. * Apply phase modulation to waveforms. * Plot frame change symbol with raw operand values."
		},
		{
			"id": "qiskit.opflow.expectations.ExpectationBase",
			"name": "qiskit.opflow.expectations.ExpectationBase",
			"type": "class",
			"description": "Deprecated: A base for Expectation value converters. Expectations are converters which enable the computation of the expectation value of an Observable with respect to some state function."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeArmonkV2",
			"name": "qiskit.providers.fake_provider.FakeArmonkV2",
			"type": "class",
			"description": "A fake 1 qubit backend. ``text 0 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeAthensV2",
			"name": "qiskit.providers.fake_provider.FakeAthensV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeManila",
			"name": "qiskit.providers.fake_provider.FakeManila",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeEssexV2",
			"name": "qiskit.providers.fake_provider.FakeEssexV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.gradients.QFIResult",
			"name": "qiskit.algorithms.gradients.QFIResult",
			"type": "class",
			"description": "Result of QFI. ## Attributes ### qfis The QFI. ### metadata Additional information about the job. ### options Primitive runtime options for the execution of the job."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBrooklyn",
			"name": "qiskit.providers.fake_provider.FakeBrooklyn",
			"type": "class",
			"description": "A fake Brooklyn backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.SamplingMinimumEigensolverResult",
			"name": "qiskit.algorithms.minimum_eigensolvers.SamplingMinimumEigensolverResult",
			"type": "class",
			"description": "Sampling Minimum Eigensolver Result. In contrast to the result of a MinimumEigenSolver, this result also contains the best measurement of the overall optimization and the samples of the final state. ## Attributes ### aux\\_operators\\_evaluated Return aux operator expectation values and metadata."
		},
		{
			"id": "qiskit.algorithms.optimizers.optimizer_utils",
			"name": "qiskit.algorithms.optimizers.optimizer_utils",
			"type": "module",
			"description": "Utils for optimizers"
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.VQEResult",
			"name": "qiskit.algorithms.minimum_eigensolvers.VQEResult",
			"type": "class",
			"description": "Variational quantum eigensolver result. ## Attributes ### aux\\_operators\\_evaluated The aux operator expectation values. These values are in fact tuples formatted as (mean, (variance, shots)). ### cost\\_function\\_evals The number of cost optimizer evaluations."
		},
		{
			"id": "qiskit.algorithms.optimizers.NELDER_MEAD",
			"name": "qiskit.algorithms.optimizers.NELDER_MEAD",
			"type": "class",
			"description": "Nelder-Mead optimizer. The Nelder-Mead algorithm performs unconstrained optimization; it ignores bounds or constraints. It is used to find the minimum or maximum of an objective function in a multidimensional space. It is based on the Simplex algorithm."
		},
		{
			"id": "qiskit.opflow.converters.PauliBasisChange",
			"name": "qiskit.opflow.converters.PauliBasisChange",
			"type": "class",
			"description": "Deprecated: Converter for changing Paulis into other bases. By default, the diagonal basis composed only of Pauli \\{Z, I}^n is used as the destination basis to which to convert."
		},
		{
			"id": "qiskit.opflow.expectations.ExpectationFactory",
			"name": "qiskit.opflow.expectations.ExpectationFactory",
			"type": "class",
			"description": "Deprecated: factory class for convenient automatic selection of an Expectation based on the Operator to be converted and backend used to sample the expectation value."
		},
		{
			"id": "qiskit.algorithms.EstimationProblem",
			"name": "qiskit.algorithms.EstimationProblem",
			"type": "class",
			"description": "The estimation problem is the input to amplitude estimation algorithm. This class contains all problem-specific information required to run an amplitude estimation algorithm. That means, it minimally contains the state preparation and the specification of the good state."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeJohannesburgV2",
			"name": "qiskit.providers.fake_provider.FakeJohannesburgV2",
			"type": "class",
			"description": "A fake Johannesburg V2 backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeManilaV2",
			"name": "qiskit.providers.fake_provider.FakeManilaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.gradients.ParamShiftEstimatorGradient",
			"name": "qiskit.algorithms.gradients.ParamShiftEstimatorGradient",
			"type": "class",
			"description": "Compute the gradients of the expectation values by the parameter shift rule \\[1]. **Reference:** \\[1] Schuld, M., Bergholm, V., Gogolin, C., Izaac, J., and Killoran, N."
		},
		{
			"id": "qiskit.providers.fake_provider.FakePrague",
			"name": "qiskit.providers.fake_provider.FakePrague",
			"type": "class",
			"description": "A fake 33 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeOurenseV2",
			"name": "qiskit.providers.fake_provider.FakeOurenseV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSherbrooke",
			"name": "qiskit.providers.fake_provider.FakeSherbrooke",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.eigensolvers.VQD",
			"name": "qiskit.algorithms.eigensolvers.VQD",
			"type": "class",
			"description": "The Variational Quantum Deflation algorithm. Implementation using primitives. VQD is a quantum algorithm that uses a variational technique to find the k eigenvalues of the Hamiltonian of a given system."
		},
		{
			"id": "qiskit.algorithms.optimizers.UMDA",
			"name": "qiskit.algorithms.optimizers.UMDA",
			"type": "class",
			"description": "Continuous Univariate Marginal Distribution Algorithm (UMDA)."
		},
		{
			"id": "qiskit.opflow.converters.AbelianGrouper",
			"name": "qiskit.opflow.converters.AbelianGrouper",
			"type": "class",
			"description": "Deprecated: The AbelianGrouper converts SummedOps into a sum of Abelian sums. Meaning, it will traverse the Operator, and when it finds a SummedOp, it will evaluate which of the summed sub-Operators commute with one another."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational",
			"name": "qiskit.algorithms.time_evolvers.variational",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBogotaV2",
			"name": "qiskit.providers.fake_provider.FakeBogotaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.QAOA",
			"name": "qiskit.algorithms.QAOA",
			"type": "class",
			"description": "Deprecated: Quantum Approximate Optimization Algorithm. The QAOA class has been superseded by the qiskit.algorithms.minimum_eigensolvers.QAOA class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.algorithms.gradients.ReverseEstimatorGradient",
			"name": "qiskit.algorithms.gradients.ReverseEstimatorGradient",
			"type": "class",
			"description": "Estimator gradients with the classically efficient reverse mode. This gradient implementation is based on statevector manipulations and scales exponentially with the number of qubits. However, for small system sizes it can be very fast compared to circuit-based gradients."
		},
		{
			"id": "qiskit.opflow.expectations",
			"name": "qiskit.opflow.expectations",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.algorithms.optimizers.SteppableOptimizer",
			"name": "qiskit.algorithms.optimizers.SteppableOptimizer",
			"type": "class",
			"description": "Base class for a steppable optimizer. This family of optimizers uses the ask and tell interface. When using this interface the user has to call ask() to get information about how to evaluate the function (we are asking the optimizer about how to do the evaluation)."
		},
		{
			"id": "qiskit.algorithms.gradients.LinCombQGT",
			"name": "qiskit.algorithms.gradients.LinCombQGT",
			"type": "class",
			"description": "Computes the Quantum Geometric Tensor (QGT) given a pure, parameterized quantum state. This method employs a linear combination of unitaries \\[1]."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeCasablanca",
			"name": "qiskit.providers.fake_provider.FakeCasablanca",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeQasmSimulator",
			"name": "qiskit.providers.fake_provider.FakeQasmSimulator",
			"type": "class",
			"description": "A fake simulator backend. The class qiskit.providers.fake_provider.fake_qasm_simulator.FakeQasmSimulator is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0. Use the qiskit.providers.basic\\_provider.BasicSimulator class instead."
		},
		{
			"id": "qiskit.opflow.gradients.HessianBase",
			"name": "qiskit.opflow.gradients.HessianBase",
			"type": "class",
			"description": "Deprecated: Base class for the Hessian of an expected value. The class qiskit.opflow.gradients.hessian_base.HessianBase is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.algorithms.EvolutionResult",
			"name": "qiskit.algorithms.EvolutionResult",
			"type": "class",
			"description": "Deprecated: Class for holding evolution result. The EvolutionResult class has been superseded by the qiskit.algorithms.time_evolvers.TimeEvolutionResult class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.algorithms.MinimumEigensolverResult",
			"name": "qiskit.algorithms.MinimumEigensolverResult",
			"type": "class",
			"description": "Deprecated: Minimum Eigensolver Result. The MinimumEigensolverResult class has been superseded by the qiskit.algorithms.minimum_eigensolvers.MinimumEigensolverResult class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.opflow.converters.CircuitSampler",
			"name": "qiskit.opflow.converters.CircuitSampler",
			"type": "class",
			"description": "Deprecated: The CircuitSampler traverses an Operator and converts any CircuitStateFns into approximations of the state function by a DictStateFn or VectorStateFn using a quantum backend."
		},
		{
			"id": "qiskit.opflow.converters.DictToCircuitSum",
			"name": "qiskit.opflow.converters.DictToCircuitSum",
			"type": "class",
			"description": "Deprecated: Converts DictStateFns or VectorStateFns to equivalent CircuitStateFns or sums thereof."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.variational.ImaginaryMcLachlanPrinciple",
			"name": "qiskit.algorithms.time_evolvers.variational.ImaginaryMcLachlanPrinciple",
			"type": "class",
			"description": "Class for an Imaginary McLachlan’s Variational Principle. It aims to minimize the distance between both sides of the Wick-rotated Schrödinger equation with a quantum state given as a parametrized trial state. The principle leads to a system of linear equations handled by a linear solver."
		},
		{
			"id": "qiskit.transpiler.FencedDAGCircuit",
			"name": "qiskit.transpiler.FencedDAGCircuit",
			"type": "class",
			"description": "A dag circuit that cannot be modified (via remove\\_op\\_node) The class qiskit.transpiler.fencedobjs.FencedDAGCircuit is deprecated as of qiskit 0.46.0. It will be removed in the 1.0 release. Internal use of FencedObject is already removed from pass manager."
		},
		{
			"id": "qiskit.algorithms.VarQITE",
			"name": "qiskit.algorithms.VarQITE",
			"type": "class",
			"description": ", lse_solver=None, num_timesteps=None, imag_part_tol=1e-07, num_instability_tol=1e-07)\" modifiers=\"class\"> Bases: VarQTE, ImaginaryTimeEvolver Variational Quantum Imaginary Time Evolution algorithm. **Parameters** * **ansatz** (*QuantumCircuit*) – Ansatz to be used for variational time evolution."
		},
		{
			"id": "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE",
			"name": "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE",
			"type": "class",
			"description": "Quantum Real Time Evolution using Trotterization. Type of Trotterization is defined by a ProductFormula provided."
		},
		{
			"id": "qiskit.opflow.state_fns.CVaRMeasurement",
			"name": "qiskit.opflow.state_fns.CVaRMeasurement",
			"type": "class",
			"description": "**Deprecated: A specialized measurement class to compute CVaR expectation values.** See https://arxiv.org/pdf/1907.04769.pdf for further details. Used in CVaRExpectation, see there for more details. The class qiskit.opflow.state_fns.cvar_measurement.CVaRMeasurement is deprecated as of qiskit 0.24.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeKolkataV2",
			"name": "qiskit.providers.fake_provider.FakeKolkataV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSingaporeV2",
			"name": "qiskit.providers.fake_provider.FakeSingaporeV2",
			"type": "class",
			"description": "A fake Singapore backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeLagos",
			"name": "qiskit.providers.fake_provider.FakeLagos",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.transpiler.FencedPropertySet",
			"name": "qiskit.transpiler.FencedPropertySet",
			"type": "class",
			"description": "A property set that cannot be written (via \\_\\_setitem\\_\\_) The class qiskit.transpiler.fencedobjs.FencedPropertySet is deprecated as of qiskit 0.46.0. It will be removed in the 1.0 release. Internal use of FencedObject is already removed from pass manager."
		},
		{
			"id": "qiskit.algorithms.FasterAmplitudeEstimationResult",
			"name": "qiskit.algorithms.FasterAmplitudeEstimationResult",
			"type": "class",
			"description": "The result object for the Faster Amplitude Estimation algorithm. ## Attributes ### circuit\\_results Return the circuit results. Can be a statevector or counts dictionary. ### confidence\\_interval Return the confidence interval for the amplitude (95% interval by default)."
		},
		{
			"id": "qiskit.opflow.gradients.QFI",
			"name": "qiskit.opflow.gradients.QFI",
			"type": "class",
			"description": "Deprecated: Compute the Quantum Fisher Information (QFI). Computes the QFI given a pure, parameterized quantum state, where QFI is: The class qiskit.opflow.gradients.qfi.QFI is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeEssex",
			"name": "qiskit.providers.fake_provider.FakeEssex",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.optimizers.ADAM",
			"name": "qiskit.algorithms.optimizers.ADAM",
			"type": "class",
			"description": "Adam and AMSGRAD optimizers. Adam \\[1] is a gradient-based optimization algorithm that is relies on adaptive estimates of lower-order moments. The algorithm requires little memory and is invariant to diagonal rescaling of the gradients."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMelbourneV2",
			"name": "qiskit.providers.fake_provider.FakeMelbourneV2",
			"type": "class",
			"description": "A fake 14 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation",
			"name": "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation",
			"type": "class",
			"description": "The Maximum Likelihood Amplitude Estimation algorithm. This class implements the quantum amplitude estimation (QAE) algorithm without phase estimation, as introduced in \\[1]."
		},
		{
			"id": "qiskit.algorithms.optimizers.DIRECT_L",
			"name": "qiskit.algorithms.optimizers.DIRECT_L",
			"type": "class",
			"description": "DIviding RECTangles Locally-biased optimizer. DIviding RECTangles (DIRECT) is a deterministic-search algorithms based on systematic division of the search domain into increasingly smaller hyper-rectangles."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeCairo",
			"name": "qiskit.providers.fake_provider.FakeCairo",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.optimizers.TellData",
			"name": "qiskit.algorithms.optimizers.TellData",
			"type": "class",
			"description": "Base class for argument type of tell(). **Parameters** * **eval\\_fun** (*float*\") *|**list*\")*\\*[*float*\")*] | None*) – Image of the function at x_fun. * **eval\\_jac** (*POINT |* *list*\")*\\[POINT] | None*) – Image of the gradient-jacobian at x_jac. ## Attributes ### eval\\_fun ### eval\\_jac"
		},
		{
			"id": "qiskit.algorithms.optimizers.SPSA",
			"name": "qiskit.algorithms.optimizers.SPSA",
			"type": "class",
			"description": "Simultaneous Perturbation Stochastic Approximation (SPSA) optimizer. SPSA \\[1] is an gradient descent method for optimizing systems with multiple unknown parameters. As an optimization method, it is appropriately suited to large-scale population models, adaptive modeling, and simulation optimization."
		},
		{
			"id": "qiskit.algorithms.gradients.FiniteDiffSamplerGradient",
			"name": "qiskit.algorithms.gradients.FiniteDiffSamplerGradient",
			"type": "class",
			"description": "Compute the gradients of the sampling probability by finite difference method \\[1]. **Reference:** \\[1] Finite difference method **Parameters** * **sampler** (*BaseSampler*) – The sampler used to compute the gradients. * **epsilon** (*float*\")) – The offset size for the finite difference gradients."
		},
		{
			"id": "qiskit.algorithms.optimizers.SciPyOptimizer",
			"name": "qiskit.algorithms.optimizers.SciPyOptimizer",
			"type": "class",
			"description": "A general Qiskit Optimizer wrapping scipy.optimize.minimize. For further detail, please refer to https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html **Parameters** * **method** (*str*\") *| Callable*) – Type of solver."
		},
		{
			"id": "qiskit.opflow.evolutions.Suzuki",
			"name": "qiskit.opflow.evolutions.Suzuki",
			"type": "class",
			"description": "Deprecated: Suzuki Trotter expansion, composing the evolution circuits of each Operator in the sum together by a recursive “bookends” strategy, repeating the whole composed circuit reps times. Detailed in https://arxiv.org/pdf/quant-ph/0508139.pdf."
		},
		{
			"id": "qiskit.algorithms.optimizers.GradientDescentState",
			"name": "qiskit.algorithms.optimizers.GradientDescentState",
			"type": "class",
			"description": "State of GradientDescent. Dataclass with all the information of an optimizer plus the learning\\_rate and the stepsize. ## Attributes ### stepsize Norm of the gradient on the last step. ### learning\\_rate Learning rate at the current step of the optimization process."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeToronto",
			"name": "qiskit.providers.fake_provider.FakeToronto",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.gradients.ParamShiftSamplerGradient",
			"name": "qiskit.algorithms.gradients.ParamShiftSamplerGradient",
			"type": "class",
			"description": "Compute the gradients of the sampling probability by the parameter shift rule \\[1]. **Reference:** \\[1] Schuld, M., Bergholm, V., Gogolin, C., Izaac, J., and Killoran, N."
		},
		{
			"id": "qiskit.algorithms.optimizers.POWELL",
			"name": "qiskit.algorithms.optimizers.POWELL",
			"type": "class",
			"description": "Powell optimizer. The Powell algorithm performs unconstrained optimization; it ignores bounds or constraints. Powell is a *conjugate direction method*: it performs sequential one-dimensional minimization along each directional vector, which is updated at each iteration of the main minimization loop."
		},
		{
			"id": "qiskit.algorithms.TimeEvolutionResult",
			"name": "qiskit.algorithms.TimeEvolutionResult",
			"type": "class",
			"description": "Class for holding time evolution result. ### evolved\\_state An evolved quantum state. **Type** QuantumCircuit|Statevector ### aux\\_ops\\_evaluated Optional list of observables for which expected values on an evolved state are calculated."
		},
		{
			"id": "qiskit.algorithms.MinimumEigensolver",
			"name": "qiskit.algorithms.MinimumEigensolver",
			"type": "class",
			"description": "Deprecated: Minimum Eigensolver Interface. The Minimum Eigensolver interface has been superseded by the qiskit.algorithms.minimum_eigensolvers.MinimumEigensolver interface. This interface will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.opflow.evolutions.TrotterizationBase",
			"name": "qiskit.opflow.evolutions.TrotterizationBase",
			"type": "class",
			"description": "Deprecated: A base for Trotterization methods, algorithms for approximating exponentiations of operator sums by compositions of exponentiations. The class qiskit.opflow.evolutions.trotterizations.trotterization_base.TrotterizationBase is deprecated as of qiskit-terra 0.24.0."
		},
		{
			"id": "qiskit.algorithms.optimizers.ISRES",
			"name": "qiskit.algorithms.optimizers.ISRES",
			"type": "class",
			"description": "Improved Stochastic Ranking Evolution Strategy optimizer. Improved Stochastic Ranking Evolution Strategy (ISRES) is an algorithm for non-linearly constrained global optimization. It has heuristics to escape local optima, even though convergence to a global optima is not guaranteed."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.AdaptVQEResult",
			"name": "qiskit.algorithms.minimum_eigensolvers.AdaptVQEResult",
			"type": "class",
			"description": "AdaptVQE Result. ## Attributes ### aux\\_operators\\_evaluated The aux operator expectation values. These values are in fact tuples formatted as (mean, (variance, shots)). ### cost\\_function\\_evals The number of cost optimizer evaluations. ### eigenvalue The computed minimum eigenvalue."
		},
		{
			"id": "qiskit.algorithms.PVQD",
			"name": "qiskit.algorithms.PVQD",
			"type": "class",
			"description": "The projected Variational Quantum Dynamics (p-VQD) Algorithm. In each timestep, this algorithm computes the next state with a Trotter formula (specified by the evolution argument) and projects the timestep onto a variational form (ansatz)."
		},
		{
			"id": "qiskit.algorithms.HamiltonianPhaseEstimation",
			"name": "qiskit.algorithms.HamiltonianPhaseEstimation",
			"type": "class",
			"description": "Run the Quantum Phase Estimation algorithm to find the eigenvalues of a Hermitian operator."
		},
		{
			"id": "qiskit.algorithms.RealTimeEvolver",
			"name": "qiskit.algorithms.RealTimeEvolver",
			"type": "class",
			"description": "Interface for Quantum Real Time Evolution. ## Methods ### evolve Perform real time evolution . Evolves an initial state for a time under a Hamiltonian , as provided in the evolution_problem. **Parameters** **evolution\\_problem** (*TimeEvolutionProblem*) – The definition of the evolution problem."
		},
		{
			"id": "qiskit.visualization.pulse_drawer",
			"name": "qiskit.visualization.pulse_drawer",
			"type": "function",
			"description": "Generate visualization data for pulse programs. **Parameters** * **program** (*Waveform* *|**ParametricPulse* *|**SymbolicPulse* *|**Schedule* *|**ScheduleBlock*) – Program to visualize."
		},
		{
			"id": "qiskit.algorithms.optimizers.AskData",
			"name": "qiskit.algorithms.optimizers.AskData",
			"type": "class",
			"description": "Base class for return type of ask()."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeYorktownV2",
			"name": "qiskit.providers.fake_provider.FakeYorktownV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 1 / | 0 - 2 - 3 | / 4 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeCairoV2",
			"name": "qiskit.providers.fake_provider.FakeCairoV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.AmplitudeEstimationResult",
			"name": "qiskit.algorithms.AmplitudeEstimationResult",
			"type": "class",
			"description": "The AmplitudeEstimation result object. ## Attributes ### circuit\\_results Return the circuit results. Can be a statevector or counts dictionary. ### confidence\\_interval Return the confidence interval for the amplitude (95% interval by default)."
		},
		{
			"id": "qiskit.algorithms.PhaseEstimationResult",
			"name": "qiskit.algorithms.PhaseEstimationResult",
			"type": "class",
			"description": "Store and manipulate results from running PhaseEstimation. This class is instantiated by the PhaseEstimation class, not via user code. The PhaseEstimation class generates a list of phases and corresponding weights. Upon completion it returns the results as an instance of this class."
		},
		{
			"id": "qiskit.algorithms.optimizers.CRS",
			"name": "qiskit.algorithms.optimizers.CRS",
			"type": "class",
			"description": "Controlled Random Search (CRS) with local mutation optimizer. Controlled Random Search (CRS) with local mutation is part of the family of the CRS optimizers. The CRS optimizers start with a random population of points, and randomly evolve these points by heuristic rules."
		},
		{
			"id": "qiskit.algorithms.EigensolverResult",
			"name": "qiskit.algorithms.EigensolverResult",
			"type": "class",
			"description": "Deprecated: Eigensolver Result. The EigensolverResult class has been superseded by the qiskit.algorithms.eigensolvers.EigensolverResult class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.SamplingVQEResult",
			"name": "qiskit.algorithms.minimum_eigensolvers.SamplingVQEResult",
			"type": "class",
			"description": "VQE Result. ## Attributes ### aux\\_operators\\_evaluated Return aux operator expectation values and metadata. These are formatted as (mean, metadata). ### best\\_measurement Return the best measurement over the entire optimization. Possesses keys: state, bitstring, value, probability."
		},
		{
			"id": "qiskit.transpiler.passes.LinearFunctionsSynthesis",
			"name": "qiskit.transpiler.passes.LinearFunctionsSynthesis",
			"type": "class",
			"description": "DEPRECATED: Synthesize linear functions. Under the hood, this runs the default high-level synthesis plugin for linear functions. The class qiskit.transpiler.passes.synthesis.linear_functions_synthesis.LinearFunctionsSynthesis is deprecated as of qiskit-terra 0.23.0."
		},
		{
			"id": "qiskit.algorithms.optimizers.COBYLA",
			"name": "qiskit.algorithms.optimizers.COBYLA",
			"type": "class",
			"description": "Constrained Optimization By Linear Approximation optimizer. COBYLA is a numerical optimization method for constrained problems where the derivative of the objective function is not known. Uses scipy.optimize.minimize COBYLA."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeTenerife",
			"name": "qiskit.providers.fake_provider.FakeTenerife",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 1 ↙ ↑ 0 ← 2 ← 3 ↑ ↙ 4 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used. These are used to control the run()` method."
		},
		{
			"id": "qiskit.opflow.primitive_ops.PrimitiveOp",
			"name": "qiskit.opflow.primitive_ops.PrimitiveOp",
			"type": "class",
			"description": "Deprecated: A class for representing basic Operators, backed by Operator primitives from Terra. This class (and inheritors) primarily serves to allow the underlying primitives to “flow” - i.e."
		},
		{
			"id": "qiskit.visualization.pulse.IQXSimple",
			"name": "qiskit.visualization.pulse.IQXSimple",
			"type": "class",
			"description": "Simple pulse stylesheet without channel notation. * Generate stepwise waveform envelope with latex pulse names. * Apply phase modulation to waveforms. * Do not show frame changes. * Show chart name. * Do not show snapshot and barrier. * Do not show acquire channels. * Channels are sorted by qubit index."
		},
		{
			"id": "qiskit.extensions.SingleQubitUnitary",
			"name": "qiskit.extensions.SingleQubitUnitary",
			"type": "class",
			"description": "Single-qubit unitary. **Parameters** * **unitary\\_matrix** – unitary (given as a (complex) numpy.ndarray). * **mode** – determines the used decomposition by providing the rotation axes. * **up\\_to\\_diagonal** – the single-qubit unitary is decomposed up to a diagonal matrix, i.e."
		},
		{
			"id": "qiskit.utils.mitigation",
			"name": "qiskit.utils.mitigation",
			"type": "module",
			"description": "qiskit.utils.mitigation This module is deprecated and will be removed no sooner than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi\\_migration. The user-facing API stability of this module is not guaranteed except for its use with the QuantumInstance (i.e."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeVigoV2",
			"name": "qiskit.providers.fake_provider.FakeVigoV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.gradients.CircuitQFI",
			"name": "qiskit.opflow.gradients.CircuitQFI",
			"type": "class",
			"description": "Deprecated: Circuit to Quantum Fisher Information operator converter."
		},
		{
			"id": "qiskit.extensions",
			"name": "qiskit.extensions",
			"type": "module",
			"description": "Base class for errors raised by extensions module. Set the error message. The class qiskit.extensions.exceptions.ExtensionError is deprecated as of qiskit 0.46.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.opflow.state_fns.VectorStateFn",
			"name": "qiskit.opflow.state_fns.VectorStateFn",
			"type": "class",
			"description": "Deprecated: A class for state functions and measurements which are defined in vector representation, and stored using Terra’s Statevector class. The class qiskit.opflow.state_fns.vector_state_fn.VectorStateFn is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.algorithms.EvolutionProblem",
			"name": "qiskit.algorithms.EvolutionProblem",
			"type": "class",
			"description": "Deprecated: Evolution problem class. The EvolutionProblem class has been superseded by the qiskit.algorithms.time_evolvers.TimeEvolutionProblem class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.algorithms.IterativeAmplitudeEstimation",
			"name": "qiskit.algorithms.IterativeAmplitudeEstimation",
			"type": "class",
			"description": "The Iterative Amplitude Estimation algorithm. This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed in \\[1]."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeAlmadenV2",
			"name": "qiskit.providers.fake_provider.FakeAlmadenV2",
			"type": "class",
			"description": "A fake Almaden V2 backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.VQE",
			"name": "qiskit.algorithms.minimum_eigensolvers.VQE",
			"type": "class",
			"description": "The variational quantum eigensolver (VQE) algorithm. VQE is a hybrid quantum-classical algorithm that uses a variational technique to find the minimum eigenvalue of a given Hamiltonian operator ."
		},
		{
			"id": "qiskit.algorithms.FasterAmplitudeEstimation",
			"name": "qiskit.algorithms.FasterAmplitudeEstimation",
			"type": "class",
			"description": "The Faster Amplitude Estimation algorithm. The Faster Amplitude Estimation (FAE) \\[1] algorithm is a variant of Quantum Amplitude Estimation (QAE), where the Quantum Phase Estimation (QPE) by an iterative Grover search, similar to \\[2]."
		},
		{
			"id": "qiskit.providers.fake_provider.FakePoughkeepsie",
			"name": "qiskit.providers.fake_provider.FakePoughkeepsie",
			"type": "class",
			"description": "A fake Poughkeepsie backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used."
		},
		{
			"id": "qiskit.providers.basicaer.QasmSimulatorPy",
			"name": "qiskit.providers.basicaer.QasmSimulatorPy",
			"type": "class",
			"description": "Python implementation of an OpenQASM 2 simulator. The class qiskit.providers.basicaer.qasm_simulator.QasmSimulatorPy is deprecated as of qiskit 0.46.0. It will be removed in Qiskit 1.0.0. The qiskit.providers.basicaer module has been superseded by qiskit.providers.basic\\_provider."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeRomeV2",
			"name": "qiskit.providers.fake_provider.FakeRomeV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.expectations.MatrixExpectation",
			"name": "qiskit.opflow.expectations.MatrixExpectation",
			"type": "class",
			"description": "An Expectation converter which converts Operator measurements to be matrix-based so they can be evaluated by matrix multiplication. The class qiskit.opflow.expectations.matrix_expectation.MatrixExpectation is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBoeblingen",
			"name": "qiskit.providers.fake_provider.FakeBoeblingen",
			"type": "class",
			"description": "A fake Boeblingen backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.gradients.BaseSamplerGradient",
			"name": "qiskit.algorithms.gradients.BaseSamplerGradient",
			"type": "class",
			"description": "Base class for a SamplerGradient to compute the gradients of the sampling probability. **Parameters** * **sampler** (*BaseSampler*) – The sampler used to compute the gradients. * **options** (*Options* *| None*) – Primitive backend runtime options used for circuit execution."
		},
		{
			"id": "qiskit.algorithms.SciPyRealEvolver",
			"name": "qiskit.algorithms.SciPyRealEvolver",
			"type": "class",
			"description": "Classical Evolver for real time evolution. Evolves an initial state for a time under a Hamiltonian , as provided in the evolution_problem. Note that the precision of the evolver does not depend on the number of timesteps taken."
		},
		{
			"id": "qiskit.algorithms.state_fidelities",
			"name": "qiskit.algorithms.state_fidelities",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.qasm",
			"name": "qiskit.qasm",
			"type": "module",
			"description": "OPENQASM circuit object. Create an OPENQASM circuit object."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolverResult",
			"name": "qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolverResult",
			"type": "class",
			"description": "NumPy minimum eigensolver result. ## Attributes ### aux\\_operators\\_evaluated The aux operator expectation values. These values are in fact tuples formatted as (mean, (variance, shots)). ### eigenstate Returns the eigenstate corresponding to the computed minimum eigenvalue."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeGuadalupe",
			"name": "qiskit.providers.fake_provider.FakeGuadalupe",
			"type": "class",
			"description": "A fake 16 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMontreal",
			"name": "qiskit.providers.fake_provider.FakeMontreal",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.gradients.NaturalGradient",
			"name": "qiskit.opflow.gradients.NaturalGradient",
			"type": "class",
			"description": "Deprecated: Convert an operator expression to the first-order gradient."
		},
		{
			"id": "qiskit.algorithms.gradients.ReverseQGT",
			"name": "qiskit.algorithms.gradients.ReverseQGT",
			"type": "class",
			"description": "QGT calculation with the classically efficient reverse mode. This QGT implementation is based on statevector manipulations and scales exponentially with the number of qubits. However, for small system sizes it can be very fast compared to circuit-based gradients."
		},
		{
			"id": "qiskit.algorithms.optimizers.IMFIL",
			"name": "qiskit.algorithms.optimizers.IMFIL",
			"type": "class",
			"description": "IMplicit FILtering algorithm. Implicit filtering is a way to solve bound-constrained optimization problems for which derivatives are not available."
		},
		{
			"id": "qiskit.transpiler.passes.SolovayKitaevSynthesis",
			"name": "qiskit.transpiler.passes.SolovayKitaevSynthesis",
			"type": "class",
			"description": "A Solovay-Kitaev Qiskit unitary synthesis plugin. This plugin is invoked by transpile() when the unitary_synthesis_method parameter is set to \"sk\"."
		},
		{
			"id": "qiskit.algorithms.ImaginaryTimeEvolver",
			"name": "qiskit.algorithms.ImaginaryTimeEvolver",
			"type": "class",
			"description": "Interface for Quantum Imaginary Time Evolution. ## Methods ### evolve Perform imaginary time evolution . Evolves an initial state for an imaginary time under a Hamiltonian , as provided in the evolution_problem."
		},
		{
			"id": "qiskit.algorithms.AmplificationProblem",
			"name": "qiskit.algorithms.AmplificationProblem",
			"type": "class",
			"description": "The amplification problem is the input to amplitude amplification algorithms, like Grover. This class contains all problem-specific information required to run an amplitude amplification algorithm. It minimally contains the Grover operator."
		},
		{
			"id": "qiskit.algorithms.state_fidelities.ComputeUncompute",
			"name": "qiskit.algorithms.state_fidelities.ComputeUncompute",
			"type": "class",
			"description": "This class leverages the sampler primitive to calculate the state fidelity of two quantum circuits following the compute-uncompute method (see \\[1] for further reference). The fidelity can be defined as the state overlap."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.MinimumEigensolver",
			"name": "qiskit.algorithms.minimum_eigensolvers.MinimumEigensolver",
			"type": "class",
			"description": "The minimum eigensolver interface. Algorithms that can compute a minimum eigenvalue for an operator may implement this interface to allow different algorithms to be used interchangeably. ## Methods ### compute\\_minimum\\_eigenvalue Computes the minimum eigenvalue."
		},
		{
			"id": "qiskit.opflow.list_ops",
			"name": "qiskit.opflow.list_ops",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSantiago",
			"name": "qiskit.providers.fake_provider.FakeSantiago",
			"type": "class",
			"description": "A fake Santiago backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeMumbaiFractionalCX",
			"name": "qiskit.providers.fake_provider.FakeMumbaiFractionalCX",
			"type": "class",
			"description": "A fake mumbai backend. The class qiskit.providers.fake_provider.fake_mumbai_v2.FakeMumbaiFractionalCX is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0. Use the qiskit.providers.basic\\_provider.GenericBackendV2 class instead."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBrooklynV2",
			"name": "qiskit.providers.fake_provider.FakeBrooklynV2",
			"type": "class",
			"description": "A fake Brooklyn V2 backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.providers.basicaer.BasicAerJob",
			"name": "qiskit.providers.basicaer.BasicAerJob",
			"type": "class",
			"description": "BasicAerJob class. The class qiskit.providers.basicaer.basicaerjob.BasicAerJob is deprecated as of qiskit 0.46.0. It will be removed in Qiskit 1.0.0."
		},
		{
			"id": "qiskit.algorithms.optimizers.optimizer_utils.LearningRate",
			"name": "qiskit.algorithms.optimizers.optimizer_utils.LearningRate",
			"type": "class",
			"description": "Represents a Learning Rate. Will be an attribute of GradientDescentState. Note that GradientDescent also has a learning rate. That learning rate can be a float, a list, an array, a function returning a generator and will be used to create a generator to be used during the optimization process."
		},
		{
			"id": "qiskit.opflow.gradients.Hessian",
			"name": "qiskit.opflow.gradients.Hessian",
			"type": "class",
			"description": "Deprecated: Compute the Hessian of an expected value. The class qiskit.opflow.gradients.hessian.Hessian is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.execute_function",
			"name": "qiskit.execute_function",
			"type": "module",
			"description": "Execute a list of qiskit.circuit.QuantumCircuit or qiskit.pulse.Schedule on a backend. The execution is asynchronous, and a handle to a job instance is returned. The function qiskit.execute_function.execute() is deprecated as of qiskit 0.46.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.opflow.primitive_ops.CircuitOp",
			"name": "qiskit.opflow.primitive_ops.CircuitOp",
			"type": "class",
			"description": "Deprecated: Class for Operators backed by Terra’s QuantumCircuit module. The class qiskit.opflow.primitive_ops.circuit_op.CircuitOp is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.providers.fake_provider.FakePerth",
			"name": "qiskit.providers.fake_provider.FakePerth",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.optimizers",
			"name": "qiskit.algorithms.optimizers",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.providers.fake_provider.FakeNairobi",
			"name": "qiskit.providers.fake_provider.FakeNairobi",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.optimizers.OptimizerResult",
			"name": "qiskit.algorithms.optimizers.OptimizerResult",
			"type": "class",
			"description": "The result of an optimization routine. ## Attributes ### fun The final value of the minimization. ### jac The final gradient of the minimization. ### nfev The total number of function evaluations. ### nit The total number of iterations. ### njev The total number of gradient evaluations."
		},
		{
			"id": "qiskit.algorithms.VarQRTE",
			"name": "qiskit.algorithms.VarQRTE",
			"type": "class",
			"description": ", lse_solver=None, num_timesteps=None, imag_part_tol=1e-07, num_instability_tol=1e-07)\" modifiers=\"class\"> Bases: VarQTE, RealTimeEvolver Variational Quantum Real Time Evolution algorithm. **Parameters** * **ansatz** (*QuantumCircuit*) – Ansatz to be used for variational time evolution."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers",
			"name": "qiskit.algorithms.minimum_eigensolvers",
			"type": "module",
			"description": ""
		},
		{
			"id": "qiskit.opflow.gradients.GradientBase",
			"name": "qiskit.opflow.gradients.GradientBase",
			"type": "class",
			"description": "Deprecated: Base class for first-order operator gradient. Convert an operator expression to the first-order gradient. The class qiskit.opflow.gradients.gradient_base.GradientBase is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.opflow.evolutions.MatrixEvolution",
			"name": "qiskit.opflow.evolutions.MatrixEvolution",
			"type": "class",
			"description": "Deprecated: Performs Evolution by classical matrix exponentiation, constructing a circuit with UnitaryGates or HamiltonianGates containing the exponentiation of the Operator. The class qiskit.opflow.evolutions.matrix_evolution.MatrixEvolution is deprecated as of qiskit-terra 0.24.0."
		},
		{
			"id": "qiskit.tools.jupyter",
			"name": "qiskit.tools.jupyter",
			"type": "module",
			"description": "qiskit.tools.jupyter A Collection of Jupyter magic functions and tools that extend the functionality of Qiskit."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeOslo",
			"name": "qiskit.providers.fake_provider.FakeOslo",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.evolutions.EvolutionFactory",
			"name": "qiskit.opflow.evolutions.EvolutionFactory",
			"type": "class",
			"description": "Deprecated: A factory class for convenient automatic selection of an Evolution algorithm based on the Operator to be converted. ## Methods ### build A factory method for convenient automatic selection of an Evolution algorithm based on the Operator to be converted."
		},
		{
			"id": "qiskit.algorithms.VQE",
			"name": "qiskit.algorithms.VQE",
			"type": "class",
			"description": "Deprecated: Variational Quantum Eigensolver algorithm. The VQE class has been superseded by the qiskit.algorithms.minimum_eigensolvers.VQE class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeBelemV2",
			"name": "qiskit.providers.fake_provider.FakeBelemV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.minimum_eigensolvers.SamplingVQE",
			"name": "qiskit.algorithms.minimum_eigensolvers.SamplingVQE",
			"type": "class",
			"description": "The Variational Quantum Eigensolver algorithm, optimized for diagonal Hamiltonians. VQE is a hybrid quantum-classical algorithm that uses a variational technique to find the minimum eigenvalue of a given diagonal Hamiltonian operator ."
		},
		{
			"id": "qiskit.providers.fake_provider.ConfigurableFakeBackend",
			"name": "qiskit.providers.fake_provider.ConfigurableFakeBackend",
			"type": "class",
			"description": "Configurable backend. Creates backend based on provided configuration. The class qiskit.providers.fake_provider.utils.configurable_backend.ConfigurableFakeBackend is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0. Use a suitable FakeBackend instead."
		},
		{
			"id": "qiskit.transpiler.passes.Unroller",
			"name": "qiskit.transpiler.passes.Unroller",
			"type": "class",
			"description": "Unroll a circuit to a given basis. Unroll (expand) non-basis, non-opaque instructions recursively to a desired basis, using decomposition rules defined for each instruction. Unroller initializer. The class qiskit.transpiler.passes.basis.unroller.Unroller is deprecated as of qiskit 0.45.0."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeWashington",
			"name": "qiskit.providers.fake_provider.FakeWashington",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.opflow.state_fns.CircuitStateFn",
			"name": "qiskit.opflow.state_fns.CircuitStateFn",
			"type": "class",
			"description": "Deprecated: A class for state functions and measurements which are defined by the action of a QuantumCircuit starting from |0⟩, and stored using Terra’s QuantumCircuit class. The class qiskit.opflow.state_fns.circuit_state_fn.CircuitStateFn is deprecated as of qiskit-terra 0.24.0."
		},
		{
			"id": "qiskit.utils.mitigation.CompleteMeasFitter",
			"name": "qiskit.utils.mitigation.CompleteMeasFitter",
			"type": "class",
			"description": "Deprecated: Measurement correction fitter for a full calibration Initialize a measurement calibration matrix from the results of running the circuits returned by measurement\\_calibration\\_circuits A wrapper for the tensored fitter This class is not a public API."
		},
		{
			"id": "qiskit.transpiler.passes.AQCSynthesisPlugin",
			"name": "qiskit.transpiler.passes.AQCSynthesisPlugin",
			"type": "class",
			"description": "An AQC-based Qiskit unitary synthesis plugin. This plugin is invoked by transpile() when the unitary_synthesis_method parameter is set to \"aqc\"."
		},
		{
			"id": "qiskit.algorithms.optimizers.ESCH",
			"name": "qiskit.algorithms.optimizers.ESCH",
			"type": "class",
			"description": "ESCH evolutionary optimizer. ESCH is an evolutionary algorithm for global optimization that supports bound constraints only. Specifically, it does not support nonlinear constraints. NLopt global optimizer, derivative-free."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSantiagoV2",
			"name": "qiskit.providers.fake_provider.FakeSantiagoV2",
			"type": "class",
			"description": "A fake Santiago backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.PhaseEstimation",
			"name": "qiskit.algorithms.PhaseEstimation",
			"type": "class",
			"description": "Run the Quantum Phase Estimation (QPE) algorithm. This runs QPE with a multi-qubit register for reading the phases \\[1] of input states. The algorithm takes as input a unitary and a state , which may be written where are eigenstates of ."
		},
		{
			"id": "qiskit.algorithms.gradients.LinCombSamplerGradient",
			"name": "qiskit.algorithms.gradients.LinCombSamplerGradient",
			"type": "class",
			"description": "Compute the gradients of the sampling probability. This method employs a linear combination of unitaries \\[1]."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeHanoi",
			"name": "qiskit.providers.fake_provider.FakeHanoi",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimationResult",
			"name": "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimationResult",
			"type": "class",
			"description": "The MaximumLikelihoodAmplitudeEstimation result object. ## Attributes ### circuit\\_results Return the circuit results. Can be a statevector or counts dictionary. ### confidence\\_interval Return the confidence interval for the amplitude (95% interval by default)."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeGeneva",
			"name": "qiskit.providers.fake_provider.FakeGeneva",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.algorithms.AlgorithmJob",
			"name": "qiskit.algorithms.AlgorithmJob",
			"type": "class",
			"description": "This empty class is introduced for typing purposes. **Parameters** **function** – a callable function to execute the job. ## Attributes ### version ## Methods ### backend Return the backend where this job was executed. **Return type** *Backend* ### cancel Attempt to cancel the job."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeJakarta",
			"name": "qiskit.providers.fake_provider.FakeJakarta",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.gradients.BaseEstimatorGradient",
			"name": "qiskit.algorithms.gradients.BaseEstimatorGradient",
			"type": "class",
			"description": "Base class for an EstimatorGradient to compute the gradients of the expectation value. **Parameters** * **estimator** (*BaseEstimator*) – The estimator used to compute the gradients. * **options** (*Options* *| None*) – Primitive backend runtime options used for circuit execution."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeManhattan",
			"name": "qiskit.providers.fake_provider.FakeManhattan",
			"type": "class",
			"description": "A fake Manhattan backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeGuadalupeV2",
			"name": "qiskit.providers.fake_provider.FakeGuadalupeV2",
			"type": "class",
			"description": "A fake 16 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.primitive_ops.MatrixOp",
			"name": "qiskit.opflow.primitive_ops.MatrixOp",
			"type": "class",
			"description": "Deprecated: Class for Operators represented by matrices, backed by Terra’s Operator module. The class qiskit.opflow.primitive_ops.matrix_op.MatrixOp is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release."
		},
		{
			"id": "qiskit.algorithms.optimizers.CG",
			"name": "qiskit.algorithms.optimizers.CG",
			"type": "class",
			"description": "Conjugate Gradient optimizer. CG is an algorithm for the numerical solution of systems of linear equations whose matrices are symmetric and positive-definite."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeSydney",
			"name": "qiskit.providers.fake_provider.FakeSydney",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit.algorithms.NumPyEigensolver",
			"name": "qiskit.algorithms.NumPyEigensolver",
			"type": "class",
			"description": "Deprecated: NumPy Eigensolver algorithm. The NumPyEigensolver class has been superseded by the qiskit.algorithms.eigensolvers.NumPyEigensolver class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeParisV2",
			"name": "qiskit.providers.fake_provider.FakeParisV2",
			"type": "class",
			"description": "A fake Paris backend. ``text 06 17 ↕ ↕ 00 ↔ 01 ↔ 04 ↔ 07 ↔ 10 ↔ 12 ↔ 15 ↔ 18 ↔ 20 ↔ 23 ↕ ↕ ↕ 02 13 24 ↕ ↕ ↕ 03 ↔ 05 ↔ 08 ↔ 11 ↔ 14 ↔ 16 ↔ 19 ↔ 22 ↔ 25 ↔ 26 ↕ ↕ 09 20 ` FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0."
		},
		{
			"id": "qiskit.algorithms.NumPyMinimumEigensolver",
			"name": "qiskit.algorithms.NumPyMinimumEigensolver",
			"type": "class",
			"description": "Deprecated: Numpy Minimum Eigensolver algorithm. The NumPyMinimumEigensolver class has been superseded by the qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver class. This class will be deprecated in a future release and subsequently removed after that."
		},
		{
			"id": "qiskit.opflow.list_ops.TensoredOp",
			"name": "qiskit.opflow.list_ops.TensoredOp",
			"type": "class",
			"description": "Deprecated: A class for lazily representing tensor products of Operators. Often Operators cannot be efficiently tensored to one another, but may be manipulated further so that they can be later."
		},
		{
			"id": "qiskit.providers.fake_provider.FakeQuitoV2",
			"name": "qiskit.providers.fake_provider.FakeQuitoV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. The class qiskit.providers.fake_provider.fake_backend.FakeBackendV2 is deprecated as of qiskit 0.46.0. It will be removed in qiskit 1.0."
		},
		{
			"id": "qiskit.opflow.primitive_ops.PauliOp",
			"name": "qiskit.opflow.primitive_ops.PauliOp",
			"type": "class",
			"description": "Deprecated: Class for Operators backed by Terra’s Pauli module. The class qiskit.opflow.primitive_ops.pauli_op.PauliOp is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow\\_migration."
		},
		{
			"id": "qiskit.transpiler.passes.SubstitutePi4Rotations",
			"name": "qiskit.transpiler.passes.SubstitutePi4Rotations",
			"type": "class",
			"description": "Convert single-qubit rotation gates RZGate, RXGate and RYGate, whose angles are integer multiples of into discrete sets of Clifford, TGate and TdgGate gates."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.ross_selinger_plugin.RossSelingerSynthesis",
			"name": "qiskit.transpiler.passes.synthesis.ross_selinger_plugin.RossSelingerSynthesis",
			"type": "class",
			"description": "A Ross-Selinger Qiskit unitary synthesis plugin. The algorithm is described in \\[1]. The source code (in Rust) is available at https://github.com/qiskit-community/rsgridsynth. This plugin is invoked by transpile() when the unitary_synthesis_method parameter is set to \"gridsynth\"."
		},
		{
			"id": "qiskit.transpiler.passes.synthesis.default_unitary_synth_plugin.DefaultUnitarySynthesis",
			"name": "qiskit.transpiler.passes.synthesis.default_unitary_synth_plugin.DefaultUnitarySynthesis",
			"type": "class",
			"description": "The default unitary synthesis plugin."
		},
		{
			"id": "QkTranspileLayout",
			"name": "QkTranspileLayout",
			"type": "module",
			"description": "Return the number of qubits in the input circuit to the transpiler. #### Safety Behavior is undefined if layout is not a valid, non-null pointer to a QkTranspileLayout. **Parameters** * **layout** – A pointer to the QkTranspileLayout. **Returns** The number of input qubits"
		},
		{
			"id": "QkComplex64",
			"name": "QkComplex64",
			"type": "module",
			"description": "A complex double. See also qk_complex64_to_native and qk_complex64_from_native to convert this struct to (or from) a compiler-native complex number representation. #### double re #### double im"
		},
		{
			"id": "QkCircuit",
			"name": "QkCircuit",
			"type": "module",
			"description": "An individual operation count represented by the operation name and the number of instances in the circuit. #### const char \\*name A nul terminated string representing the operation name #### size\\_t count The number of instances of this operation in the circuit"
		},
		{
			"id": "QkBitTerm",
			"name": "QkBitTerm",
			"type": "module",
			"description": "Get the label for a bit term. #### Example ``c QkBitTerm bit_term = QkBitTerm_Y; // cast the uint8_t to char char label = qk_bitterm_label(bit_term); ` #### Safety The behavior is undefined if bit_term is not a valid uint8_t value of a QkBitTerm. **Parameters** * **bit\\_term** – The bit term."
		},
		{
			"id": "QkClassicalRegister",
			"name": "QkClassicalRegister",
			"type": "module",
			"description": "Free a classical register. #### Example ``c QkClassicalRegister *cr = qk_classical_register_new(1024, \"creg\"); qk_classical_register_free(cr); ` #### Safety Behavior is undefined if reg is not either null or a valid pointer to a QkClassicalRegister`."
		},
		{
			"id": "QkQuantumRegister",
			"name": "QkQuantumRegister",
			"type": "module",
			"description": "Construct a new owning quantum register with a given number of qubits and name #### Example ``c QkQuantumRegister *qr = qk_quantum_register_new(5, \"five_qubits\"); ` #### Safety The name` parameter must be a pointer to memory that contains a valid nul terminator at the end of the string."
		},
		{
			"id": "QkTarget",
			"name": "QkTarget",
			"type": "module",
			"description": "Construct a new QkTarget with the given number of qubits."
		},
		{
			"id": "QkTargetEntry",
			"name": "QkTargetEntry",
			"type": "module",
			"description": "Creates an entry to the QkTarget based on a QkGate instance. #### Example ``c QkTargetEntry *entry = qk_target_entry_new(QkGate_H); ` **Parameters** * **operation** – The QkGate whose properties this target entry defines."
		},
		{
			"id": "QkTranspiler",
			"name": "QkTranspiler",
			"type": "module",
			"description": "The container result object from qk_transpile When the transpiler successfully compiles a quantum circuit for a given target it returns the transpiled circuit and the layout."
		},
		{
			"id": "QkObs",
			"name": "QkObs",
			"type": "module",
			"description": "Construct the zero observable (without any terms). #### Example ``c QkObs *zero = qk_obs_zero(100); `` **Parameters** * **num\\_qubits** – The number of qubits the observable is defined on. **Returns** A pointer to the created observable."
		},
		{
			"id": "QkSabreLayoutOptions",
			"name": "QkSabreLayoutOptions",
			"type": "module",
			"description": "The options for running qk_transpiler_pass_standalone_sabre_layout. This struct is used as an input to control the behavior of the layout and routing algorithms."
		},
		{
			"id": "Transpiler Passes",
			"name": "Transpiler Passes",
			"type": "module",
			"description": "Run the BasisTranslator transpiler pass on a circuit. The BasisTranslator transpiler pass translates gates to a target basis by searching for a set of translations from the standard EquivalenceLibrary."
		},
		{
			"id": "QkObsTerm",
			"name": "QkObsTerm",
			"type": "module",
			"description": "A term in a QkObs. This contains the coefficient (coeff), the number of qubits of the observable (num_qubits) and pointers to the bit_terms and indices arrays, which have length len. It’s the responsibility of the user that the data is coherent, see also the below section on safety."
		},
		{
			"id": "QkVF2LayoutResult",
			"name": "QkVF2LayoutResult",
			"type": "module",
			"description": "Check whether a result was found. #### Safety Behavior is undefined if layout is not a valid, non-null pointer to a QkVF2LayoutResult. **Parameters** * **layout** – a pointer to the layout **Returns** true if the qk_transpiler_pass_standalone_vf2_layout() run found a layout"
		},
		{
			"id": "QkExitCode",
			"name": "QkExitCode",
			"type": "module",
			"description": "``c enum QkExitCode `` Function exit codes."
		},
		{
			"id": "Versioning",
			"name": "Versioning",
			"type": "module",
			"description": "Qiskit’s version can be queried using a set of compiler macros."
		},
		{
			"id": "VF2 compiler-pass objects",
			"name": "VF2 compiler-pass objects",
			"type": "module",
			"description": "Create a new configuration for the VF2 passes that runs everything completely unbounded. Call qk_vf2_layout_configuration_free with the return value to free the memory when done. **Returns** A pointer to the configuration."
		},
		{
			"id": "Cirucit Library",
			"name": "Cirucit Library",
			"type": "module",
			"description": "Generate a Quantum Volume model circuit The model circuits are random instances of circuits used to measure the Quantum Volume metric, as introduced in \\[1]. The model circuits consist of layers of Haar random elements of SU(4) applied between corresponding pairs of qubits in a random bipartition."
		},
		{
			"id": "QkNeighbors",
			"name": "QkNeighbors",
			"type": "module",
			"description": "An adjacency-list representation of a coupling graph. This is initialized by qk_neighbors_from_target. This object is read-only from C. To satisfy the safety guarantees of qk_neighbors_clear, you must not overwrite any data initialized by qk_neighbors_from_target, including any pointed-to data."
		},
		{
			"id": "QkDag",
			"name": "QkDag",
			"type": "module",
			"description": "The type of node in a QkDag. Operation nodes represent an applied instruction. The rest of the nodes are considered “wire” nodes and represent the endpoints of the DAG’s data dependency chains. *Values:* #### enumerator QkDagNodeType\\_Operation Operation node."
		},
		{
			"id": "qiskit_addon_aqc_tensor.ansatz_generation",
			"name": "qiskit_addon_aqc_tensor.ansatz_generation",
			"type": "module",
			"description": "Generate an ansatz from the two-qubit connectivity structure of a circuit. See the explanatatory material for motivation. **Parameters** * **qc** (QuantumCircuit\")) – A circuit, which is assumed to be unitary. Barriers are ignored."
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.quimb.QuimbSimulator",
			"name": "qiskit_addon_aqc_tensor.simulation.quimb.QuimbSimulator",
			"type": "class",
			"description": "Settings for Quimb simulator. This is compatible with both Quimb’s MPS simulator, which eagerly contracts gates by default, as well as Quimb’s standard method for circuit simulation."
		},
		{
			"id": "qiskit_addon_aqc_tensor.ansatz_generation.AnsatzBlock",
			"name": "qiskit_addon_aqc_tensor.ansatz_generation.AnsatzBlock",
			"type": "class",
			"description": "Ansatz block. This is the base class of all blocks returned by generate_ansatz_from_circuit(). Initialize the ansatz block. **Parameters** **params** (Sequence\")\\[Parameter\")]) – Sequence of parameters. ## Attributes ### base\\_class Get the base class of this instruction."
		},
		{
			"id": "qiskit_addon_aqc_tensor.ansatz_generation.OneQubitAnsatzBlock",
			"name": "qiskit_addon_aqc_tensor.ansatz_generation.OneQubitAnsatzBlock",
			"type": "class",
			"description": "One-qubit ansatz block. Initialize the ansatz block. **Parameters** **params** (Sequence\")\\[Parameter\")]) – Sequence of parameters. ## Attributes ### ansatz\\_num\\_qubits ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.quimb.QiskitQuimbConversionContext",
			"name": "qiskit_addon_aqc_tensor.simulation.quimb.QiskitQuimbConversionContext",
			"type": "class",
			"description": "Contains information about Qiskit-to-Quimb conversion, necessary to recover Qiskit parameters. Initialize. Should not be called by users. **Parameters** **mapping** (*list*\")*\\*[*tuple*\")*\\*[*int*\")*,* *float*\")*,* *float*\")*]]*)"
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.aer.QiskitAerSimulationSettings",
			"name": "qiskit_addon_aqc_tensor.simulation.aer.QiskitAerSimulationSettings",
			"type": "class",
			"description": "Qiskit Aer simulator settings."
		},
		{
			"id": "qiskit_addon_aqc_tensor.ansatz_generation.KAK",
			"name": "qiskit_addon_aqc_tensor.ansatz_generation.KAK",
			"type": "class",
			"description": "Two-qubit ansatz block based on the KAK decomposition. !Circuit diagram output by the previous code. The above KAK block is equivalent to the following circuit: !Circuit diagram output by the previous code. Initialize the ansatz block."
		},
		{
			"id": "qiskit_addon_aqc_tensor.ansatz_generation.ZXZ",
			"name": "qiskit_addon_aqc_tensor.ansatz_generation.ZXZ",
			"type": "class",
			"description": "One-qubit ansatz block based on the ZXZ decomposition. !Circuit diagram output by the previous code. The above ZXZ block is equivalent to the following circuit: !Circuit diagram output by the previous code. Initialize the ansatz block."
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation",
			"name": "qiskit_addon_aqc_tensor.simulation",
			"type": "module",
			"description": "Create a tensor-network state by simulating a quantum circuit. The type of tensor-network state will correspond to the type of the settings object. For instance, a QiskitAerSimulationSettings will result in this function returning a QiskitAerMPS."
		},
		{
			"id": "qiskit_addon_aqc_tensor.ansatz_generation.TwoQubitAnsatzBlock",
			"name": "qiskit_addon_aqc_tensor.ansatz_generation.TwoQubitAnsatzBlock",
			"type": "class",
			"description": "Two-qubit ansatz block. Initialize the ansatz block. **Parameters** **params** (Sequence\")\\[Parameter\")]) – Sequence of parameters. ## Attributes ### ansatz\\_num\\_qubits ### base\\_class Get the base class of this instruction. This is guaranteed to be in the inheritance tree of self."
		},
		{
			"id": "qiskit_addon_aqc_tensor.objective",
			"name": "qiskit_addon_aqc_tensor.objective",
			"type": "module",
			"description": "Simplest possible objective function for use with AQC-Tensor. Its definition is given by Eq."
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.quimb",
			"name": "qiskit_addon_aqc_tensor.simulation.quimb",
			"type": "module",
			"description": "Return True is qiskit-quimb is installed, False otherwise. **Return type** bool\")"
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.aer.QiskitAerMPS",
			"name": "qiskit_addon_aqc_tensor.simulation.aer.QiskitAerMPS",
			"type": "class",
			"description": "Qiskit Aer representation of a matrix-product state. This form of a matrix-product state was introduced in the original time-evolving block decimation (TEBD) paper, https://arxiv.org/abs/quant-ph/0301063. See Sec."
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.aer",
			"name": "qiskit_addon_aqc_tensor.simulation.aer",
			"type": "module",
			"description": "Return True is qiskit-aer is installed, False otherwise. **Return type** bool\")"
		},
		{
			"id": "qiskit_addon_aqc_tensor.simulation.quimb.QuimbCircuitFactory",
			"name": "qiskit_addon_aqc_tensor.simulation.quimb.QuimbCircuitFactory",
			"type": "class",
			"description": "Quimb circuit factory."
		},
		{
			"id": "qiskit_addon_obp.utils.metadata",
			"name": "qiskit_addon_obp.utils.metadata",
			"type": "module",
			"description": "qiskit_addon_obp.utils.metadata Container classes for holding backpropagation metadata."
		},
		{
			"id": "qiskit_addon_obp.utils.noise.PauliLindbladErrorInstruction",
			"name": "qiskit_addon_obp.utils.noise.PauliLindbladErrorInstruction",
			"type": "class",
			"description": "A lightweight wrapper around a PauliLindbladError. Initializes a circuit instruction with a Pauli-Lindblad error. **Parameters** * **ple** (*PauliLindbladError*) – the Pauli-Lindblad error to include. * **index** – an optional index of this error instruction."
		},
		{
			"id": "qiskit_addon_obp.utils.simplify",
			"name": "qiskit_addon_obp.utils.simplify",
			"type": "module",
			"description": "A class for storing the constants that determine how large an operator may grow. Backpropagation will stop if either of the following conditions is met: * The number of Pauli terms across all of the observables exceeds max_paulis."
		},
		{
			"id": "qiskit_addon_obp.utils.visualization",
			"name": "qiskit_addon_obp.utils.visualization",
			"type": "module",
			"description": "Plot the accumulated error. This method populates the provided figure axes with a line-plot of the OBPMetadata.accumulated_error(). Below is an example where we plot some metadata which exists within our context."
		},
		{
			"id": "qiskit_addon_obp.utils.metadata.OBPMetadata",
			"name": "qiskit_addon_obp.utils.metadata.OBPMetadata",
			"type": "class",
			"description": "A container for metadata generated during the backpropagate() method."
		},
		{
			"id": "qiskit_addon_obp.utils.metadata.SliceMetadata",
			"name": "qiskit_addon_obp.utils.metadata.SliceMetadata",
			"type": "class",
			"description": "A container for metadata generated during the backpropagation of a single slice."
		},
		{
			"id": "qiskit_addon_obp",
			"name": "qiskit_addon_obp",
			"type": "module",
			"description": "Backpropagate slices of quantum circuit operations onto the provided observables. This function takes a (list of) observable(s) and backpropagates the provided quantum circuit slices **in reverse order** onto the observable(s) until one of the stopping criteria is reached."
		},
		{
			"id": "qiskit_addon_obp.utils.operations",
			"name": "qiskit_addon_obp.utils.operations",
			"type": "module",
			"description": "Apply the operator op2 to the operator op1. These operators do not necessarily need to act on the same number of qubits, as they are assumed to act on a larger system. The position in the system of each operator is defined by the corresponding qargs."
		},
		{
			"id": "qiskit_addon_obp.utils.truncating",
			"name": "qiskit_addon_obp.utils.truncating",
			"type": "module",
			"description": ", max_error_total=0.0, p_norm=1, tol=1e-08)\" modifiers=\"class\"> Bases: object\") A class for storing the constants that determine the truncation error budget. Refer to the how-to guide for a detailed discussion on truncating operator terms during backpropagation and bounding the incurred error."
		},
		{
			"id": "qiskit_addon_obp.utils.noise",
			"name": "qiskit_addon_obp.utils.noise",
			"type": "module",
			"description": "qiskit_addon_obp.utils.noise Utilities for noise operators."
		},
		{
			"id": "qiskit_ibm_runtime.debug_tools",
			"name": "qiskit_ibm_runtime.debug_tools",
			"type": "module",
			"description": "qiskit_ibm_runtime.debug_tools The tools for debugging and analyzing qiskit-ibm-runtime jobs."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeManhattanV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeManhattanV2",
			"type": "class",
			"description": "A fake Manhattan backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeProviderForBackendV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeProviderForBackendV2",
			"type": "class",
			"description": "Fake provider containing fake V2 backends. Only filtering backends by name is implemented. This class contains all fake V2 backends available in the qiskit_ibm_runtime.fake_provider. ## Methods ### backend Filter backends in provider by name."
		},
		{
			"id": "qiskit_ibm_runtime",
			"name": "qiskit_ibm_runtime",
			"type": "module",
			"description": "qiskit_ibm_runtime Modules related to Qiskit Runtime IBM Client. Qiskit Runtime is a new architecture that streamlines computations requiring many iterations. These experiments will execute significantly faster within its improved hybrid quantum/classical process."
		},
		{
			"id": "qiskit_ibm_runtime.EstimatorV2",
			"name": "qiskit_ibm_runtime.EstimatorV2",
			"type": "class",
			"description": "Class for interacting with Qiskit Runtime Estimator primitive service. Qiskit Runtime Estimator primitive service estimates expectation values of quantum circuits and observables. The run() can be used to submit circuits, observables, and parameters to the Estimator primitive."
		},
		{
			"id": "qiskit_ibm_runtime.debug_tools.NeatPubResult",
			"name": "qiskit_ibm_runtime.debug_tools.NeatPubResult",
			"type": "class",
			"description": "A class to store the PUB results of Neat. It allows performing mathematical operations (+, -, *, /, abs, and **) with other objects of type NeatPubResultLike and with scalars. **Parameters** **vals** (*ArrayLike*) – The values in this NeatPubResult. ## Attributes ### vals The values in this result."
		},
		{
			"id": "qiskit_ibm_runtime.Batch",
			"name": "qiskit_ibm_runtime.Batch",
			"type": "class",
			"description": "Class for running jobs in batch execution mode. The batch mode is designed to efficiently perform experiments that comprise multiple independent jobs. **Using the batch mode provides the following benefits:** * The jobs’ classical computation, such as compilation, is run in parallel."
		},
		{
			"id": "qiskit_ibm_runtime.visualization.draw_layer_errors_swarm",
			"name": "qiskit_ibm_runtime.visualization.draw_layer_errors_swarm",
			"type": "function",
			"description": "Draw a swarm plot for the given list of layer errors. This function plots the rates of each of the given layer errors along a vertical axes, offsetting the rates along the x axis to minimize the overlap between the markers."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeAuckland",
			"name": "qiskit_ibm_runtime.fake_provider.FakeAuckland",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.noise_learner",
			"name": "qiskit_ibm_runtime.noise_learner",
			"type": "module",
			"description": "qiskit_ibm_runtime.noise_learner.NoiseLearner The tools to characterize the noise processes affecting the gates in noisy quantum circuits."
		},
		{
			"id": "qiskit_ibm_runtime.visualization.draw_circuit_schedule_timing",
			"name": "qiskit_ibm_runtime.visualization.draw_circuit_schedule_timing",
			"type": "function",
			"description": "Draw a circuit schedule timing for CircuitSchedule. **Parameters** * **circuit\\_schedule** (*str | CircuitSchedule*) – The circuit schedule as a string as returned from the compiler or a CircuitSchedule object."
		},
		{
			"id": "qiskit_ibm_runtime.utils.noise_learner_result.PauliLindbladError",
			"name": "qiskit_ibm_runtime.utils.noise_learner_result.PauliLindbladError",
			"type": "class",
			"description": "A Pauli error channel generated by a Pauli Lindblad dissipators. This operator represents an N-qubit quantum error channel generated by Pauli Lindblad dissipators , where are N-qubit Pauli operators."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes",
			"name": "qiskit_ibm_runtime.transpiler.passes",
			"type": "module",
			"description": "qiskit_ibm_runtime.transpiler.passes A collection of transpiler passes. Refer to /guides/transpile to learn more about transpilation and passes."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span.DoubleSliceSpan",
			"name": "qiskit_ibm_runtime.execution_span.DoubleSliceSpan",
			"type": "class",
			"description": "An ExecutionSpan for data stored in a sliceable format. This type of execution span references pub result data by assuming that it is a sliceable portion of the data where the shots are the outermost slice and the rest of the data is flattened."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDynamicalDecoupling",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDynamicalDecoupling",
			"type": "class",
			"description": "Dynamical decoupling insertion pass for IBM dynamic circuit backends. This pass works on a scheduled, physical circuit. It scans the circuit for idle periods of time (i.e. those containing delay instructions) and inserts a DD sequence of gates in those spots."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling.BlockBasePadder",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling.BlockBasePadder",
			"type": "class",
			"description": "The base class of padding pass. This pass requires one of scheduling passes to be executed before itself. Since there are multiple scheduling strategies, the selection of scheduling pass is left in the hands of the pass manager designer."
		},
		{
			"id": "qiskit_ibm_runtime.options.LayerNoiseLearningOptions",
			"name": "qiskit_ibm_runtime.options.LayerNoiseLearningOptions",
			"type": "class",
			"description": "Options for learning layer noise. This is only used by V2 Estimator. These options are only used when the resilience level or options specify a technique that requires layer noise learning."
		},
		{
			"id": "qiskit_ibm_runtime.models",
			"name": "qiskit_ibm_runtime.models",
			"type": "module",
			"description": "qiskit_ibm_runtime.models Qiskit schema-conformant objects used by the backends and providers."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling.ALAPScheduleAnalysis",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling.ALAPScheduleAnalysis",
			"type": "class",
			"description": "Dynamic circuits as-late-as-possible (ALAP) scheduling analysis pass. This is a scheduler designed to work for the unique scheduling constraints of the dynamic circuits backends due to the limitations imposed by hardware."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span",
			"name": "qiskit_ibm_runtime.execution_span",
			"type": "module",
			"description": "qiskit_ibm_runtime.execution_span"
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeRomeV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeRomeV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDelay",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDelay",
			"type": "class",
			"description": "Padding idle time with Delay instructions. Consecutive delays will be merged in the output of this pass."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeKyoto",
			"name": "qiskit_ibm_runtime.fake_provider.FakeKyoto",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakePrague",
			"name": "qiskit_ibm_runtime.fake_provider.FakePrague",
			"type": "class",
			"description": "A fake 33 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.options.ExecutionOptionsV2",
			"name": "qiskit_ibm_runtime.options.ExecutionOptionsV2",
			"type": "class",
			"description": "Execution options for V2 primitives. ## Attributes **Parameters** * **init\\_qubits** (*UnsetType | bool*) * **rep\\_delay** (*UnsetType | float*) ### init\\_qubits Whether to reset the qubits to the ground state for each shot. Default is True. ### rep\\_delay The repetition delay."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeKolkataV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeKolkataV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.models.BackendConfiguration",
			"name": "qiskit_ibm_runtime.models.BackendConfiguration",
			"type": "class",
			"description": "Backwards compat shim representing an abstract backend configuration."
		},
		{
			"id": "qiskit_ibm_runtime.models.UchannelLO",
			"name": "qiskit_ibm_runtime.models.UchannelLO",
			"type": "class",
			"description": "Class representing a U Channel LO ### q Qubit that scale corresponds too. ### scale Scale factor for qubit frequency. Initialize a UchannelLOSchema object **Parameters** * **q** (*int*) – Qubit that scale corresponds too. Must be >= 0. * **scale** (*complex*) – Scale factor for qubit frequency."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSingaporeV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSingaporeV2",
			"type": "class",
			"description": "A fake Singapore backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeGeneva",
			"name": "qiskit_ibm_runtime.fake_provider.FakeGeneva",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling.ASAPScheduleAnalysis",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling.ASAPScheduleAnalysis",
			"type": "class",
			"description": "Dynamic circuits as-soon-as-possible (ASAP) scheduling analysis pass. This is a scheduler designed to work for the unique scheduling constraints of the dynamic circuits backends due to the limitations imposed by hardware."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeOslo",
			"name": "qiskit_ibm_runtime.fake_provider.FakeOslo",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.debug_tools.Neat",
			"name": "qiskit_ibm_runtime.debug_tools.Neat",
			"type": "class",
			"description": "A class to help understand the expected performance of estimator jobs. The “Noisy Estimator Analyzer Tool” (or “NEAT”) is a convenience tool that users of the Estimator primitive can employ to analyze and predict the performance of their queries."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeKyiv",
			"name": "qiskit_ibm_runtime.fake_provider.FakeKyiv",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeParisV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeParisV2",
			"type": "class",
			"description": "A fake Paris backend. ``text 06 17 ↕ ↕ 00 ↔ 01 ↔ 04 ↔ 07 ↔ 10 ↔ 12 ↔ 15 ↔ 18 ↔ 21 ↔ 23 ↕ ↕ ↕ 02 13 24 ↕ ↕ ↕ 03 ↔ 05 ↔ 08 ↔ 11 ↔ 14 ↔ 16 ↔ 19 ↔ 22 ↔ 25 ↔ 26 ↕ ↕ 09 20 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakePoughkeepsieV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakePoughkeepsieV2",
			"type": "class",
			"description": "A fake Poughkeepsie backend. FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.visualization.draw_layer_error_map",
			"name": "qiskit_ibm_runtime.visualization.draw_layer_error_map",
			"type": "function",
			"description": "Draw a map view of a LayerError. **Parameters** * **layer\\_error** (*LayerError*) – The LayerError to draw. * **embedding** (*Embedding | BackendV2*) – An Embedding object containing the coordinates and coupling map to draw the layer error on, or a backend to generate an Embedding for."
		},
		{
			"id": "qiskit_ibm_runtime.IBMBackend",
			"name": "qiskit_ibm_runtime.IBMBackend",
			"type": "class",
			"description": "Backend class interfacing with an IBM Quantum backend. * You should not instantiate the IBMBackend class directly. Instead, use the methods provided by an QiskitRuntimeService instance to retrieve and handle backends. This class represents an IBM Quantum backend."
		},
		{
			"id": "qiskit_ibm_runtime.options.SamplerExecutionOptionsV2",
			"name": "qiskit_ibm_runtime.options.SamplerExecutionOptionsV2",
			"type": "class",
			"description": "Extension of ExecutionOptionsV2 for the sampler primitive."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMumbaiV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMumbaiV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling.DynamicCircuitInstructionDurations",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling.DynamicCircuitInstructionDurations",
			"type": "class",
			"description": "For dynamic circuits the IBM Qiskit backend currently reports instruction durations that differ compared with those required for the legacy Qobj-based path. For now we use this class to report updated InstructionDurations."
		},
		{
			"id": "qiskit_ibm_runtime.options.EnvironmentOptions",
			"name": "qiskit_ibm_runtime.options.EnvironmentOptions",
			"type": "class",
			"description": "Options related to the execution environment. ## Attributes **Parameters** * **log\\_level** (*Literal\\['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']*) * **job\\_tags** (*list | None*) * **private** (*bool | None*) ### job\\_tags Tags to be assigned to the job."
		},
		{
			"id": "qiskit_ibm_runtime.models.Nduv",
			"name": "qiskit_ibm_runtime.models.Nduv",
			"type": "class",
			"description": "Class representing name-date-unit-value ### date date. ### name name. ### unit unit. ### value value."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBoeblingenV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBoeblingenV2",
			"type": "class",
			"description": "A fake Boeblingen V2 backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSydneyV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSydneyV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.Estimator",
			"name": "qiskit_ibm_runtime.Estimator",
			"type": "attribute",
			"description": "alias of EstimatorV2"
		},
		{
			"id": "qiskit_ibm_runtime.visualization.draw_execution_spans",
			"name": "qiskit_ibm_runtime.visualization.draw_execution_spans",
			"type": "function",
			"description": "Draw one or more ExecutionSpans on a bar plot. **Parameters** * **spans** (*ExecutionSpans*) – One or more ExecutionSpans. * **names** (*str | Iterable\\[str] | None*) – Name or names to assign to respective spans."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeJohannesburgV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeJohannesburgV2",
			"type": "class",
			"description": "A fake Johannesburg V2 backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeQuebec",
			"name": "qiskit_ibm_runtime.fake_provider.FakeQuebec",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.RuntimeJobV2",
			"name": "qiskit_ibm_runtime.RuntimeJobV2",
			"type": "class",
			"description": "Representation of a runtime V2 primitive execution. RuntimeJob constructor. **Parameters** * **backend** (*Backend*\")) – The backend instance used to run this job. * **api\\_client** (*RuntimeClient*) – Object for connecting to the server. * **job\\_id** (*str*) – Job ID."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCusco",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCusco",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.SamplerV2",
			"name": "qiskit_ibm_runtime.SamplerV2",
			"type": "class",
			"description": "Class for interacting with Qiskit Runtime Sampler primitive service. This class supports version 2 of the Sampler interface, which uses different input and output formats than version 1. Qiskit Runtime Sampler primitive returns the sampled result according to the specified output type."
		},
		{
			"id": "qiskit_ibm_runtime.utils.noise_learner_result.LayerError",
			"name": "qiskit_ibm_runtime.utils.noise_learner_result.LayerError",
			"type": "class",
			"description": "The error channel (in Pauli-Lindblad format) of a single layer of instructions. **Parameters** * **circuit** (*QuantumCircuit*) – A circuit whose noise has been learnt. * **qubits** (*Sequence\\[int]*) – The labels of the qubits in the circuit."
		},
		{
			"id": "qiskit_ibm_runtime.options",
			"name": "qiskit_ibm_runtime.options",
			"type": "module",
			"description": "qiskit_ibm_runtime.options Options that can be passed to the Qiskit Runtime primitives."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.ConvertIdToDelay",
			"name": "qiskit_ibm_runtime.transpiler.passes.ConvertIdToDelay",
			"type": "class",
			"description": "Convert qiskit.circuit.library.standard_gates.IGate to a delay of the corresponding length. Convert qiskit.circuit.library.IGate\") to a Convert qiskit.circuit.Delay\"). **Parameters** * **duration** – Duration of the delay to replace the identity gate with."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMelbourneV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMelbourneV2",
			"type": "class",
			"description": "A fake 15 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCasablancaV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCasablancaV2",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeFez",
			"name": "qiskit_ibm_runtime.fake_provider.FakeFez",
			"type": "class",
			"description": "A fake 156 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.options.SamplerOptions",
			"name": "qiskit_ibm_runtime.options.SamplerOptions",
			"type": "class",
			"description": ", simulator=, default_shots=Unset, dynamical_decoupling=, execution=, twirling=, experimental=Unset)\" modifiers=\"class\"> Bases: OptionsV2 Options for V2 Sampler."
		},
		{
			"id": "qiskit_ibm_runtime.models.BackendStatus",
			"name": "qiskit_ibm_runtime.models.BackendStatus",
			"type": "class",
			"description": "Class representing Backend Status."
		},
		{
			"id": "qiskit_ibm_runtime.models.GateConfig",
			"name": "qiskit_ibm_runtime.models.GateConfig",
			"type": "class",
			"description": "Class representing a Gate Configuration ### name the gate name as it will be referred to in OpenQASM. ### parameters variable names for the gate parameters (if any). ### qasm\\_def definition of this gate in terms of OpenQASM 2 primitives U and CX."
		},
		{
			"id": "qiskit_ibm_runtime.RuntimeEncoder",
			"name": "qiskit_ibm_runtime.RuntimeEncoder",
			"type": "class",
			"description": "JSON Encoder used by runtime service. Constructor for JSONEncoder, with sensible defaults. If skipkeys is false, then it is a TypeError to attempt encoding of keys that are not str, int, float or None. If skipkeys is True, such items are simply skipped."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.ConvertToMidCircuitMeasure",
			"name": "qiskit_ibm_runtime.transpiler.passes.ConvertToMidCircuitMeasure",
			"type": "class",
			"description": "This pass replaces terminal measures in the middle of the circuit with MidCircuitMeasure instructions. Transpiler pass that replaces terminal measure instructions in non-terminal locations with MidCircuitMeasure instructions."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.ConvertISAToClifford",
			"name": "qiskit_ibm_runtime.transpiler.passes.ConvertISAToClifford",
			"type": "class",
			"description": "Convert the gates of an ISA circuit to Clifford gates. ISA circuits only contain Clifford gates from a restricted set or qiskit.circuit.library.RZGate\")s by arbitrary angles."
		},
		{
			"id": "qiskit_ibm_runtime.Sampler",
			"name": "qiskit_ibm_runtime.Sampler",
			"type": "attribute",
			"description": "alias of SamplerV2"
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBogotaV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBogotaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeRochesterV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeRochesterV2",
			"type": "class",
			"description": "A fake Rochester backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeLondonV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeLondonV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeHanoiV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeHanoiV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeOurenseV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeOurenseV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSherbrooke",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSherbrooke",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.FoldRzzAngle",
			"name": "qiskit_ibm_runtime.transpiler.passes.FoldRzzAngle",
			"type": "class",
			"description": "Fold Rzz gate angle into calibrated range of 0-pi/2 with local gate tweaks. In the IBM Quantum ISA, the instruction Rzz(theta) has valid “theta” value of \\[0, pi/2] and any instruction outside this range becomes a non-ISA operation for the quantum backend."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeTorontoV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeTorontoV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span.SliceSpan",
			"name": "qiskit_ibm_runtime.execution_span.SliceSpan",
			"type": "class",
			"description": "An ExecutionSpan for data stored in a sliceable format. This type of execution span references pub result data by assuming that it is a sliceable portion of the (row major) flattened data."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeManilaV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeManilaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.options.ResilienceOptionsV2",
			"name": "qiskit_ibm_runtime.options.ResilienceOptionsV2",
			"type": "class",
			"description": ", zne_mitigation=Unset, zne=, pec_mitigation=Unset, pec=, layer_noise_learning=, layer_noise_model=Unset)\" modifiers=\"class\"> Bases: object Resilience options for V2 Estimator."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCairoV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCairoV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeValenciaV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeValenciaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCambridgeV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCambridgeV2",
			"type": "class",
			"description": "A fake Cambridge backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 06 ↕ ↕ 07 ↔ 08 ↔ 09 ↔ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↔ 15 ↕ ↕ ↕ 16 17 18 ↕ ↕ ↕ 19 ↔ 20 ↔ 21 ↔ 22 ↔ 23 ↔ 24 ↔ 25 ↔ 26 ↔ 27 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.options.ZneOptions",
			"name": "qiskit_ibm_runtime.options.ZneOptions",
			"type": "class",
			"description": "Zero noise extrapolation mitigation options. This is only used by the V2 Estimator. Any V2 estimator is guaranteed to return data fields called evs and stds that report the desired expectation value estimates and errors, respectively."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span.ShapeType",
			"name": "qiskit_ibm_runtime.execution_span.ShapeType",
			"type": "attribute",
			"description": "alias of tuple\\[int, …]"
		},
		{
			"id": "qiskit_ibm_runtime.options.EstimatorOptions",
			"name": "qiskit_ibm_runtime.options.EstimatorOptions",
			"type": "class",
			"description": ", simulator=, default_precision=Unset, default_shots=Unset, resilience_level=Unset, seed_estimator=Unset, dynamical_decoupling=, resilience=, execution=, twirling=, experimental=Unset)\" modifiers=\"class\"> Bases: OptionsV2 Options for V2 Estimator."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakePeekskill",
			"name": "qiskit_ibm_runtime.fake_provider.FakePeekskill",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.noise_learner.NoiseLearner",
			"name": "qiskit_ibm_runtime.noise_learner.NoiseLearner",
			"type": "class",
			"description": "Class for executing noise learning experiments. The noise learner class allows characterizing the noise processes affecting the gates in one or more circuits of interest, based on the Pauli-Lindblad noise model described in \\[1]."
		},
		{
			"id": "qiskit_ibm_runtime.RuntimeDecoder",
			"name": "qiskit_ibm_runtime.RuntimeDecoder",
			"type": "class",
			"description": "JSON Decoder used by runtime service. object_hook, if specified, will be called with the result of every JSON object decoded and its return value will be used in place of the given dict. This can be used to provide custom deserializations (e.g. to support JSON-RPC class hinting)."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeNairobiV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeNairobiV2",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBurlingtonV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBurlingtonV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeQuitoV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeQuitoV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeFractionalBackend",
			"name": "qiskit_ibm_runtime.fake_provider.FakeFractionalBackend",
			"type": "class",
			"description": "A fake 5 qubit backend with dynamic and fractional feature modeled based on FakeLima. This backend include following features. * Fractional gates (rx, rzx) in addition to the standard basis gates. * Control flow operations (if\\_else, while\\_loop)."
		},
		{
			"id": "qiskit_ibm_runtime.debug_tools.NeatResult",
			"name": "qiskit_ibm_runtime.debug_tools.NeatResult",
			"type": "class",
			"description": "A container for multiple NeatPubResult objects. **Parameters** **pub\\_results** (*Iterable\\*[*NeatPubResult**]*) – An iterable of NeatPubResult objects. ## Methods ### \\_\\_getitem\\_\\_ **Parameters** **index** (*int*) **Return type** *NeatPubResult* ### \\_\\_len\\_\\_ **Return type** int"
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeAlmadenV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeAlmadenV2",
			"type": "class",
			"description": "A fake Almaden V2 backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span.ExecutionSpans",
			"name": "qiskit_ibm_runtime.execution_span.ExecutionSpans",
			"type": "class",
			"description": "A collection of timings for pub results. This class is a list-like containing ExecutionSpans, where each execution span represents a time window of data collection, and contains a reference to exactly which of the data were collected during the window."
		},
		{
			"id": "qiskit_ibm_runtime.options.SimulatorOptions",
			"name": "qiskit_ibm_runtime.options.SimulatorOptions",
			"type": "class",
			"description": "Simulator options. For best practice in simulating a backend make sure to pass the basis gates and coupling map of that backend."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeYorktownV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeYorktownV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 1 / | 0 - 2 - 3 | / 4 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.options.NoiseLearnerOptions",
			"name": "qiskit_ibm_runtime.options.NoiseLearnerOptions",
			"type": "class",
			"description": ", simulator=, max_layers_to_learn=Unset, shots_per_randomization=Unset, num_randomizations=Unset, layer_pair_depths=Unset, twirling_strategy=Unset, experimental=Unset)\" modifiers=\"class\"> Bases: OptionsV2 Options for NoiseLearner."
		},
		{
			"id": "qiskit_ibm_runtime.models.BackendProperties",
			"name": "qiskit_ibm_runtime.models.BackendProperties",
			"type": "class",
			"description": "Class representing backend properties This holds backend properties measured by the provider. All properties which are provided optionally. These properties may describe qubits, gates, or other general properties of the backend. Initialize a BackendProperties instance."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeTorino",
			"name": "qiskit_ibm_runtime.fake_provider.FakeTorino",
			"type": "class",
			"description": "A fake 133 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBelemV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBelemV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeLimaV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeLimaV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeArmonkV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeArmonkV2",
			"type": "class",
			"description": "A fake 1 qubit backend. ``text 0 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMontrealV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMontrealV2",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.options.TwirlingOptions",
			"name": "qiskit_ibm_runtime.options.TwirlingOptions",
			"type": "class",
			"description": "Twirling options."
		},
		{
			"id": "qiskit_ibm_runtime.options.PecOptions",
			"name": "qiskit_ibm_runtime.options.PecOptions",
			"type": "class",
			"description": "Probabalistic error cancellation mitigation options. This is only used by V2 Estimator."
		},
		{
			"id": "qiskit_ibm_runtime.transpiler.passes.scheduling",
			"name": "qiskit_ibm_runtime.transpiler.passes.scheduling",
			"type": "module",
			"description": "qiskit_ibm_runtime.transpiler.passes.scheduling A collection of scheduling passes for working with IBM Quantum’s next-generation backends that support advanced “dynamic circuit” capabilities. Ie., circuits with support for classical control-flow/feedback based off of measurement results."
		},
		{
			"id": "qiskit_ibm_runtime.visualization.draw_zne_evs",
			"name": "qiskit_ibm_runtime.visualization.draw_zne_evs",
			"type": "function",
			"description": "Plot the zero noise extrapolation data in an EstimatorPubResult. This function generates a subfigure for each estimated expectation value. **Parameters** * **result** (*EstimatorPubResult*) – An EstimatorPubResult."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider",
			"name": "qiskit_ibm_runtime.fake_provider",
			"type": "module",
			"description": "qiskit_ibm_runtime.fake_provider"
		},
		{
			"id": "qiskit_ibm_runtime.options.MeasureNoiseLearningOptions",
			"name": "qiskit_ibm_runtime.options.MeasureNoiseLearningOptions",
			"type": "class",
			"description": "Options for measurement noise learning. This is only used by V2 Estimator. These options are only used when the resilience level or options specify a technique that requires measurement noise learning."
		},
		{
			"id": "qiskit_ibm_runtime.visualization",
			"name": "qiskit_ibm_runtime.visualization",
			"type": "module",
			"description": "qiskit_ibm_runtime.visualization A suite of functions for visualizing qiskit-ibm-runtime’s objects."
		},
		{
			"id": "qiskit_ibm_runtime.models.QasmBackendConfiguration",
			"name": "qiskit_ibm_runtime.models.QasmBackendConfiguration",
			"type": "class",
			"description": "Class representing an OpenQASM 2.0 Backend Configuration. ### backend\\_name backend name. ### backend\\_version backend version in the form X.Y.Z. ### n\\_qubits number of qubits. ### basis\\_gates list of basis gates names on the backend. ### gates list of basis gates on the backend."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakePerth",
			"name": "qiskit_ibm_runtime.fake_provider.FakePerth",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeAlgiers",
			"name": "qiskit_ibm_runtime.fake_provider.FakeAlgiers",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeWashingtonV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeWashingtonV2",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span.ExecutionSpan",
			"name": "qiskit_ibm_runtime.execution_span.ExecutionSpan",
			"type": "class",
			"description": "Abstract parent for classes that store an execution time span for a subset of job data. A pub is said to have dependence on an execution span if the corresponding execution includes data that forms any part of the pub’s results."
		},
		{
			"id": "qiskit_ibm_runtime.options.DynamicalDecouplingOptions",
			"name": "qiskit_ibm_runtime.options.DynamicalDecouplingOptions",
			"type": "class",
			"description": "Options for dynamical decoupling (DD)."
		},
		{
			"id": "qiskit_ibm_runtime.utils.noise_learner_result",
			"name": "qiskit_ibm_runtime.utils.noise_learner_result",
			"type": "module",
			"description": "Qiskit API documentation for qiskit_ibm_runtime.utils.noise_learner_result"
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeOsaka",
			"name": "qiskit_ibm_runtime.fake_provider.FakeOsaka",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.visualization.draw_zne_extrapolators",
			"name": "qiskit_ibm_runtime.visualization.draw_zne_extrapolators",
			"type": "function",
			"description": "Plot the zero noise extrapolation data in an EstimatorPubResult. This function generates a subfigure for each extrapolator. **Parameters** * **result** (*EstimatorPubResult*) – An EstimatorPubResult."
		},
		{
			"id": "qiskit_ibm_runtime.models.GateProperties",
			"name": "qiskit_ibm_runtime.models.GateProperties",
			"type": "class",
			"description": "Class representing a gate’s properties ### qubits qubits. ### gate gate. ### parameters parameters."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeLagosV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeLagosV2",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeAthensV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeAthensV2",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBrisbane",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBrisbane",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMarrakesh",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMarrakesh",
			"type": "class",
			"description": "A fake 156 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.execution_span.TwirledSliceSpan",
			"name": "qiskit_ibm_runtime.execution_span.TwirledSliceSpan",
			"type": "class",
			"description": "An ExecutionSpan for data stored in a sliceable format when twirling. This type of execution span references pub result data that came from a twirled sampler experiment which was executed by either prepending or appending an axis to parameter values to account for twirling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeVigoV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeVigoV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeJakartaV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeJakartaV2",
			"type": "class",
			"description": "A fake 7 qubit V2 backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBrooklynV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBrooklynV2",
			"type": "class",
			"description": "A fake Brooklyn V2 backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeKawasaki",
			"name": "qiskit_ibm_runtime.fake_provider.FakeKawasaki",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.QiskitRuntimeService",
			"name": "qiskit_ibm_runtime.QiskitRuntimeService",
			"type": "class",
			"description": "Class for interacting with the Qiskit Runtime service. QiskitRuntimeService constructor."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeEssexV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeEssexV2",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackendV2 initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeGuadalupeV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeGuadalupeV2",
			"type": "class",
			"description": "A fake 16 qubit backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.Session",
			"name": "qiskit_ibm_runtime.Session",
			"type": "class",
			"description": "Class for creating a Qiskit Runtime session. A Qiskit Runtime session allows you to group a collection of iterative calls to the quantum computer. A session is started when the first job within the session is started. Subsequent jobs within the session are prioritized by the scheduler."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSantiagoV2",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSantiagoV2",
			"type": "class",
			"description": "A fake Santiago backend. FakeBackendV2 initializer. ## Attributes ### backend\\_name ### conf\\_filename ### coupling\\_map Return the CouplingMap\") object ### dirname ### dt Return the system time resolution of input signals This is required to be implemented if the backend supports Pulse scheduling."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBoeblingen",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBoeblingen",
			"type": "class",
			"description": "A fake Boeblingen backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeAthens",
			"name": "qiskit_ibm_runtime.fake_provider.FakeAthens",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeTenerife",
			"name": "qiskit_ibm_runtime.fake_provider.FakeTenerife",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 1 ↙ ↑ 0 ← 2 ← 3 ↑ ↙ 4 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used. These are used to control the run() method."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMelbourne",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMelbourne",
			"type": "class",
			"description": "A fake 14 qubit backend. ``text 0 ← 1 → 2 → 3 ← 4 ← 5 → 6 ↑ ↑ ↑ ↓ ↓ ↓ 13 → 12 ← 11 → 10 ← 9 → 8 ← 7 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used. These are used to control the run() method."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSantiago",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSantiago",
			"type": "class",
			"description": "A fake Santiago backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeLondon",
			"name": "qiskit_ibm_runtime.fake_provider.FakeLondon",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeOurense",
			"name": "qiskit_ibm_runtime.fake_provider.FakeOurense",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBogota",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBogota",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeLima",
			"name": "qiskit_ibm_runtime.fake_provider.FakeLima",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeRome",
			"name": "qiskit_ibm_runtime.fake_provider.FakeRome",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeParis",
			"name": "qiskit_ibm_runtime.fake_provider.FakeParis",
			"type": "class",
			"description": "A fake Paris backend. ``text 06 17 ↕ ↕ 00 ↔ 01 ↔ 04 ↔ 07 ↔ 10 ↔ 12 ↔ 15 ↔ 18 ↔ 20 ↔ 23 ↕ ↕ ↕ 02 13 24 ↕ ↕ ↕ 03 ↔ 05 ↔ 08 ↔ 11 ↔ 14 ↔ 16 ↔ 19 ↔ 22 ↔ 25 ↔ 26 ↕ ↕ 09 20 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeEssex",
			"name": "qiskit_ibm_runtime.fake_provider.FakeEssex",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 2 ↕ 3 ↕ 4 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeManila",
			"name": "qiskit_ibm_runtime.fake_provider.FakeManila",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCairo",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCairo",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeQuito",
			"name": "qiskit_ibm_runtime.fake_provider.FakeQuito",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeRueschlikon",
			"name": "qiskit_ibm_runtime.fake_provider.FakeRueschlikon",
			"type": "class",
			"description": "A fake 16 qubit backend. ``text 1 → 2 → 3 → 4 ← 5 ← 6 → 7 ← 8 ↓ ↑ ↓ ↓ ↑ ↓ ↓ ↑ 0 ← 15 → 14 ← 13 ← 12 → 11 → 10 ← 9 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeNairobi",
			"name": "qiskit_ibm_runtime.fake_provider.FakeNairobi",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeProvider",
			"name": "qiskit_ibm_runtime.fake_provider.FakeProvider",
			"type": "class",
			"description": "Fake provider containing fake V1 backends. Only filtering backends by name is implemented. This class contains all fake V1 backends available in the qiskit_ibm_runtime.fake_provider. The class qiskit.providers.provider.Provider is deprecated as of qiskit 1.1."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeKolkata",
			"name": "qiskit_ibm_runtime.fake_provider.FakeKolkata",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeAlmaden",
			"name": "qiskit_ibm_runtime.fake_provider.FakeAlmaden",
			"type": "class",
			"description": "A fake Almaden backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeJohannesburg",
			"name": "qiskit_ibm_runtime.fake_provider.FakeJohannesburg",
			"type": "class",
			"description": "A fake Johannesburg backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeJakarta",
			"name": "qiskit_ibm_runtime.fake_provider.FakeJakarta",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeTokyo",
			"name": "qiskit_ibm_runtime.fake_provider.FakeTokyo",
			"type": "class",
			"description": "A fake 20 qubit backend."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeManhattan",
			"name": "qiskit_ibm_runtime.fake_provider.FakeManhattan",
			"type": "class",
			"description": "A fake Manhattan backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeWashington",
			"name": "qiskit_ibm_runtime.fake_provider.FakeWashington",
			"type": "class",
			"description": "A fake 127 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBrooklyn",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBrooklyn",
			"type": "class",
			"description": "A fake Brooklyn backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeVigo",
			"name": "qiskit_ibm_runtime.fake_provider.FakeVigo",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.RuntimeJob",
			"name": "qiskit_ibm_runtime.RuntimeJob",
			"type": "class",
			"description": "Representation of a runtime primitive execution. A new RuntimeJob instance is returned when you call QiskitRuntimeService.run to execute a runtime primitive, or QiskitRuntimeService.job to retrieve a previously executed job."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeLagos",
			"name": "qiskit_ibm_runtime.fake_provider.FakeLagos",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeYorktown",
			"name": "qiskit_ibm_runtime.fake_provider.FakeYorktown",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 1 / | 0 - 2 - 3 | / 4 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMumbai",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMumbai",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeValencia",
			"name": "qiskit_ibm_runtime.fake_provider.FakeValencia",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSydney",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSydney",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBelem",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBelem",
			"type": "class",
			"description": "A fake 5 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeBurlington",
			"name": "qiskit_ibm_runtime.fake_provider.FakeBurlington",
			"type": "class",
			"description": "A fake 5 qubit backend. ``text 0 ↔ 1 ↔ 3 ↔ 4 ↕ 2 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCambridge",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCambridge",
			"type": "class",
			"description": "A fake Cambridge backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 06 ↕ ↕ 07 ↔ 08 ↔ 09 ↔ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↔ 15 ↕ ↕ ↕ 16 17 18 ↕ ↕ ↕ 19 ↔ 20 ↔ 21 ↔ 22 ↔ 23 ↔ 24 ↔ 25 ↔ 26 ↔ 27 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeMontreal",
			"name": "qiskit_ibm_runtime.fake_provider.FakeMontreal",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeCasablanca",
			"name": "qiskit_ibm_runtime.fake_provider.FakeCasablanca",
			"type": "class",
			"description": "A fake 7 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeRochester",
			"name": "qiskit_ibm_runtime.fake_provider.FakeRochester",
			"type": "class",
			"description": "A fake Rochester backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeToronto",
			"name": "qiskit_ibm_runtime.fake_provider.FakeToronto",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeGuadalupe",
			"name": "qiskit_ibm_runtime.fake_provider.FakeGuadalupe",
			"type": "class",
			"description": "A fake 16 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeSingapore",
			"name": "qiskit_ibm_runtime.fake_provider.FakeSingapore",
			"type": "class",
			"description": "A fake Singapore backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeArmonk",
			"name": "qiskit_ibm_runtime.fake_provider.FakeArmonk",
			"type": "class",
			"description": "A fake 1 qubit backend. ``text 0 ` FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakeHanoi",
			"name": "qiskit_ibm_runtime.fake_provider.FakeHanoi",
			"type": "class",
			"description": "A fake 27 qubit backend. FakeBackend initializer."
		},
		{
			"id": "qiskit_ibm_runtime.fake_provider.FakePoughkeepsie",
			"name": "qiskit_ibm_runtime.fake_provider.FakePoughkeepsie",
			"type": "class",
			"description": "A fake Poughkeepsie backend. ``text 00 ↔ 01 ↔ 02 ↔ 03 ↔ 04 ↕ ↕ 05 ↔ 06 ↔ 07 ↔ 08 ↔ 09 ↕ ↕ ↕ 10 ↔ 11 ↔ 12 ↔ 13 ↔ 14 ↕ ↕ 15 ↔ 16 ↔ 17 ↔ 18 ↔ 19 ` ## Attributes ### options Return the options for the backend The options of a backend are the dynamic parameters defining how the backend is used."
		},
		{
			"id": "qiskit_ibm_runtime.options.TranspilationOptions",
			"name": "qiskit_ibm_runtime.options.TranspilationOptions",
			"type": "class",
			"description": "Transpilation options. This is only used by V1 primitives. **Parameters** * **skip\\_transpilation** – Whether to skip transpilation. Default is False. * **initial\\_layout** – Initial position of virtual qubits on physical qubits. See qiskit.compiler.transpile for more information."
		},
		{
			"id": "qiskit_ibm_runtime.options.ExecutionOptions",
			"name": "qiskit_ibm_runtime.options.ExecutionOptions",
			"type": "class",
			"description": "Execution options for V1 primitives. **Parameters** * **shots** – Number of repetitions of each circuit, for sampling. Default: 4000. * **init\\_qubits** – Whether to reset the qubits to the ground state for each shot. Default: True. ## Attributes ### init\\_qubits ### shots ## Methods"
		},
		{
			"id": "qiskit_ibm_runtime.options.Options",
			"name": "qiskit_ibm_runtime.options.Options",
			"type": "class",
			"description": ", resilience=, execution=, environment=, simulator=)\" modifiers=\"class\"> Options for V1 primitives. **Parameters** * **optimization\\_level** (Optional\\[int]) – How much optimization to perform on the circuits."
		},
		{
			"id": "qiskit_ibm_runtime.EstimatorV1",
			"name": "qiskit_ibm_runtime.EstimatorV1",
			"type": "class",
			"description": "Class for interacting with Qiskit Runtime Estimator primitive service. The EstimatorV1 primitives have been deprecated in 0.23, released on April 15, 2024. See the V2 migration guide. for more details. The EstimatorV1 support will be removed no earlier than July 15, 2024."
		},
		{
			"id": "qiskit_ibm_runtime.SamplerV1",
			"name": "qiskit_ibm_runtime.SamplerV1",
			"type": "class",
			"description": "Class for interacting with Qiskit Runtime Sampler primitive service. The SamplerV1 primitives have been deprecated in 0.23, released on April 15, 2024. See the V2 migration guide. for more details. The SamplerV1 support will be removed no earlier than July 15, 2024."
		},
		{
			"id": "qiskit_ibm_runtime.options.ResilienceOptions",
			"name": "qiskit_ibm_runtime.options.ResilienceOptions",
			"type": "class",
			"description": "Resilience options for V1 primitives. **Parameters** * **noise\\_factors** – An list of real valued noise factors that determine by what amount the circuits’ noise is amplified. Only applicable for resilience_level=2. Default: None, and (1, 3, 5) if resilience level is 2."
		},
		{
			"id": "qiskit_ibm_runtime.RuntimeOptions",
			"name": "qiskit_ibm_runtime.RuntimeOptions",
			"type": "class",
			"description": "Class for representing generic runtime execution options. RuntimeOptions constructor. **Parameters** * **backend** (*Optional\\[str | Backend]*) – target backend to run on. This is required for ibm_quantum channel."
		},
		{
			"id": "qiskit_ibm_transpiler.ai.AICliffordSynthesis",
			"name": "qiskit_ibm_transpiler.ai.AICliffordSynthesis",
			"type": "class",
			"description": "Synthesis for Clifford circuits (blocks of H, S and CX gates). Currently up to 9 qubit blocks. **Parameters** * **coupling\\_map** (*list*\")*\\*[*list*\")*\\*[*int*\")*]], optional*) – A list of pairs that represents physical links between qubits."
		},
		{
			"id": "qiskit_ibm_transpiler.ai.AILinearFunctionSynthesis",
			"name": "qiskit_ibm_transpiler.ai.AILinearFunctionSynthesis",
			"type": "class",
			"description": "Synthesis for Linear Function circuits (blocks of CX and SWAP gates). Currently up to 9 qubit blocks. **Parameters** * **coupling\\_map** (*list*\")*\\*[*list*\")*\\*[*int*\")*]], optional*) – A list of pairs that represents physical links between qubits."
		},
		{
			"id": "qiskit_ibm_transpiler.ai.AIRouting",
			"name": "qiskit_ibm_transpiler.ai.AIRouting",
			"type": "class",
			"description": "The AIRouting pass acts both as a layout stage and a routing stage. **Parameters** * **coupling\\_map** (*list*\")*\\*[*list*\")*\\*[*int*\")*]], optional*) – A list of pairs that represents physical links between qubits. * **backend** (*Backend, optional*) – Backend used for doing the transpilation."
		},
		{
			"id": "qiskit_ibm_transpiler.transpiler_service.TranspilerService",
			"name": "qiskit_ibm_transpiler.transpiler_service.TranspilerService",
			"type": "class",
			"description": "Class for using the transpiler service. **Parameters** * **optimization\\_level** (*int*\")) – The optimization level to use during the transpilation."
		},
		{
			"id": "qiskit_ibm_transpiler.ai.CollectCliffords",
			"name": "qiskit_ibm_transpiler.ai.CollectCliffords",
			"type": "class",
			"description": "Collects Clifford blocks as Instruction objects and stores the original sub-circuit to compare against it after synthesis."
		},
		{
			"id": "qiskit_ibm_transpiler.transpiler_service",
			"name": "qiskit_ibm_transpiler.transpiler_service",
			"type": "module",
			"description": "qiskit_ibm_transpiler.transpiler_service"
		},
		{
			"id": "qiskit_ibm_transpiler.ai.AIPermutationSynthesis",
			"name": "qiskit_ibm_transpiler.ai.AIPermutationSynthesis",
			"type": "class",
			"description": "Synthesis for Permutation circuits (blocks of SWAP gates). Currently available for 65, 33, and 27 qubit blocks. **Parameters** * **coupling\\_map** (*list*\")*\\*[*list*\")*\\*[*int*\")*]], optional*) – A list of pairs that represents physical links between qubits."
		},
		{
			"id": "qiskit_ibm_transpiler.ai.CollectPermutations",
			"name": "qiskit_ibm_transpiler.ai.CollectPermutations",
			"type": "class",
			"description": "Collects blocks of SWAP circuits as Permutations."
		},
		{
			"id": "qiskit_ibm_transpiler.utils",
			"name": "qiskit_ibm_transpiler.utils",
			"type": "module",
			"description": "**Parameters** * **n\\_qubits** (*int*\")) – * **seed** (*int*\")) – **Return type** *LinearFunction*\")"
		},
		{
			"id": "qiskit_ibm_transpiler.ai.CollectLinearFunctions",
			"name": "qiskit_ibm_transpiler.ai.CollectLinearFunctions",
			"type": "class",
			"description": "Collects blocks of SWAP and CX as LinearFunction objects and stores the original sub-circuit to compare against it after synthesis."
		},
		{
			"id": "qiskit_ibm_transpiler.ai",
			"name": "qiskit_ibm_transpiler.ai",
			"type": "module",
			"description": "qiskit_ibm_transpiler.ai"
		}
	]
}