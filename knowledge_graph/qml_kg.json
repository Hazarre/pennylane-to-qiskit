{
  "nodes": [
    {
      "id": "qml.transforms",
      "name": "qml.transforms",
      "type": "function",
      "description": "PennyLane API: transforms. Found in index.html",
      "source_file": "index.html",
      "context": "_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measureme"
    },
    {
      "id": "qml.io",
      "name": "qml.io",
      "type": "function",
      "description": "PennyLane API: io. Found in index.html",
      "source_file": "index.html",
      "context": "                                  Overview: module code — PennyLane 0.45.0-dev3 documentation                       About     Research                  Features                  Performance   "
    },
    {
      "id": "qml.tape",
      "name": "qml.tape",
      "type": "function",
      "description": "PennyLane API: tape. Found in index.html",
      "source_file": "index.html",
      "context": "ency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Overview: module code    All modules for which code is ava"
    },
    {
      "id": "qml.shadows",
      "name": "qml.shadows",
      "type": "function",
      "description": "PennyLane API: shadows. Found in index.html",
      "source_file": "index.html",
      "context": " qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions q"
    },
    {
      "id": "qml.measurements",
      "name": "qml.measurements",
      "type": "function",
      "description": "PennyLane API: measurements. Found in index.html",
      "source_file": "index.html",
      "context": "spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Ove"
    },
    {
      "id": "qml.numpy",
      "name": "qml.numpy",
      "type": "function",
      "description": "PennyLane API: numpy. Found in index.html",
      "source_file": "index.html",
      "context": "qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shado"
    },
    {
      "id": "qml.wires",
      "name": "qml.wires",
      "type": "function",
      "description": "PennyLane API: wires. Found in index.html",
      "source_file": "index.html",
      "context": "devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Overview: module code    All modules for which code is available pe"
    },
    {
      "id": "qml.qaoa",
      "name": "qml.qaoa",
      "type": "function",
      "description": "PennyLane API: qaoa. Found in index.html",
      "source_file": "index.html",
      "context": "ml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.cap"
    },
    {
      "id": "qml.pauli",
      "name": "qml.pauli",
      "type": "function",
      "description": "PennyLane API: pauli. Found in index.html",
      "source_file": "index.html",
      "context": "qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms"
    },
    {
      "id": "qml.exceptions",
      "name": "qml.exceptions",
      "type": "function",
      "description": "PennyLane API: exceptions. Found in index.html",
      "source_file": "index.html",
      "context": "esource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.wo"
    },
    {
      "id": "qml.labs",
      "name": "qml.labs",
      "type": "function",
      "description": "PennyLane API: labs. Found in index.html",
      "source_file": "index.html",
      "context": "n qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qao"
    },
    {
      "id": "qml.ftqc",
      "name": "qml.ftqc",
      "type": "function",
      "description": "PennyLane API: ftqc. Found in index.html",
      "source_file": "index.html",
      "context": "dows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow         "
    },
    {
      "id": "qml.kernels",
      "name": "qml.kernels",
      "type": "function",
      "description": "PennyLane API: kernels. Found in index.html",
      "source_file": "index.html",
      "context": "decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.p"
    },
    {
      "id": "qml.operation",
      "name": "qml.operation",
      "type": "function",
      "description": "PennyLane API: operation. Found in index.html",
      "source_file": "index.html",
      "context": "s  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Overview: module code    All mod"
    },
    {
      "id": "qml.liealg",
      "name": "qml.liealg",
      "type": "function",
      "description": "PennyLane API: liealg. Found in index.html",
      "source_file": "index.html",
      "context": "ugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qch"
    },
    {
      "id": "qml.workflow",
      "name": "qml.workflow",
      "type": "function",
      "description": "PennyLane API: workflow. Found in index.html",
      "source_file": "index.html",
      "context": "rs Measurements Dynamic quantum circuits Templates Inspecting circuits Compiling circuits Compiling workflows Importing workflows Quantum Chemistry Quantum Datasets Logging  Release news  Release note"
    },
    {
      "id": "qml.drawer",
      "name": "qml.drawer",
      "type": "function",
      "description": "PennyLane API: drawer. Found in index.html",
      "source_file": "index.html",
      "context": "n Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml."
    },
    {
      "id": "qml.math",
      "name": "qml.math",
      "type": "function",
      "description": "PennyLane API: math. Found in index.html",
      "source_file": "index.html",
      "context": "stimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml"
    },
    {
      "id": "qml.debugging",
      "name": "qml.debugging",
      "type": "function",
      "description": "PennyLane API: debugging. Found in index.html",
      "source_file": "index.html",
      "context": "ilding a plugin Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs q"
    },
    {
      "id": "qml.compiler",
      "name": "qml.compiler",
      "type": "function",
      "description": "PennyLane API: compiler. Found in index.html",
      "source_file": "index.html",
      "context": " bits  Development  Development guide Building a plugin Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml"
    },
    {
      "id": "qml.capture",
      "name": "qml.capture",
      "type": "function",
      "description": "PennyLane API: capture. Found in index.html",
      "source_file": "index.html",
      "context": "mistry Quantum Datasets Logging  Release news  Release notes Deprecations Updated Operators Program capture sharp bits  Development  Development guide Building a plugin Adding new operators  API  qml "
    },
    {
      "id": "qml.qnn",
      "name": "qml.qnn",
      "type": "function",
      "description": "PennyLane API: qnn. Found in index.html",
      "source_file": "index.html",
      "context": "ng qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.dev"
    },
    {
      "id": "qml.concurrency",
      "name": "qml.concurrency",
      "type": "function",
      "description": "PennyLane API: concurrency. Found in index.html",
      "source_file": "index.html",
      "context": "qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queui"
    },
    {
      "id": "qml.pytrees",
      "name": "qml.pytrees",
      "type": "function",
      "description": "PennyLane API: pytrees. Found in index.html",
      "source_file": "index.html",
      "context": "ms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Overview: module cod"
    },
    {
      "id": "qml.gradients",
      "name": "qml.gradients",
      "type": "function",
      "description": "PennyLane API: gradients. Found in index.html",
      "source_file": "index.html",
      "context": "ompiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op"
    },
    {
      "id": "qml.data",
      "name": "qml.data",
      "type": "function",
      "description": "PennyLane API: data. Found in index.html",
      "source_file": "index.html",
      "context": "pment  Development guide Building a plugin Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qm"
    },
    {
      "id": "qml.devices",
      "name": "qml.devices",
      "type": "function",
      "description": "PennyLane API: devices. Found in index.html",
      "source_file": "index.html",
      "context": "ml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml."
    },
    {
      "id": "qml.bose",
      "name": "qml.bose",
      "type": "function",
      "description": "PennyLane API: bose. Found in index.html",
      "source_file": "index.html",
      "context": "ure sharp bits  Development  Development guide Building a plugin Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fo"
    },
    {
      "id": "qml.qchem",
      "name": "qml.qchem",
      "type": "function",
      "description": "PennyLane API: qchem. Found in index.html",
      "source_file": "index.html",
      "context": "ml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml."
    },
    {
      "id": "qml.decomposition",
      "name": "qml.decomposition",
      "type": "function",
      "description": "PennyLane API: decomposition. Found in index.html",
      "source_file": "index.html",
      "context": "velopment guide Building a plugin Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml."
    },
    {
      "id": "qml.ops.op_math",
      "name": "qml.ops.op_math",
      "type": "function",
      "description": "PennyLane API: ops.op_math. Found in index.html",
      "source_file": "index.html",
      "context": "r qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spi"
    },
    {
      "id": "qml.noise",
      "name": "qml.noise",
      "type": "function",
      "description": "PennyLane API: noise. Found in index.html",
      "source_file": "index.html",
      "context": "qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource"
    },
    {
      "id": "qml.fourier",
      "name": "qml.fourier",
      "type": "function",
      "description": "PennyLane API: fourier. Found in index.html",
      "source_file": "index.html",
      "context": "l.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.nump"
    },
    {
      "id": "qml.estimator",
      "name": "qml.estimator",
      "type": "function",
      "description": "PennyLane API: estimator. Found in index.html",
      "source_file": "index.html",
      "context": "w operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml"
    },
    {
      "id": "qml.resource",
      "name": "qml.resource",
      "type": "function",
      "description": "PennyLane API: resource. Found in index.html",
      "source_file": "index.html",
      "context": "ath qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml"
    },
    {
      "id": "qml.spin",
      "name": "qml.spin",
      "type": "function",
      "description": "PennyLane API: spin. Found in index.html",
      "source_file": "index.html",
      "context": "ml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml."
    },
    {
      "id": "qml.queuing",
      "name": "qml.queuing",
      "type": "function",
      "description": "PennyLane API: queuing. Found in index.html",
      "source_file": "index.html",
      "context": " qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Overview: module code    All modules for which"
    },
    {
      "id": "qml.fermi",
      "name": "qml.fermi",
      "type": "function",
      "description": "PennyLane API: fermi. Found in index.html",
      "source_file": "index.html",
      "context": "PI  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.nois"
    },
    {
      "id": "qml.logging",
      "name": "qml.logging",
      "type": "function",
      "description": "PennyLane API: logging. Found in index.html",
      "source_file": "index.html",
      "context": "drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut"
    },
    {
      "id": "qml.pulse",
      "name": "qml.pulse",
      "type": "function",
      "description": "PennyLane API: pulse. Found in index.html",
      "source_file": "index.html",
      "context": ".kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internal"
    },
    {
      "id": "qml.qcut",
      "name": "qml.qcut",
      "type": "function",
      "description": "PennyLane API: qcut. Found in index.html",
      "source_file": "index.html",
      "context": "qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrenc"
    },
    {
      "id": "qml.RY",
      "name": "qml.RY",
      "type": "class",
      "description": "PennyLane API: RY. Found in grad.html",
      "source_file": "grad.html",
      "context": "de(dev)         def circuit(weights):             qml.RX(weights[0, 0, 0], wires=0)             qml.RY(weights[0, 0, 1], wires=1)             qml.RZ(weights[1, 0, 2], wires=0)             return qml.p"
    },
    {
      "id": "qml.math.shape",
      "name": "qml.math.shape",
      "type": "function",
      "description": "PennyLane API: math.shape. Found in grad.html",
      "source_file": "grad.html",
      "context": " = qml.jacobian(circuit)(x, y)     >>> print(type(jac), len(jac))     <class 'tuple'> 2     >>> qml.math.shape(jac[0])     (8, 2)     >>> qml.math.shape(jac[1])     (8, 2, 4)      As we can see, there"
    },
    {
      "id": "qml.RZ",
      "name": "qml.RZ",
      "type": "class",
      "description": "PennyLane API: RZ. Found in grad.html",
      "source_file": "grad.html",
      "context": "    qml.RX(weights[0, 0, 0], wires=0)             qml.RY(weights[0, 0, 1], wires=1)             qml.RZ(weights[1, 0, 2], wires=0)             return qml.probs()          weights = np.array([[[0.2, 0.9"
    },
    {
      "id": "qml.device",
      "name": "qml.device",
      "type": "function",
      "description": "PennyLane API: device. Found in grad.html",
      "source_file": "grad.html",
      "context": "ml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml."
    },
    {
      "id": "qml.probs",
      "name": "qml.probs",
      "type": "function",
      "description": "PennyLane API: probs. Found in grad.html",
      "source_file": "grad.html",
      "context": ".RY(weights[0, 0, 1], wires=1)             qml.RZ(weights[1, 0, 2], wires=0)             return qml.probs()          weights = np.array([[[0.2, 0.9, -1.4]], [[0.5, 0.2, 0.1]]], requires_grad=True)    "
    },
    {
      "id": "qml.grad",
      "name": "qml.grad",
      "type": "function",
      "description": "PennyLane API: grad. Found in grad.html",
      "source_file": "grad.html",
      "context": "                                  pennylane._grad.grad — PennyLane 0.45.0-dev3 documentation                       About     Research                "
    },
    {
      "id": "qml.RX",
      "name": "qml.RX",
      "type": "class",
      "description": "PennyLane API: RX. Found in grad.html",
      "source_file": "grad.html",
      "context": "ce(\"default.qubit\", wires=2)          @qml.qnode(dev)         def circuit(weights):             qml.RX(weights[0, 0, 0], wires=0)             qml.RY(weights[0, 0, 1], wires=1)             qml.RZ(weigh"
    },
    {
      "id": "qml.qjit",
      "name": "qml.qjit",
      "type": "function",
      "description": "PennyLane API: qjit. Found in grad.html",
      "source_file": "grad.html",
      "context": " \"\"\"Returns the gradient as a callable function of hybrid quantum-classical functions.     :func:`~.qjit` and Autograd compatible.      By default, gradients are computed for arguments which contain  "
    },
    {
      "id": "qml.jacobian",
      "name": "qml.jacobian",
      "type": "function",
      "description": "PennyLane API: jacobian. Found in grad.html",
      "source_file": "grad.html",
      "context": "tions under the License. \"\"\" This submodule contains the autograd wrappers :class:`grad` and :func:`jacobian` \"\"\" import inspect import numbers import warnings from functools import lru_cache, wraps  "
    },
    {
      "id": "qml.qnode",
      "name": "qml.qnode",
      "type": "function",
      "description": "PennyLane API: qnode. Found in grad.html",
      "source_file": "grad.html",
      "context": "from pennylane import numpy as np          dev = qml.device(\"default.qubit\", wires=2)          @qml.qnode(dev)         def circuit(weights):             qml.RX(weights[0, 0, 0], wires=0)             q"
    },
    {
      "id": "qml.jvp",
      "name": "qml.jvp",
      "type": "function",
      "description": "PennyLane API: jvp. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "                                  pennylane._grad.jvp — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.Z",
      "name": "qml.Z",
      "type": "class",
      "description": "PennyLane API: Z. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "(params[n, 0], wires=n)             qml.RY(params[n, 1], wires=n)             return qml.expval(qml.Z(1))          @qml.qjit         def workflow(primals, tangents):             return qml.jvp(circuit"
    },
    {
      "id": "qml.expval",
      "name": "qml.expval",
      "type": "function",
      "description": "PennyLane API: expval. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "     qml.RX(params[n, 0], wires=n)             qml.RY(params[n, 1], wires=n)             return qml.expval(qml.Z(1))          @qml.qjit         def workflow(primals, tangents):             return qml."
    },
    {
      "id": "qml.vjp",
      "name": "qml.vjp",
      "type": "function",
      "description": "PennyLane API: vjp. Found in vjp.html",
      "source_file": "vjp.html",
      "context": "                                  pennylane._grad.vjp — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.cond",
      "name": "qml.cond",
      "type": "function",
      "description": "PennyLane API: cond. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "cated back into the zero state. This allows us to     use it as one of the wires requested in the second allocation, resulting in a total of three wires     being required from the device, including t"
    },
    {
      "id": "qml.X",
      "name": "qml.X",
      "type": "class",
      "description": "PennyLane API: X. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "Module code pennylane pennylane.allocation    Source code for pennylane.allocation # Copyright 2025 Xanadu Quantum Technologies Inc.  # Licensed under the Apache License, Version 2.0 (the \"License\"); "
    },
    {
      "id": "qml.SWAP",
      "name": "qml.SWAP",
      "type": "class",
      "description": "PennyLane API: SWAP. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "llocate(wire)              new_wires = qml.allocate(2, state=\"zero\", restored=True)             qml.SWAP((new_wires[1], new_wires[0]))             qml.deallocate(new_wires)              return qml.exp"
    },
    {
      "id": "qml.deallocate",
      "name": "qml.deallocate",
      "type": "function",
      "description": "PennyLane API: deallocate. Found in allocation.html",
      "source_file": "allocation.html",
      "context": " can start in.\"\"\"      ZERO = \"zero\"     ANY = \"any\"   if not has_jax:     allocate_prim = None     deallocate_prim = None else:     allocate_prim = QmlPrimitive(\"allocate\")     allocate_prim.multiple"
    },
    {
      "id": "qml.H",
      "name": "qml.H",
      "type": "class",
      "description": "PennyLane API: H. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "         About     Research                  Features                  Performance                  Hardware & Simulators                  Learn                  Teach                     Software & D"
    },
    {
      "id": "qml.measure",
      "name": "qml.measure",
      "type": "function",
      "description": "PennyLane API: measure. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation qml.queuing qml.tape qml.wires qml.workflow          Docs Mod"
    },
    {
      "id": "qml.draw",
      "name": "qml.draw",
      "type": "function",
      "description": "PennyLane API: draw. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "n Adding new operators  API  qml qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml."
    },
    {
      "id": "qml.CNOT",
      "name": "qml.CNOT",
      "type": "class",
      "description": "PennyLane API: CNOT. Found in allocation.html",
      "source_file": "allocation.html",
      "context": "       qml.H(0)              wire = qml.allocate(1, state=\"zero\", restored=True)[0]             qml.CNOT((0, wire))             qml.CNOT((0, wire))             qml.deallocate(wire)              new_wi"
    },
    {
      "id": "qml.allocate",
      "name": "qml.allocate",
      "type": "function",
      "description": "PennyLane API: allocate. Found in allocation.html",
      "source_file": "allocation.html",
      "context": " of states a dynamic wire can start in.\"\"\"      ZERO = \"zero\"     ANY = \"any\"   if not has_jax:     allocate_prim = None     deallocate_prim = None else:     allocate_prim = QmlPrimitive(\"allocate\")  "
    },
    {
      "id": "qml.BooleanFn",
      "name": "qml.BooleanFn",
      "type": "class",
      "description": "PennyLane API: BooleanFn. Found in boolean_fn.html",
      "source_file": "boolean_fn.html",
      "context": "language governing permissions and # limitations under the License.  \"\"\" Contains a utility class ``BooleanFn`` that allows logical composition of functions with boolean output. \"\"\" import functools  "
    },
    {
      "id": "qml.BoseWord",
      "name": "qml.BoseWord",
      "type": "class",
      "description": "PennyLane API: BoseWord. Found in bosonic.html",
      "source_file": "bosonic.html",
      "context": "opy import copy  from pennylane import math from pennylane.typing import TensorLike    [docs] class BoseWord(dict):     r\"\"\"Dictionary used to represent a Bose word, a product of bosonic creation and "
    },
    {
      "id": "qml.BoseSentence",
      "name": "qml.BoseSentence",
      "type": "class",
      "description": "PennyLane API: BoseSentence. Found in bosonic.html",
      "source_file": "bosonic.html",
      "context": "rd\"\"\"         return f\"BoseWord({self.sorted_dic})\"      def __add__(self, other):         \"\"\"Add a BoseSentence, BoseWord or constant to a BoseWord. Converts both         elements into BoseSentences,"
    },
    {
      "id": "qml.bose.BoseWord",
      "name": "qml.bose.BoseWord",
      "type": "function",
      "description": "PennyLane API: bose.BoseWord. Found in bosonic_mapping.html",
      "source_file": "bosonic_mapping.html",
      "context": "auliSentence, Operator]: A linear combination of qubit operators.      **Example**      >>> w = qml.bose.BoseWord({(0,0):\"+\", (1,1): \"-\"})     >>> qml.christiansen_mapping(w)     (         0.25 * (X(0"
    },
    {
      "id": "qml.christiansen_mapping",
      "name": "qml.christiansen_mapping",
      "type": "function",
      "description": "PennyLane API: christiansen_mapping. Found in bosonic_mapping.html",
      "source_file": "bosonic_mapping.html",
      "context": "ubit_operator[pw])      qubit_operator.simplify(tol=1e-16)      return qubit_operator    [docs] def christiansen_mapping(     bose_operator: BoseWord | BoseSentence,     ps: bool = False,     wire_map"
    },
    {
      "id": "qml.binary_mapping",
      "name": "qml.binary_mapping",
      "type": "function",
      "description": "PennyLane API: binary_mapping. Found in bosonic_mapping.html",
      "source_file": "bosonic_mapping.html",
      "context": "2 * 1j})      return PauliSentence({PauliWord({}): c1, PauliWord({qub_id: \"Z\"}): c2})    [docs] def binary_mapping(     bose_operator: BoseWord | BoseSentence,     n_states: int = 2,     ps: bool = Fa"
    },
    {
      "id": "qml.unary_mapping",
      "name": "qml.unary_mapping",
      "type": "function",
      "description": "PennyLane API: unary_mapping. Found in bosonic_mapping.html",
      "source_file": "bosonic_mapping.html",
      "context": "ubit_operator[pw])      qubit_operator.simplify(tol=1e-16)      return qubit_operator    [docs] def unary_mapping(     bose_operator: BoseWord | BoseSentence,     n_states: int = 2,     ps: bool = Fal"
    },
    {
      "id": "qml.QNode",
      "name": "qml.QNode",
      "type": "class",
      "description": "PennyLane API: QNode. Found in transformer.html",
      "source_file": "transformer.html",
      "context": " transformation process. Typically, this only works on function objects.         Here we also allow QNodes to be transformed.\"\"\"          # By default, AutoGraph will only convert function or method o"
    },
    {
      "id": "qml.capture.enable",
      "name": "qml.capture.enable",
      "type": "function",
      "description": "PennyLane API: capture.enable. Found in transformer.html",
      "source_file": "transformer.html",
      "context": "jaxpr         from pennylane.capture.autograph import disable_autograph, run_autograph          qml.capture.enable()          def f(x):             if x > 1:                 return x**2             re"
    },
    {
      "id": "qml.while_loop",
      "name": "qml.while_loop",
      "type": "function",
      "description": "PennyLane API: while_loop. Found in transformer.html",
      "source_file": "transformer.html",
      "context": "                # py3.14: \"Lambda(...) is not supported\"                 if \"Lambda\" in str(e) and \"while_loop\" in inspect.getsource(fn):                     raise AutoGraphError(                     "
    },
    {
      "id": "qml.capture.primitives.for_loop_prim",
      "name": "qml.capture.primitives.for_loop_prim",
      "type": "function",
      "description": "PennyLane API: capture.primitives.for_loop_prim. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "ation(self, op):                 self.ops.append(op)          @AccumulateOps.register_primitive(qml.capture.primitives.for_loop_prim)         def _(self, start, stop, step, *invals, jaxpr_body_fn, con"
    },
    {
      "id": "qml.operation.Operator",
      "name": "qml.operation.Operator",
      "type": "function",
      "description": "PennyLane API: operation.Operator. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "   a Catalyst variant jaxpr.         \"\"\"    [docs]     def interpret_operation(self, op: \"pennylane.operation.Operator\"):         \"\"\"Interpret a PennyLane operation instance.          Args:           "
    },
    {
      "id": "qml.for_loop",
      "name": "qml.for_loop",
      "type": "function",
      "description": "PennyLane API: for_loop. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "n from .primitives import (     adjoint_transform_prim,     cond_prim,     ctrl_transform_prim,     for_loop_prim,     jacobian_prim,     qnode_prim,     while_loop_prim, )  FlattenedHigherOrderPrimit"
    },
    {
      "id": "qml.QueuingManager.stop_recording",
      "name": "qml.QueuingManager.stop_recording",
      "type": "class",
      "description": "PennyLane API: QueuingManager.stop_recording. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "eration`.          \"\"\"         invals = (self.read(invar) for invar in eqn.invars)         with qml.QueuingManager.stop_recording():             op = eqn.primitive.impl(*invals, **eqn.params)         "
    },
    {
      "id": "qml.measurement.MeasurementProcess",
      "name": "qml.measurement.MeasurementProcess",
      "type": "function",
      "description": "PennyLane API: measurement.MeasurementProcess. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "turn self.interpret_measurement(mp)    [docs]     def interpret_measurement(self, measurement: \"qml.measurement.MeasurementProcess\"):         \"\"\"Interpret a measurement process instance.          Args"
    },
    {
      "id": "qml.capture.eval_jaxpr",
      "name": "qml.capture.eval_jaxpr",
      "type": "function",
      "description": "PennyLane API: capture.eval_jaxpr. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "> def f(i):     ...     return jax.numpy.arange(i)     >>> jaxpr = jax.make_jaxpr(f)(3)     >>> qml.capture.eval_jaxpr(jaxpr.jaxpr, jaxpr.consts, 2)     [Array([0, 1], dtype=int32)]     >>> jax.core.e"
    },
    {
      "id": "qml.math.is_abstract",
      "name": "qml.math.is_abstract",
      "type": "function",
      "description": "PennyLane API: math.is_abstract. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "ll from iterable of dynamic shapes             next_s = next(dyn_shape_iter)             if not qml.math.is_abstract(next_s):                 # may need to cast to a built-in integer if possible      "
    },
    {
      "id": "qml.adjoint",
      "name": "qml.adjoint",
      "type": "function",
      "description": "PennyLane API: adjoint. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "nnylane as qml from pennylane import math  from .flatfn import FlatFn from .primitives import (     adjoint_transform_prim,     cond_prim,     ctrl_transform_prim,     for_loop_prim,     jacobian_prim"
    },
    {
      "id": "qml.simplify",
      "name": "qml.simplify",
      "type": "function",
      "description": "PennyLane API: simplify. Found in base_interpreter.html",
      "source_file": "base_interpreter.html",
      "context": "ter(PlxprInterpreter):              def interpret_operation(self, op):                 new_op = qml.simplify(op)                 if new_op is op:                     # simplify didn't create a new ope"
    },
    {
      "id": "qml.capture.determine_abstracted_axes",
      "name": "qml.capture.determine_abstracted_axes",
      "type": "function",
      "description": "PennyLane API: capture.determine_abstracted_axes. Found in dynamic_shapes.html",
      "source_file": "dynamic_shapes.html",
      "context": "  def f(n):             x = jax.numpy.ones((n,))             abstracted_axes, abstract_shapes = qml.capture.determine_abstracted_axes((x,))             jaxpr = jax.make_jaxpr(jax.numpy.sum, abstracted"
    },
    {
      "id": "qml.S",
      "name": "qml.S",
      "type": "class",
      "description": "PennyLane API: S. Found in expand_transforms.html",
      "source_file": "expand_transforms.html",
      "context": "out     Research                  Features                  Performance                  Hardware & Simulators                  Learn                  Teach                     Software & Documentatio"
    },
    {
      "id": "qml.capture.expand_plxpr_transforms",
      "name": "qml.capture.expand_plxpr_transforms",
      "type": "function",
      "description": "PennyLane API: capture.expand_plxpr_transforms. Found in expand_transforms.html",
      "source_file": "expand_transforms.html",
      "context": "he transform, we can use ``expand_plxpr_transforms`` as follows:      >>> transformed_circuit = qml.capture.expand_plxpr_transforms(circuit)     >>> qml.capture.make_plxpr(transformed_circuit)()     {"
    },
    {
      "id": "qml.transforms.cancel_inverses",
      "name": "qml.transforms.cancel_inverses",
      "type": "function",
      "description": "PennyLane API: transforms.cancel_inverses. Found in expand_transforms.html",
      "source_file": "expand_transforms.html",
      "context": "ent in the program being run.      **Example**      In the below example, we can see that the ``qml.transforms.cancel_inverses`` transform has been     applied to a function. However, the resulting pr"
    },
    {
      "id": "qml.capture.make_plxpr",
      "name": "qml.capture.make_plxpr",
      "type": "function",
      "description": "PennyLane API: capture.make_plxpr. Found in expand_transforms.html",
      "source_file": "expand_transforms.html",
      "context": "    qml.X(0)             qml.adjoint(qml.S(1))             return qml.expval(qml.Z(1))      >>> qml.capture.make_plxpr(circuit)()     { lambda ; . let         a:AbstractMeasurement(n_wires=None) = can"
    },
    {
      "id": "qml.Hadamard",
      "name": "qml.Hadamard",
      "type": "class",
      "description": "PennyLane API: Hadamard. Found in make_plxpr.html",
      "source_file": "make_plxpr.html",
      "context": "t\", wires=1)          @qml.qnode(dev)         def circ(x):             qml.RX(x, 0)             qml.Hadamard(0)             return qml.expval(qml.X(0))          plxpr = qml.capture.make_plxpr(circ)(1."
    },
    {
      "id": "qml.capture.enabled",
      "name": "qml.capture.enabled",
      "type": "function",
      "description": "PennyLane API: capture.enabled. Found in make_plxpr.html",
      "source_file": "make_plxpr.html",
      "context": "function. \"             \"You can install jax via: pip install jax==0.7.1\"         )      if not qml.capture.enabled():         raise RuntimeError(             \"Capturing PLxPR with ``make_plxpr`` requ"
    },
    {
      "id": "qml.capture.pause",
      "name": "qml.capture.pause",
      "type": "function",
      "description": "PennyLane API: capture.pause. Found in switches.html",
      "source_file": "switches.html",
      "context": "anager def pause():     \"\"\"Temporarily stop program capture.      >>> def f():     ...     with qml.capture.pause():     ...         qml.X(0)     ...     return 2     >>> jax.make_jaxpr(f)()     { lam"
    },
    {
      "id": "qml.workflow.construct_tape",
      "name": "qml.workflow.construct_tape",
      "type": "function",
      "description": "PennyLane API: workflow.construct_tape. Found in circuit_graph.html",
      "source_file": "circuit_graph.html",
      "context": "xpval(qml.X(0))         >>> qnode = qml.QNode(circuit_measure_max_once, dev)         >>> tape = qml.workflow.construct_tape(qnode)()         >>> print(tape.graph.max_simultaneous_measurements)        "
    },
    {
      "id": "qml.state",
      "name": "qml.state",
      "type": "function",
      "description": "PennyLane API: state. Found in circuit_graph.html",
      "source_file": "circuit_graph.html",
      "context": "ts = np.unique(a, return_counts=True)         return counts.max() if counts.size != 0 else 1  # qml.state() will result in an empty array    _modules/pennylane/circuit_graph                      Downl"
    },
    {
      "id": "qml.compiler.active",
      "name": "qml.compiler.active",
      "type": "function",
      "description": "PennyLane API: compiler.active. Found in compiler.html",
      "source_file": "compiler.html",
      "context": "tning.qubit\", wires=2)          @qml.qnode(dev)         def circuit(phi, theta):             if qml.compiler.active_compiler() == \"catalyst\":                 qml.RX(phi, wires=0)             qml.CNOT("
    },
    {
      "id": "qml.compiler.available",
      "name": "qml.compiler.available",
      "type": "function",
      "description": "PennyLane API: compiler.available. Found in compiler.html",
      "source_file": "compiler.html",
      "context": "/pennylaneai/catalyst>`__     compiler, this will now appear as an available compiler:      >>> qml.compiler.available_compilers()     ['catalyst']     \"\"\"      # Reload installed packages and updates"
    },
    {
      "id": "qml.compiler.active_compiler",
      "name": "qml.compiler.active_compiler",
      "type": "function",
      "description": "PennyLane API: compiler.active_compiler. Found in compiler.html",
      "source_file": "compiler.html",
      "context": "tning.qubit\", wires=2)          @qml.qnode(dev)         def circuit(phi, theta):             if qml.compiler.active_compiler() == \"catalyst\":                 qml.RX(phi, wires=0)             qml.CNOT("
    },
    {
      "id": "qml.compiler.available_compilers",
      "name": "qml.compiler.available_compilers",
      "type": "function",
      "description": "PennyLane API: compiler.available_compilers. Found in compiler.html",
      "source_file": "compiler.html",
      "context": "/pennylaneai/catalyst>`__     compiler, this will now appear as an available compiler:      >>> qml.compiler.available_compilers()     ['catalyst']     \"\"\"      # Reload installed packages and updates"
    },
    {
      "id": "qml.PhaseShift",
      "name": "qml.PhaseShift",
      "type": "class",
      "description": "PennyLane API: PhaseShift. Found in compiler.html",
      "source_file": "compiler.html",
      "context": "\"catalyst\":                 qml.RX(phi, wires=0)             qml.CNOT(wires=[0, 1])             qml.PhaseShift(theta, wires=0)             return qml.expval(qml.Z(0))      >>> circuit(np.pi, np.pi / 2"
    },
    {
      "id": "qml.Y",
      "name": "qml.Y",
      "type": "class",
      "description": "PennyLane API: Y. Found in qjit_api.html",
      "source_file": "qjit_api.html",
      "context": ", Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at  #     http://www.apache.org/licenses/LICENSE-2.0  # Unless "
    },
    {
      "id": "qml.logging.enable_logging",
      "name": "qml.logging.enable_logging",
      "type": "function",
      "description": "PennyLane API: logging.enable_logging. Found in for_loop.html",
      "source_file": "for_loop.html",
      "context": "                 f\"\\n\\n{e}.\\n\\nFull error logged at exception level. \"                     \"Use qml.logging.enable_logging() to view.\"                     \"\\nFalling back to unrolled Python for loop.\""
    },
    {
      "id": "qml.py",
      "name": "qml.py",
      "type": "function",
      "description": "PennyLane API: py. Found in operator.html",
      "source_file": "operator.html",
      "context": ".fourier qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows "
    },
    {
      "id": "qml.Hamiltonian",
      "name": "qml.Hamiltonian",
      "type": "class",
      "description": "PennyLane API: Hamiltonian. Found in attribute.html",
      "source_file": "attribute.html",
      "context": "            Videos                     Topics     Fault-Tolerant Quantum Computing                  Hamiltonian Simulation                  Quantum Hardware                  Quantum Machine Learning  "
    },
    {
      "id": "qml.data.attribute",
      "name": "qml.data.attribute",
      "type": "function",
      "description": "PennyLane API: data.attribute. Found in attribute.html",
      "source_file": "attribute.html",
      "context": "vecs = np.linalg.eigh(qml.matrix(hamiltonian))     >>> dataset = qml.data.Dataset(hamiltonian = qml.data.attribute(     ...     hamiltonian,     ...     doc=\"The hamiltonian of the system\"))     >>> d"
    },
    {
      "id": "qml.data.Dataset",
      "name": "qml.data.Dataset",
      "type": "function",
      "description": "PennyLane API: data.Dataset. Found in attribute.html",
      "source_file": "attribute.html",
      "context": "qml.Z(1)])     >>> eigvals, eigvecs = np.linalg.eigh(qml.matrix(hamiltonian))     >>> dataset = qml.data.Dataset(hamiltonian = qml.data.attribute(     ...     hamiltonian,     ...     doc=\"The hamilto"
    },
    {
      "id": "qml.__data_len__",
      "name": "qml.__data_len__",
      "type": "function",
      "description": "PennyLane API: __data_len__. Found in attribute.html",
      "source_file": "attribute.html",
      "context": "):         self[\"doc\"] = doc      def __len__(self) -> int:         return self.attrs_bind.get(\"qml.__data_len__\", 0)      def _update_len(self, inc: int):         self.attrs_bind[\"qml.__data_len__\"] "
    },
    {
      "id": "qml.matrix",
      "name": "qml.matrix",
      "type": "function",
      "description": "PennyLane API: matrix. Found in attribute.html",
      "source_file": "attribute.html",
      "context": "ian = qml.Hamiltonian([1., 1.], [qml.Z(0), qml.Z(1)])     >>> eigvals, eigvecs = np.linalg.eigh(qml.matrix(hamiltonian))     >>> dataset = qml.data.Dataset(hamiltonian = qml.data.attribute(     ...   "
    },
    {
      "id": "qml.data.field",
      "name": "qml.data.field",
      "type": "function",
      "description": "PennyLane API: data.field. Found in dataset.html",
      "source_file": "dataset.html",
      "context": "ant\"]):             \\\"\"\"Dataset describing a quantum oscillator.\\\"\"\"              mass: float = qml.data.field(doc = \"The mass of the particle\")             force_constant: float = qml.data.field(doc "
    },
    {
      "id": "qml.data.Attribute",
      "name": "qml.data.Attribute",
      "type": "function",
      "description": "PennyLane API: data.Attribute. Found in dataset.html",
      "source_file": "dataset.html",
      "context": "mitations under the License. \"\"\" Contains the :class:`~pennylane.data.Dataset` base class, and `qml.data.Attribute` class for declaratively defining dataset classes. \"\"\"  from collections.abc import I"
    },
    {
      "id": "qml.data.list_attributes",
      "name": "qml.data.list_attributes",
      "type": "function",
      "description": "PennyLane API: data.list_attributes. Found in graphql.html",
      "source_file": "graphql.html",
      "context": "func:`~.load_interactive`, :func:`~.list_data_names`, :func:`~.load`.      **Example**      >>> qml.data.list_attributes(data_name=\"qchem\")     ['basis_rot_groupings',      'basis_rot_samples',      '"
    },
    {
      "id": "qml.BasisState",
      "name": "qml.BasisState",
      "type": "class",
      "description": "PennyLane API: BasisState. Found in data_manager.html",
      "source_file": "data_manager.html",
      "context": " qml.device(\"default.qubit\",wires=4)     >>> @qml.qnode(dev)     ... def circuit():     ...     qml.BasisState(H2data.hf_state, wires = [0, 1, 2, 3])     ...     for op in H2data.vqe_gates:     ...   "
    },
    {
      "id": "qml.data.load_interactive",
      "name": "qml.data.load_interactive",
      "type": "function",
      "description": "PennyLane API: data.load_interactive. Found in data_manager.html",
      "source_file": "data_manager.html",
      "context": " :func:`~.list_attributes`, :func:`~.list_data_names`.      .. code-block :: pycon          >>> qml.data.load_interactive()         Please select the data name from the following:             1: qspin"
    },
    {
      "id": "qml.apply",
      "name": "qml.apply",
      "type": "function",
      "description": "PennyLane API: apply. Found in data_manager.html",
      "source_file": "data_manager.html",
      "context": "(H2data.hf_state, wires = [0, 1, 2, 3])     ...     for op in H2data.vqe_gates:     ...         qml.apply(op)     ...     return qml.expval(H2data.hamiltonian)     >>> print(circuit())     -1.07914304"
    },
    {
      "id": "qml.data.list_datasets",
      "name": "qml.data.list_datasets",
      "type": "function",
      "description": "PennyLane API: data.list_datasets. Found in data_manager.html",
      "source_file": "data_manager.html",
      "context": " the provided configuration.\\n\"             \"Please check the available datasets by using the ``qml.data.list_datasets()`` function.\"         )      dataset_urls = [dataset_url for _, dataset_url in d"
    },
    {
      "id": "qml.data.load",
      "name": "qml.data.load",
      "type": "function",
      "description": "PennyLane API: data.load. Found in data_manager.html",
      "source_file": "data_manager.html",
      "context": ", :func:`~.list_attributes`, :func:`~.list_data_names`.      **Example**      The :func:`~pennylane.data.load` function returns a ``list`` with the desired data.      >>> H2datasets = qml.data.load(\"q"
    },
    {
      "id": "qml.devices.Device",
      "name": "qml.devices.Device",
      "type": "function",
      "description": "PennyLane API: devices.Device. Found in debugger.html",
      "source_file": "debugger.html",
      "context": "ev):         \"\"\"Update the global active device.          Args:             dev (Union[Device, \"qml.devices.Device\"]): the active device         \"\"\"         cls.__active_dev = dev      @classmethod   "
    },
    {
      "id": "qml.debug_probs",
      "name": "qml.debug_probs",
      "type": "function",
      "description": "PennyLane API: debug_probs. Found in debugger.html",
      "source_file": "debugger.html",
      "context": "with QueuingManager.stop_recording():         m = expval(op)      return _measure(m)     [docs] def debug_probs(wires=None, op=None):     \"\"\"Compute the probability distribution for the state at the c"
    },
    {
      "id": "qml.breakpoint",
      "name": "qml.breakpoint",
      "type": "function",
      "description": "PennyLane API: breakpoint. Found in debugger.html",
      "source_file": "debugger.html",
      "context": "n debugger (Pdb).      This class is not directly user-facing, but is interfaced with the     ``qml.breakpoint()`` function and ``pldb_device_manager`` context manager.     The former is responsible f"
    },
    {
      "id": "qml.debug_expval",
      "name": "qml.debug_expval",
      "type": "function",
      "description": "PennyLane API: debug_expval. Found in debugger.html",
      "source_file": "debugger.html",
      "context": "   with QueuingManager.stop_recording():         m = state()      return _measure(m)     [docs] def debug_expval(op):     \"\"\"Compute the expectation value of an observable at the     current point in "
    },
    {
      "id": "qml.debug_tape",
      "name": "qml.debug_tape",
      "type": "function",
      "description": "PennyLane API: debug_tape. Found in debugger.html",
      "source_file": "debugger.html",
      "context": "(copied_queue)     return PLDB._execute((qtape,))  # pylint: disable=protected-access    [docs] def debug_tape():     \"\"\"Access the tape of the quantum circuit.      The tape can then be used to acces"
    },
    {
      "id": "qml.debug_state",
      "name": "qml.debug_state",
      "type": "function",
      "description": "PennyLane API: debug_state. Found in debugger.html",
      "source_file": "debugger.html",
      "context": "e     debugger.set_trace(sys._getframe().f_back)  # pylint: disable=protected-access     [docs] def debug_state():     \"\"\"Compute the quantum state at the current point in the quantum circuit.      De"
    },
    {
      "id": "qml.transform",
      "name": "qml.transform",
      "type": "function",
      "description": "PennyLane API: transform. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.exceptions qml.ftqc qml.measureme"
    },
    {
      "id": "qml.set_shots",
      "name": "qml.set_shots",
      "type": "function",
      "description": "PennyLane API: set_shots. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "0.0}      .. code-block:: python3          dev = qml.device(\"default.qubit\", wires=2)          @qml.set_shots(shots=200)         @qml.snapshots         @qml.qnode(dev, interface=None)         def circ"
    },
    {
      "id": "qml.PauliZ",
      "name": "qml.PauliZ",
      "type": "class",
      "description": "PennyLane API: PauliZ. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "    qml.Snapshot(qml.counts())             qml.CNOT(wires=[0, 1])             return qml.expval(qml.PauliZ(0))          with circuit.device.tracker:             out = circuit()      >>> circuit.device"
    },
    {
      "id": "qml.sample",
      "name": "qml.sample",
      "type": "function",
      "description": "PennyLane API: sample. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "rd(wires=0)             qml.CNOT(wires=[0, 1])             qml.Snapshot()             qml.Snapshot(\"sample\", measurement=qml.sample(), shots=5)             return qml.expval(qml.X(0))      >>> qml.sna"
    },
    {
      "id": "qml.PauliX",
      "name": "qml.PauliX",
      "type": "class",
      "description": "PennyLane API: PauliX. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "l.CNOT(wires=[0, 1]),             qml.Snapshot(),         ]          measurements = [qml.expval(qml.PauliX(0))]          tape = qml.tape.QuantumTape(ops, measurements)          tapes, collect_results_"
    },
    {
      "id": "qml.tape.QuantumTape",
      "name": "qml.tape.QuantumTape",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "urements are computed as the execution progresses.     Otherwise, the :func:`QuantumTape <pennylane.tape.QuantumTape>` gets split into several, one for each snapshot, with each aggregating     all the"
    },
    {
      "id": "qml.counts",
      "name": "qml.counts",
      "type": "function",
      "description": "PennyLane API: counts. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "amard(wires=0)             qml.Snapshot()             qml.CNOT(wires=[0, 1])             return qml.counts()      >>> circuit()     {0: array([0.70710678+0.j, 0.        +0.j, 0.70710678+0.j, 0.       "
    },
    {
      "id": "qml.Snapshot",
      "name": "qml.Snapshot",
      "type": "class",
      "description": "PennyLane API: Snapshot. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "unctools import partial  from pennylane.devices import LegacyDeviceFacade from pennylane.ops import Snapshot from pennylane.tape import QuantumScript, QuantumScriptBatch from pennylane.transforms.core"
    },
    {
      "id": "qml.snapshots",
      "name": "qml.snapshots",
      "type": "function",
      "description": "PennyLane API: snapshots. Found in snapshot.html",
      "source_file": "snapshot.html",
      "context": "ific language governing permissions and # limitations under the License. \"\"\" This file contains the snapshots function which extracts measurements from the qnode. \"\"\" import warnings from functools im"
    },
    {
      "id": "qml.CRY",
      "name": "qml.CRY",
      "type": "class",
      "description": "PennyLane API: CRY. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "**op.hyperparameters)``         as arguments.          .. code-block:: python              op = qml.CRY(0.2, wires=[0, 2])             graph = DecompositionGraph(                 operations=[op],     "
    },
    {
      "id": "qml.ops.Controlled",
      "name": "qml.ops.Controlled",
      "type": "function",
      "description": "PennyLane API: ops.Controlled. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "case.             decomps.extend(self._get_pow_decompositions(op))          elif op.op_type in (qml.ops.Controlled, qml.ops.ControlledOp):             decomps.extend(self._get_controlled_decomposition"
    },
    {
      "id": "qml.CRX",
      "name": "qml.CRX",
      "type": "class",
      "description": "PennyLane API: CRX. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "de-block:: python          from pennylane.decomposition import DecompositionGraph          op = qml.CRX(0.5, wires=[0, 1])         graph = DecompositionGraph(             operations=[op],             "
    },
    {
      "id": "qml.ops.Pow",
      "name": "qml.ops.Pow",
      "type": "function",
      "description": "PennyLane API: ops.Pow. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "extend(self._get_adjoint_decompositions(op))          elif (             issubclass(op.op_type, qml.ops.Pow)             and pow_rotation not in decomps             and pow_involutory not in decomps  "
    },
    {
      "id": "qml.register_resources",
      "name": "qml.register_resources",
      "type": "function",
      "description": "PennyLane API: register_resources. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "wing decomposition rule:      .. code-block:: python          import pennylane as qml          @qml.register_resources({qml.H: 2, qml.CNOT: 1})         def my_cz(wires):             qml.H(wires=wires["
    },
    {
      "id": "qml.ops.Conditional",
      "name": "qml.ops.Conditional",
      "type": "function",
      "description": "PennyLane API: ops.Conditional. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "structs the decomposition graph.\"\"\"         for op in operations:             if isinstance(op, qml.ops.Conditional):                 op = op.base  # decompose the base of a classically controlled ope"
    },
    {
      "id": "qml.ops.ControlledOp",
      "name": "qml.ops.ControlledOp",
      "type": "function",
      "description": "PennyLane API: ops.ControlledOp. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "comps.extend(self._get_pow_decompositions(op))          elif op.op_type in (qml.ops.Controlled, qml.ops.ControlledOp):             decomps.extend(self._get_controlled_decompositions(op))          retu"
    },
    {
      "id": "qml.ops.Adjoint",
      "name": "qml.ops.Adjoint",
      "type": "function",
      "description": "PennyLane API: ops.Adjoint. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "comps.get(op_name, []) + list_decomps(op_name)          if (             issubclass(op.op_type, qml.ops.Adjoint)             and self_adjoint not in decomps             and adjoint_rotation not in dec"
    },
    {
      "id": "qml.GlobalPhase",
      "name": "qml.GlobalPhase",
      "type": "class",
      "description": "PennyLane API: GlobalPhase. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "graph = DecompositionGraph(             operations=[op],             gate_set={\"RZ\", \"RX\", \"CNOT\", \"GlobalPhase\"},         )         solution = graph.solve()      >>> with qml.queuing.AnnotatedQueue()"
    },
    {
      "id": "qml.queuing.AnnotatedQueue",
      "name": "qml.queuing.AnnotatedQueue",
      "type": "function",
      "description": "PennyLane API: queuing.AnnotatedQueue. Found in decomposition_graph.html",
      "source_file": "decomposition_graph.html",
      "context": "t={\"RZ\", \"RX\", \"CNOT\", \"GlobalPhase\"},         )         solution = graph.solve()      >>> with qml.queuing.AnnotatedQueue() as q:     ...     solution.decomposition(op)(0.5, wires=[0, 1])     >>> q.q"
    },
    {
      "id": "qml.add_decomps",
      "name": "qml.add_decomps",
      "type": "function",
      "description": "PennyLane API: add_decomps. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "         # This decomposition will be ignored for `QubitUnitary` on more than one wire.         qml.add_decomps(qml.QubitUnitary, zyz_decomposition)      \"\"\"      def _decorator(_qfunc) -> Decompositi"
    },
    {
      "id": "qml.QubitUnitary",
      "name": "qml.QubitUnitary",
      "type": "class",
      "description": "PennyLane API: QubitUnitary. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "th.decomposition import zyz_rotation_angles          # The parameters must be consistent with ``qml.QubitUnitary.resource_keys``         def _zyz_condition(num_wires):             return num_wires == "
    },
    {
      "id": "qml.CRot",
      "name": "qml.CRot",
      "type": "class",
      "description": "PennyLane API: CRot. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "{                   controlled_resource_rep(qml.X, {}, num_control_wires): 2,                   qml.CRot: 1               }            @qml.register_condition(lambda num_control_wires, **_: num_contro"
    },
    {
      "id": "qml.ctrl",
      "name": "qml.ctrl",
      "type": "function",
      "description": "PennyLane API: ctrl. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "):               with allocate(1, state=\"zero\", restored=True) as work_wires:                   qml.ctrl(qml.X(work_wires[0]), control=wires[:-1])                   qml.CRot(*params, wires=[work_wires"
    },
    {
      "id": "qml.register_condition",
      "name": "qml.register_condition",
      "type": "function",
      "description": "PennyLane API: register_condition. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "wires.\"\"\"         return self.zeroed + self.borrowed + self.burnable + self.garbage   @overload def register_condition(condition: Callable) -> Callable[[Callable], DecompositionRule]: ... @overload de"
    },
    {
      "id": "qml.MultiRZ",
      "name": "qml.MultiRZ",
      "type": "class",
      "description": "PennyLane API: MultiRZ. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "`resource_keys`` attribute.         For example, the number of gates in the decomposition for ``qml.MultiRZ`` changes based         on the number of wires it acts on, in contrast to the decomposition "
    },
    {
      "id": "qml.MultiRZ.resource_keys",
      "name": "qml.MultiRZ.resource_keys",
      "type": "class",
      "description": "PennyLane API: MultiRZ.resource_keys. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "e decomposition for ``qml.CNOT``:          >>> qml.CNOT.resource_keys         set()         >>> qml.MultiRZ.resource_keys         {'num_wires'}          The output of ``resource_keys`` indicates that "
    },
    {
      "id": "qml.QubitUnitary.resource_keys",
      "name": "qml.QubitUnitary.resource_keys",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.resource_keys. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "th.decomposition import zyz_rotation_angles          # The parameters must be consistent with ``qml.QubitUnitary.resource_keys``         def _zyz_condition(num_wires):             return num_wires == "
    },
    {
      "id": "qml.decomposition.enable_graph",
      "name": "qml.decomposition.enable_graph",
      "type": "function",
      "description": "PennyLane API: decomposition.enable_graph. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "tal graph-based decomposition system         (introduced in v0.41) is enabled via :func:`~pennylane.decomposition.enable_graph`. This new way of         performing decompositions is generally more res"
    },
    {
      "id": "qml.CNOT.resource_keys",
      "name": "qml.CNOT.resource_keys",
      "type": "class",
      "description": "PennyLane API: CNOT.resource_keys. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "the number of wires it acts on, in contrast to the decomposition for ``qml.CNOT``:          >>> qml.CNOT.resource_keys         set()         >>> qml.MultiRZ.resource_keys         {'num_wires'}        "
    },
    {
      "id": "qml.transforms.decompose",
      "name": "qml.transforms.decompose",
      "type": "function",
      "description": "PennyLane API: transforms.decompose. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "l.H(wires=wires[1])             qml.CZ(wires=wires)             qml.H(wires=wires[1])          @qml.transforms.decompose(gate_set={qml.CZ, qml.H}, fixed_decomps={qml.CNOT: my_cnot})         @qml.qnode"
    },
    {
      "id": "qml.resource_rep",
      "name": "qml.resource_rep",
      "type": "function",
      "description": "PennyLane API: resource_rep. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": ": python              def my_resources(num_wires):                 return {                     qml.resource_rep(qml.MultiRZ, num_wires=num_wires - 1): 2,                     qml.resource_rep(qml.Mult"
    },
    {
      "id": "qml.Rot",
      "name": "qml.Rot",
      "type": "class",
      "description": "PennyLane API: Rot. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "state, and can be deallocated in any state.         Here's a decomposition for a multi-controlled ``Rot`` that uses a zeroed work wire:         .. code-block:: python            import pennylane as qm"
    },
    {
      "id": "qml.list_decomps",
      "name": "qml.list_decomps",
      "type": "function",
      "description": "PennyLane API: list_decomps. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "egister_resources``.      .. seealso:: :func:`~pennylane.register_resources` and :class:`~pennylane.list_decomps`      **Example**      This example demonstrates adding two new decomposition rules to "
    },
    {
      "id": "qml.CZ",
      "name": "qml.CZ",
      "type": "class",
      "description": "PennyLane API: CZ. Found in decomposition_rule.html",
      "source_file": "decomposition_rule.html",
      "context": "ne as qml          qml.decomposition.enable_graph()          @qml.register_resources({qml.H: 2, qml.CZ: 1})         def my_cnot(wires, **_):             qml.H(wires=wires[1])             qml.CZ(wires="
    },
    {
      "id": "qml.CRZ",
      "name": "qml.CRZ",
      "type": "class",
      "description": "PennyLane API: CRZ. Found in resources.html",
      "source_file": "resources.html",
      "context": "WAP: qml.SWAP,         qml.CH: qml.H,         qml.CRX: qml.RX,         qml.CRY: qml.RY,         qml.CRZ: qml.RZ,         qml.CRot: qml.Rot,         qml.ControlledPhaseShift: qml.PhaseShift,     }   de"
    },
    {
      "id": "qml.Toffoli",
      "name": "qml.Toffoli",
      "type": "class",
      "description": "PennyLane API: Toffoli. Found in resources.html",
      "source_file": "resources.html",
      "context": "  \"\"\"The set of custom controlled operations.\"\"\"      return {         qml.CNOT: qml.X,         qml.Toffoli: qml.X,         qml.CZ: qml.Z,         qml.CCZ: qml.Z,         qml.CY: qml.Y,         qml.CS"
    },
    {
      "id": "qml.ops.MultiRZ",
      "name": "qml.ops.MultiRZ",
      "type": "function",
      "description": "PennyLane API: ops.MultiRZ. Found in resources.html",
      "source_file": "resources.html",
      "context": ":          >>> qml.resource_rep(         ...     qml.ops.Controlled,         ...     base_class=qml.ops.MultiRZ,         ...     base_params={'num_wires': 3},         ...     num_control_wires=2,     "
    },
    {
      "id": "qml.ops.op_math.controlled.base_to_custom_ctrl_op",
      "name": "qml.ops.op_math.controlled.base_to_custom_ctrl_op",
      "type": "function",
      "description": "PennyLane API: ops.op_math.controlled.base_to_custom_ctrl_op. Found in resources.html",
      "source_file": "resources.html",
      "context": "m_work_wires,             work_wire_type=work_wire_type,         )      custom_controlled_map = qml.ops.op_math.controlled.base_to_custom_ctrl_op()     custom_ctrl = custom_controlled_map.get((base_cl"
    },
    {
      "id": "qml.decomposition.controlled_resource_rep",
      "name": "qml.decomposition.controlled_resource_rep",
      "type": "function",
      "description": "PennyLane API: decomposition.controlled_resource_rep. Found in resources.html",
      "source_file": "resources.html",
      "context": "trol_values=1, num_work_wires=1)          Alternatively, use the utility function :func:`~pennylane.decomposition.controlled_resource_rep`:          >>> qml.decomposition.controlled_resource_rep(     "
    },
    {
      "id": "qml.ControlledQubitUnitary",
      "name": "qml.ControlledQubitUnitary",
      "type": "class",
      "description": "PennyLane API: ControlledQubitUnitary. Found in resources.html",
      "source_file": "resources.html",
      "context": "ass]      # Special case for controlled qubit unitaries     if base_class in (qml.QubitUnitary, qml.ControlledQubitUnitary):         return _controlled_qubit_unitary_rep(             base_class,      "
    },
    {
      "id": "qml.ops.MidMeasure",
      "name": "qml.ops.MidMeasure",
      "type": "function",
      "description": "PennyLane API: ops.MidMeasure. Found in resources.html",
      "source_file": "resources.html",
      "context": "self.params[\"base_params\"])             return f\"C({base_rep.name})\"         if self.op_type is qml.ops.MidMeasure:             return \"MidMeasureMP\"         return self.op_type.__name__      def __ha"
    },
    {
      "id": "qml.CH",
      "name": "qml.CH",
      "type": "class",
      "description": "PennyLane API: CH. Found in resources.html",
      "source_file": "resources.html",
      "context": ".CZ: qml.Z,         qml.CCZ: qml.Z,         qml.CY: qml.Y,         qml.CSWAP: qml.SWAP,         qml.CH: qml.H,         qml.CRX: qml.RX,         qml.CRY: qml.RY,         qml.CRZ: qml.RZ,         qml.CR"
    },
    {
      "id": "qml.ControlledPhaseShift",
      "name": "qml.ControlledPhaseShift",
      "type": "class",
      "description": "PennyLane API: ControlledPhaseShift. Found in resources.html",
      "source_file": "resources.html",
      "context": "X: qml.RX,         qml.CRY: qml.RY,         qml.CRZ: qml.RZ,         qml.CRot: qml.Rot,         qml.ControlledPhaseShift: qml.PhaseShift,     }   def resolve_work_wire_type(base_work_wires, base_work_"
    },
    {
      "id": "qml.CY",
      "name": "qml.CY",
      "type": "class",
      "description": "PennyLane API: CY. Found in resources.html",
      "source_file": "resources.html",
      "context": "CNOT: qml.X,         qml.Toffoli: qml.X,         qml.CZ: qml.Z,         qml.CCZ: qml.Z,         qml.CY: qml.Y,         qml.CSWAP: qml.SWAP,         qml.CH: qml.H,         qml.CRX: qml.RX,         qml."
    },
    {
      "id": "qml.CSWAP",
      "name": "qml.CSWAP",
      "type": "class",
      "description": "PennyLane API: CSWAP. Found in resources.html",
      "source_file": "resources.html",
      "context": "l.Toffoli: qml.X,         qml.CZ: qml.Z,         qml.CCZ: qml.Z,         qml.CY: qml.Y,         qml.CSWAP: qml.SWAP,         qml.CH: qml.H,         qml.CRX: qml.RX,         qml.CRY: qml.RY,         qm"
    },
    {
      "id": "qml.CCZ",
      "name": "qml.CCZ",
      "type": "class",
      "description": "PennyLane API: CCZ. Found in resources.html",
      "source_file": "resources.html",
      "context": "   return {         qml.CNOT: qml.X,         qml.Toffoli: qml.X,         qml.CZ: qml.Z,         qml.CCZ: qml.Z,         qml.CY: qml.Y,         qml.CSWAP: qml.SWAP,         qml.CH: qml.H,         qml.C"
    },
    {
      "id": "qml.ops.op_math.Prod",
      "name": "qml.ops.op_math.Prod",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Prod. Found in resources.html",
      "source_file": "resources.html",
      "context": "se_class\"] = base_rep.op_type         params[\"base_params\"] = base_rep.params     if op_type is qml.ops.op_math.Prod:         resources = defaultdict(int)         for rep, count in params[\"resources\"]"
    },
    {
      "id": "qml.ops.Controlled.resource_keys",
      "name": "qml.ops.Controlled.resource_keys",
      "type": "function",
      "description": "PennyLane API: ops.Controlled.resource_keys. Found in resources.html",
      "source_file": "resources.html",
      "context": "he resource function, we find the resource keys         of ``qml.ops.Controlled``:          >>> qml.ops.Controlled.resource_keys         {'base_class',          'base_params',          'num_control_wi"
    },
    {
      "id": "qml.MultiControlledX",
      "name": "qml.MultiControlledX",
      "type": "class",
      "description": "PennyLane API: MultiControlledX. Found in resources.html",
      "source_file": "resources.html",
      "context": "e_type,         )      # Special case for when the base class is X     if base_class in (qml.X, qml.MultiControlledX):         return _controlled_x_rep(             base_class,             base_params"
    },
    {
      "id": "qml.ops.ChangeOpBasis",
      "name": "qml.ops.ChangeOpBasis",
      "type": "function",
      "description": "PennyLane API: ops.ChangeOpBasis. Found in resources.html",
      "source_file": "resources.html",
      "context": "ass(op_type, qml.ops.Pow):         return pow_resource_rep(**params)     if issubclass(op_type, qml.ops.ChangeOpBasis):         return change_op_basis_resource_rep(**params)     if op_type is qml.ops."
    },
    {
      "id": "qml.defer_measurements",
      "name": "qml.defer_measurements",
      "type": "function",
      "description": "PennyLane API: defer_measurements. Found in _legacy_device.html",
      "source_file": "_legacy_device.html",
      "context": "ments are not natively supported on device {self.short_name}. \"                     \"Apply the @qml.defer_measurements decorator to your quantum function to \"                     \"simulate the applica"
    },
    {
      "id": "qml.devices.DefaultQutrit",
      "name": "qml.devices.DefaultQutrit",
      "type": "function",
      "description": "PennyLane API: devices.DefaultQutrit. Found in _legacy_device.html",
      "source_file": "_legacy_device.html",
      "context": "illustrate, if \"dev\" is of type LegacyDeviceFacade, and a user is     checking \"isinstance(dev, qml.devices.DefaultQutrit)\", the overridden     \"__instancecheck__\" will look behind the facade, and wil"
    },
    {
      "id": "qml.math.get_interface",
      "name": "qml.math.get_interface",
      "type": "function",
      "description": "PennyLane API: math.get_interface. Found in _qubit_device.html",
      "source_file": "_qubit_device.html",
      "context": ", s2], bin_size=shot_tuple.shots)              # This will likely be required:             # if qml.math.get_interface(*r) == \"jax\":             #     r = r[0]              if single_measurement:     "
    },
    {
      "id": "qml.math.mutual_info",
      "name": "qml.math.mutual_info",
      "type": "function",
      "description": "PennyLane API: math.mutual_info. Found in _qutrit_device.html",
      "source_file": "_qutrit_device.html",
      "context": "turn type. Currently, qml.math is hard coded to calculate this for qubit         # states (see `qml.math.mutual_info()`), so it needs to be updated before MutualInfo can be supported for qutrits.     "
    },
    {
      "id": "qml.math.reduced_dm",
      "name": "qml.math.reduced_dm",
      "type": "function",
      "description": "PennyLane API: math.reduced_dm. Found in _qutrit_device.html",
      "source_file": "_qutrit_device.html",
      "context": "turn type. Currently, qml.math is hard coded to calculate this for qubit         # states (see `qml.math.reduced_dm()`), so it needs to be updated before DensityMatrix can be supported for qutrits.   "
    },
    {
      "id": "qml.math.vn_entropy",
      "name": "qml.math.vn_entropy",
      "type": "function",
      "description": "PennyLane API: math.vn_entropy. Found in _qutrit_device.html",
      "source_file": "_qutrit_device.html",
      "context": "turn type. Currently, qml.math is hard coded to calculate this for qubit         # states (see `qml.math.vn_entropy()`), so it needs to be updated before VnEntropy can be supported for qutrits.       "
    },
    {
      "id": "qml.PauliError",
      "name": "qml.PauliError",
      "type": "class",
      "description": "PennyLane API: PauliError. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "one,     \"BasisState\": None,     \"StatePrep\": None,     \"Snapshot\": None,     \"Barrier\": None,     \"PauliError\": \"CORRELATED_ERROR\",     \"BitFlip\": \"X_ERROR\",     \"PhaseFlip\": \"Z_ERROR\",     \"Depolari"
    },
    {
      "id": "qml.ISWAP",
      "name": "qml.ISWAP",
      "type": "class",
      "description": "PennyLane API: ISWAP. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": " \"S_DAG\",     \"SX\": \"SX\",     \"Adjoint(SX)\": \"SX_DAG\",     \"CNOT\": \"CNOT\",     \"SWAP\": \"SWAP\",     \"ISWAP\": \"ISWAP\",     \"Adjoint(ISWAP)\": \"ISWAP_DAG\",     \"CY\": \"CY\",     \"CZ\": \"CZ\",     \"GlobalPhase"
    },
    {
      "id": "qml.Projector",
      "name": "qml.Projector",
      "type": "class",
      "description": "PennyLane API: Projector. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "ation import Channel, Operator, StatePrepBase from pennylane.ops.qubit.observables import BasisStateProjector from pennylane.pauli import PauliWord, pauli_decompose from pennylane.pauli.utils import _"
    },
    {
      "id": "qml.devices.DefaultClifford",
      "name": "qml.devices.DefaultClifford",
      "type": "function",
      "description": "PennyLane API: devices.DefaultClifford. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "ml.tape.QuantumScript([qml.Hadamard(wires=0)], [qml.expval(qml.Z(0)), qml.state()])         >>> qml.devices.DefaultClifford().simulate(qs)         (array(0),          array([[0, 1, 0],                "
    },
    {
      "id": "qml.PhaseFlip",
      "name": "qml.PhaseFlip",
      "type": "class",
      "description": "PennyLane API: PhaseFlip. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "t\": None,     \"Barrier\": None,     \"PauliError\": \"CORRELATED_ERROR\",     \"BitFlip\": \"X_ERROR\",     \"PhaseFlip\": \"Z_ERROR\",     \"DepolarizingChannel\": \"DEPOLARIZE1\", }    [docs] def operation_stopping_"
    },
    {
      "id": "qml.tape.QuantumScript",
      "name": "qml.tape.QuantumScript",
      "type": "function",
      "description": "PennyLane API: tape.QuantumScript. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "lowing:      .. code-block:: python          num_qscripts = 5          qscripts = [             qml.tape.QuantumScript(                 [qml.Hadamard(wires=[0]), qml.CNOT(wires=[0, 1])],              "
    },
    {
      "id": "qml.DepolarizingChannel",
      "name": "qml.DepolarizingChannel",
      "type": "class",
      "description": "PennyLane API: DepolarizingChannel. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "e,     \"PauliError\": \"CORRELATED_ERROR\",     \"BitFlip\": \"X_ERROR\",     \"PhaseFlip\": \"Z_ERROR\",     \"DepolarizingChannel\": \"DEPOLARIZE1\", }    [docs] def operation_stopping_condition(op: Operator) -> b"
    },
    {
      "id": "qml.BitFlip",
      "name": "qml.BitFlip",
      "type": "class",
      "description": "PennyLane API: BitFlip. Found in default_clifford.html",
      "source_file": "default_clifford.html",
      "context": "ePrep\": None,     \"Snapshot\": None,     \"Barrier\": None,     \"PauliError\": \"CORRELATED_ERROR\",     \"BitFlip\": \"X_ERROR\",     \"PhaseFlip\": \"Z_ERROR\",     \"DepolarizingChannel\": \"DEPOLARIZE1\", }    [doc"
    },
    {
      "id": "qml.math.squeeze",
      "name": "qml.math.squeeze",
      "type": "function",
      "description": "PennyLane API: math.squeeze. Found in default_gaussian.html",
      "source_file": "default_gaussian.html",
      "context": "h_execute(self, circuits):         results = super().batch_execute(circuits)         results = [qml.math.squeeze(res) for res in results]         return results     _modules/pennylane/devices/default_"
    },
    {
      "id": "qml.PolyXP",
      "name": "qml.PolyXP",
      "type": "class",
      "description": "PennyLane API: PolyXP. Found in default_gaussian.html",
      "source_file": "default_gaussian.html",
      "context": "ld make heisenberg_obs a class method or a static method to avoid this being a 'hack'?     op = qml.PolyXP(Q, wires=wires)     Q = op.heisenberg_obs(device_wires)      if Q.ndim == 1:         d = np.r"
    },
    {
      "id": "qml.math.random.randint",
      "name": "qml.math.random.randint",
      "type": "function",
      "description": "PennyLane API: math.random.randint. Found in default_mixed.html",
      "source_file": "default_mixed.html",
      "context": "1].\")         super().__init__(wires=wires, shots=shots)          # Seed setting         seed = qml.math.random.randint(0, high=10000000) if seed == \"global\" else seed         if qml.math.get_interfac"
    },
    {
      "id": "qml.devices.default_qubit.accepted_sample_measurement",
      "name": "qml.devices.default_qubit.accepted_sample_measurement",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.accepted_sample_measurement. Found in default_mixed.html",
      "source_file": "default_mixed.html",
      "context": "ements=qml.devices.default_qubit.accepted_analytic_measurement,             sample_measurements=qml.devices.default_qubit.accepted_sample_measurement,             name=self.name,         )         com"
    },
    {
      "id": "qml.devices.default_qubit.accepted_analytic_measurement",
      "name": "qml.devices.default_qubit.accepted_analytic_measurement",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.accepted_analytic_measurement. Found in default_mixed.html",
      "source_file": "default_mixed.html",
      "context": "le_pileline.add_transform(             validate_measurements,             analytic_measurements=qml.devices.default_qubit.accepted_analytic_measurement,             sample_measurements=qml.devices.def"
    },
    {
      "id": "qml.math.random.default_rng",
      "name": "qml.math.random.default_rng",
      "type": "function",
      "description": "PennyLane API: math.random.default_rng. Found in default_mixed.html",
      "source_file": "default_mixed.html",
      "context": "ml.math.get_interface(seed) == \"jax\":             self._prng_key = seed             self._rng = qml.math.random.default_rng(None)         else:             self._prng_key = None             self._rng "
    },
    {
      "id": "qml.measurements.StateMP",
      "name": "qml.measurements.StateMP",
      "type": "function",
      "description": "PennyLane API: measurements.StateMP. Found in default_mixed.html",
      "source_file": "default_mixed.html",
      "context": "    \"\"\"     if not tape.shots:         for m in tape.measurements:             if isinstance(m, qml.measurements.StateMP):                 warnings.warn(f\"Measurement {m} is not affected by readout er"
    },
    {
      "id": "qml.StronglyEntanglingLayers",
      "name": "qml.StronglyEntanglingLayers",
      "type": "class",
      "description": "PennyLane API: StronglyEntanglingLayers. Found in default_qubit.html",
      "source_file": "default_qubit.html",
      "context": "k:: python          n_layers = 5         n_wires = 10         num_qscripts = 5          shape = qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)         rng = qml.numpy.random.de"
    },
    {
      "id": "qml.numpy.random.default_rng",
      "name": "qml.numpy.random.default_rng",
      "type": "function",
      "description": "PennyLane API: numpy.random.default_rng. Found in default_qubit.html",
      "source_file": "default_qubit.html",
      "context": " Generator, jax.random.PRNGKey]): A             seed-like parameter matching that of ``seed`` for ``numpy.random.default_rng``, or             a request to seed from numpy's global random number gener"
    },
    {
      "id": "qml.counts.",
      "name": "qml.counts.",
      "type": "function",
      "description": "PennyLane API: counts.. Found in default_qubit.html",
      "source_file": "default_qubit.html",
      "context": "in tape.measurements):         raise NotImplementedError(\"The JAX-JIT interface doesn't support qml.counts.\")     return (tape,), null_postprocessing     [docs] @transform def adjoint_state_measuremen"
    },
    {
      "id": "qml.StronglyEntanglingLayers.shape",
      "name": "qml.StronglyEntanglingLayers.shape",
      "type": "class",
      "description": "PennyLane API: StronglyEntanglingLayers.shape. Found in default_qubit.html",
      "source_file": "default_qubit.html",
      "context": "k:: python          n_layers = 5         n_wires = 10         num_qscripts = 5          shape = qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)         rng = qml.numpy.random.de"
    },
    {
      "id": "qml.math.sum",
      "name": "qml.math.sum",
      "type": "function",
      "description": "PennyLane API: math.sum. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "staticmethod(qml.math.imag)      @staticmethod     def _reduce_sum(array, axes):         return qml.math.sum(array, tuple(axes))      @staticmethod     def _asarray(array, dtype=None):         # Suppo"
    },
    {
      "id": "qml.math.roll",
      "name": "qml.math.roll",
      "type": "function",
      "description": "PennyLane API: math.roll. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "= staticmethod(qml.math.stack)     _conj = staticmethod(qml.math.conj)     _roll = staticmethod(qml.math.roll)     _cast = staticmethod(qml.math.cast)     _tensordot = staticmethod(qml.math.tensordot)"
    },
    {
      "id": "qml.math.dot",
      "name": "qml.math.dot",
      "type": "function",
      "description": "PennyLane API: math.dot. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "hod(qml.math.flatten)     _transpose = staticmethod(qml.math.transpose)     _dot = staticmethod(qml.math.dot)     _stack = staticmethod(qml.math.stack)     _conj = staticmethod(qml.math.conj)     _rol"
    },
    {
      "id": "qml.math.conj",
      "name": "qml.math.conj",
      "type": "function",
      "description": "PennyLane API: math.conj. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "= staticmethod(qml.math.dot)     _stack = staticmethod(qml.math.stack)     _conj = staticmethod(qml.math.conj)     _roll = staticmethod(qml.math.roll)     _cast = staticmethod(qml.math.cast)     _tens"
    },
    {
      "id": "qml.QutritBasisState",
      "name": "qml.QutritBasisState",
      "type": "class",
      "description": "PennyLane API: QutritBasisState. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "   \"THadamard\",         \"Adjoint(THadamard)\",         \"TRX\",         \"TRY\",         \"TRZ\",         \"QutritBasisState\",     }      # Identity is supported as an observable for qml.state() to work corre"
    },
    {
      "id": "qml.math.imag",
      "name": "qml.math.imag",
      "type": "function",
      "description": "PennyLane API: math.imag. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "aticmethod(qml.math.tensordot)     _real = staticmethod(qml.math.real)     _imag = staticmethod(qml.math.imag)      @staticmethod     def _reduce_sum(array, axes):         return qml.math.sum(array, t"
    },
    {
      "id": "qml.math.reshape",
      "name": "qml.math.reshape",
      "type": "function",
      "description": "PennyLane API: math.reshape. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "tatic methods to use qml.math to allow for backprop differentiation     _reshape = staticmethod(qml.math.reshape)     _flatten = staticmethod(qml.math.flatten)     _transpose = staticmethod(qml.math.t"
    },
    {
      "id": "qml.math.exp",
      "name": "qml.math.exp",
      "type": "function",
      "description": "PennyLane API: math.exp. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": ".addHandler(logging.NullHandler())  # tolerance for numerical errors tolerance = 1e-10  OMEGA = qml.math.exp(2 * np.pi * 1j / 3)   def _get_slice(index, axis, num_axes):     \"\"\"Allows slicing along an"
    },
    {
      "id": "qml.math.cast",
      "name": "qml.math.cast",
      "type": "function",
      "description": "PennyLane API: math.cast. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": " = staticmethod(qml.math.conj)     _roll = staticmethod(qml.math.roll)     _cast = staticmethod(qml.math.cast)     _tensordot = staticmethod(qml.math.tensordot)     _real = staticmethod(qml.math.real)"
    },
    {
      "id": "qml.math.tensordot",
      "name": "qml.math.tensordot",
      "type": "function",
      "description": "PennyLane API: math.tensordot. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "aticmethod(qml.math.roll)     _cast = staticmethod(qml.math.cast)     _tensordot = staticmethod(qml.math.tensordot)     _real = staticmethod(qml.math.real)     _imag = staticmethod(qml.math.imag)     "
    },
    {
      "id": "qml.math.flatten",
      "name": "qml.math.flatten",
      "type": "function",
      "description": "PennyLane API: math.flatten. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "kprop differentiation     _reshape = staticmethod(qml.math.reshape)     _flatten = staticmethod(qml.math.flatten)     _transpose = staticmethod(qml.math.transpose)     _dot = staticmethod(qml.math.dot"
    },
    {
      "id": "qml.math.stack",
      "name": "qml.math.stack",
      "type": "function",
      "description": "PennyLane API: math.stack. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "taticmethod(qml.math.transpose)     _dot = staticmethod(qml.math.dot)     _stack = staticmethod(qml.math.stack)     _conj = staticmethod(qml.math.conj)     _roll = staticmethod(qml.math.roll)     _cas"
    },
    {
      "id": "qml.math.convert_like",
      "name": "qml.math.convert_like",
      "type": "function",
      "description": "PennyLane API: math.convert_like. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "       basis_states = 3 ** (self.num_wires - 1 - np.array(device_wires))         basis_states = qml.math.convert_like(basis_states, state)         num = int(qml.math.dot(state, basis_states))         "
    },
    {
      "id": "qml.math.transpose",
      "name": "qml.math.transpose",
      "type": "function",
      "description": "PennyLane API: math.transpose. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "d(qml.math.reshape)     _flatten = staticmethod(qml.math.flatten)     _transpose = staticmethod(qml.math.transpose)     _dot = staticmethod(qml.math.dot)     _stack = staticmethod(qml.math.stack)     "
    },
    {
      "id": "qml.math.real",
      "name": "qml.math.real",
      "type": "function",
      "description": "PennyLane API: math.real. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "ethod(qml.math.cast)     _tensordot = staticmethod(qml.math.tensordot)     _real = staticmethod(qml.math.real)     _imag = staticmethod(qml.math.imag)      @staticmethod     def _reduce_sum(array, axe"
    },
    {
      "id": "qml.Identity",
      "name": "qml.Identity",
      "type": "class",
      "description": "PennyLane API: Identity. Found in default_qutrit.html",
      "source_file": "default_qutrit.html",
      "context": "  # TODO: Update list of operations and observables once more are added     operations = {         \"Identity\",         \"QutritUnitary\",         \"ControlledQutritUnitary\",         \"TShift\",         \"Ad"
    },
    {
      "id": "qml.TritFlip",
      "name": "qml.TritFlip",
      "type": "class",
      "description": "PennyLane API: TritFlip. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": " transmon-based qudits.         readout_misclassification_probs (List[float]): Inputs for :class:`~.TritFlip` channel             of the form :math:`[p_{01}, p_{02}, p_{12}]`. This error models miscla"
    },
    {
      "id": "qml.measurements.MeasurementProcess",
      "name": "qml.measurements.MeasurementProcess",
      "type": "function",
      "description": "PennyLane API: measurements.MeasurementProcess. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": "t\"} | channels     return op.name in expected_set     [docs] def accepted_sample_measurement(m: qml.measurements.MeasurementProcess) -> bool:     \"\"\"Specifies whether a measurement is accepted when sa"
    },
    {
      "id": "qml.measurements.SampleMeasurement",
      "name": "qml.measurements.SampleMeasurement",
      "type": "function",
      "description": "PennyLane API: measurements.SampleMeasurement. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": ":     \"\"\"Specifies whether a measurement is accepted when sampling.\"\"\"     return isinstance(m, qml.measurements.SampleMeasurement)     [docs] @qml.transform def warn_readout_error_state(     tape: qm"
    },
    {
      "id": "qml.GellMann",
      "name": "qml.GellMann",
      "type": "class",
      "description": "PennyLane API: GellMann. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": "tLogger(__name__) logger.addHandler(logging.NullHandler())   observables = {     \"THermitian\",     \"GellMann\", }    [docs] def observable_stopping_condition(obs: qml.operation.Operator) -> bool:     \""
    },
    {
      "id": "qml.QutritUnitary",
      "name": "qml.QutritUnitary",
      "type": "class",
      "description": "PennyLane API: QutritUnitary. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": "      unitary = scipy.stats.unitary_group(dim=3**n_wires, seed=(42 + i)).rvs()             op = qml.QutritUnitary(unitary, wires=range(n_wires))             qs = qml.tape.QuantumScript([op], [qml.expv"
    },
    {
      "id": "qml.TRX",
      "name": "qml.TRX",
      "type": "class",
      "description": "PennyLane API: TRX. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": "        import jax          @jax.jit         def f(x):             qs = qml.tape.QuantumScript([qml.TRX(x, 0)], [qml.expval(qml.GellMann(0, 3))])             program, execution_config = dev.preprocess"
    },
    {
      "id": "qml.queuing.QueuingManager.stop_recording",
      "name": "qml.queuing.QueuingManager.stop_recording",
      "type": "function",
      "description": "PennyLane API: queuing.QueuingManager.stop_recording. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": "  measure_funcs = []     if readout_relaxation_probs is not None:         try:             with qml.queuing.QueuingManager.stop_recording():                 qml.QutritAmplitudeDamping(*readout_relaxat"
    },
    {
      "id": "qml.QutritAmplitudeDamping",
      "name": "qml.QutritAmplitudeDamping",
      "type": "class",
      "description": "PennyLane API: QutritAmplitudeDamping. Found in default_qutrit_mixed.html",
      "source_file": "default_qutrit_mixed.html",
      "context": "each measured wire.      Args:         readout_relaxation_probs (List[float]): Inputs for :class:`~.QutritAmplitudeDamping` channel             of the form :math:`[\\gamma_{10}, \\gamma_{20}, \\gamma_{21"
    },
    {
      "id": "qml.DoubleExcitation",
      "name": "qml.DoubleExcitation",
      "type": "class",
      "description": "PennyLane API: DoubleExcitation. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "      \"SingleExcitation\",         \"SingleExcitationPlus\",         \"SingleExcitationMinus\",         \"DoubleExcitation\",         \"QubitCarry\",         \"QubitSum\",         \"OrbitalRotation\",         \"ECR"
    },
    {
      "id": "qml.math.zeros",
      "name": "qml.math.zeros",
      "type": "function",
      "description": "PennyLane API: math.zeros. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "len(sites) == 1:             # Special case for a single-qubit Pauli rotation             arr = qml.math.zeros((1, 1, 2, 2), dtype=complex)             arr[0, 0] = _PAULI_MATRICES[P] * (-1j) * qml.mat"
    },
    {
      "id": "qml.transforms.broadcast_expand",
      "name": "qml.transforms.broadcast_expand",
      "type": "function",
      "description": "PennyLane API: transforms.broadcast_expand. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "wires=self.wires,             target_gates=_operations,         )         program.add_transform(qml.transforms.broadcast_expand)          return program, config    [docs]     def execute(         self"
    },
    {
      "id": "qml.PauliRot",
      "name": "qml.PauliRot",
      "type": "class",
      "description": "PennyLane API: PauliRot. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "rry\",         \"QubitSum\",         \"OrbitalRotation\",         \"ECR\",         \"BlockEncode\",         \"PauliRot\",         \"MultiRZ\",         \"TrotterProduct\",     } ) # The set of supported operations.  "
    },
    {
      "id": "qml.StatePrep",
      "name": "qml.StatePrep",
      "type": "class",
      "description": "PennyLane API: StatePrep. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "      ),                 ),             )         elif operations and isinstance(operations[0], qml.StatePrep):             op = operations.pop(0)             self._quimb_circuit = self._initial_quimb"
    },
    {
      "id": "qml.TrotterProduct",
      "name": "qml.TrotterProduct",
      "type": "class",
      "description": "PennyLane API: TrotterProduct. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "talRotation\",         \"ECR\",         \"BlockEncode\",         \"PauliRot\",         \"MultiRZ\",         \"TrotterProduct\",     } ) # The set of supported operations.   _observables = frozenset(     {       "
    },
    {
      "id": "qml.PauliY",
      "name": "qml.PauliY",
      "type": "class",
      "description": "PennyLane API: PauliY. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "bitUnitary\",         \"MultiControlledX\",         \"DiagonalQubitUnitary\",         \"PauliX\",         \"PauliY\",         \"PauliZ\",         \"GlobalPhase\",         \"Hadamard\",         \"S\",         \"T\",     "
    },
    {
      "id": "qml.wires.Wires",
      "name": "qml.wires.Wires",
      "type": "function",
      "description": "PennyLane API: wires.Wires. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "ata type.\"\"\"         return self._c_dtype      def _initial_quimb_circuit(         self, wires: qml.wires.Wires, psi0=None     ) -> Union[\"qtn.CircuitMPS\", \"qtn.Circuit\"]:         \"\"\"         Initiali"
    },
    {
      "id": "qml.math.eye",
      "name": "qml.math.eye",
      "type": "function",
      "description": "PennyLane API: math.eye. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "      arr[0, 0] = _PAULI_MATRICES[P] * (-1j) * qml.math.sin(theta / 2)             arr[0, 0] += qml.math.eye(2, dtype=complex) * qml.math.cos(theta / 2)          # Multi-qubit Pauli rotations are impl"
    },
    {
      "id": "qml.math.cos",
      "name": "qml.math.cos",
      "type": "function",
      "description": "PennyLane API: math.cos. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "[P] * (-1j) * qml.math.sin(theta / 2)             arr[0, 0] += qml.math.eye(2, dtype=complex) * qml.math.cos(theta / 2)          # Multi-qubit Pauli rotations are implemented with an MPO chain. Each t"
    },
    {
      "id": "qml.math.sin",
      "name": "qml.math.sin",
      "type": "function",
      "description": "PennyLane API: math.sin. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "ml.math.zeros((1, 1, 2, 2), dtype=complex)             arr[0, 0] = _PAULI_MATRICES[P] * (-1j) * qml.math.sin(theta / 2)             arr[0, 0] += qml.math.eye(2, dtype=complex) * qml.math.cos(theta / 2"
    },
    {
      "id": "qml.var",
      "name": "qml.var",
      "type": "function",
      "description": "PennyLane API: var. Found in default_tensor.html",
      "source_file": "default_tensor.html",
      "context": "cluding ``default.tensor``.     At present, the supported measurement types are expectation values, variances, and state measurements.     Finally, ``UserWarnings`` from the ``cotengra`` package may a"
    },
    {
      "id": "qml.Permute",
      "name": "qml.Permute",
      "type": "class",
      "description": "PennyLane API: Permute. Found in device_api.html",
      "source_file": "device_api.html",
      "context": "sibility to perform any         validation or provide clearer error messages.          >>> op = qml.Permute([\"c\", 3,\"a\",2,0], wires=[3,2,\"a\",0,\"c\"])         >>> circuit = qml.tape.QuantumScript([op], "
    },
    {
      "id": "qml.devices.ExecutionConfig",
      "name": "qml.devices.ExecutionConfig",
      "type": "function",
      "description": "PennyLane API: devices.ExecutionConfig. Found in device_api.html",
      "source_file": "device_api.html",
      "context": "d.Zero(jax.core.ShapedArray((), float))         >>> tangents = (zero, 1.0)         >>> config = qml.devices.ExecutionConfig(gradient_method=\"adjoint\")         >>> dev = qml.device('default.qubit', wir"
    },
    {
      "id": "qml.IsingXX",
      "name": "qml.IsingXX",
      "type": "class",
      "description": "PennyLane API: IsingXX. Found in device_constructor.html",
      "source_file": "device_constructor.html",
      "context": "     circuits in terms of CNOTs. On an ion trap device, CNOT can be implemented         using the ``IsingXX`` gate. We first define a decomposition function         (such functions have the signature "
    },
    {
      "id": "qml.about",
      "name": "qml.about",
      "type": "function",
      "description": "PennyLane API: about. Found in device_constructor.html",
      "source_file": "device_constructor.html",
      "context": "ane.ai/plugins>`_ for more     details. To list all currently installed devices, run     :func:`qml.about <pennylane.about>`.      Args:         name (str): the name of the device to load         wire"
    },
    {
      "id": "qml.devices.LegacyDevice.",
      "name": "qml.devices.LegacyDevice.",
      "type": "function",
      "description": "PennyLane API: devices.LegacyDevice.. Found in legacy_facade.html",
      "source_file": "legacy_facade.html",
      "context": "        raise ValueError(                 \"The LegacyDeviceFacade only accepts a device of type qml.devices.LegacyDevice.\"             )          self._device = device         self.capabilities = None"
    },
    {
      "id": "qml.device.LegacyDevice",
      "name": "qml.device.LegacyDevice",
      "type": "function",
      "description": "PennyLane API: device.LegacyDevice. Found in legacy_facade.html",
      "source_file": "legacy_facade.html",
      "context": "device from the old ``qml.Device`` interface into the new interface.      Args:         device (qml.device.LegacyDevice): a device that follows the legacy device interface.      >>> from pennylane.dev"
    },
    {
      "id": "qml.Device",
      "name": "qml.Device",
      "type": "class",
      "description": "PennyLane API: Device. Found in legacy_facade.html",
      "source_file": "legacy_facade.html",
      "context": "he specific language governing permissions and # limitations under the License. \"\"\" Defines a LegacyDeviceFacade class for converting legacy devices to the new interface. \"\"\"  import warnings  # pylin"
    },
    {
      "id": "qml.Tracker",
      "name": "qml.Tracker",
      "type": "class",
      "description": "PennyLane API: Tracker. Found in null_qubit.html",
      "source_file": "null_qubit.html",
      "context": "pval(qml.Z(i)) for i in range(n_wires)]          params = np.random.random(shape)          with qml.Tracker(dev) as tracker:             circuit(params)      >>> tracker.history[\"resources\"][0]     nu"
    },
    {
      "id": "qml.classical_shadow",
      "name": "qml.classical_shadow",
      "type": "function",
      "description": "PennyLane API: classical_shadow. Found in null_qubit.html",
      "source_file": "null_qubit.html",
      "context": "     raise ValueError(             \"Parameter broadcasting is not supported with null.qubit and qml.classical_shadow\"         )     shape = mp.shape(shots, num_device_wires)     return math.zeros(shap"
    },
    {
      "id": "qml.measurements.CountsMP",
      "name": "qml.measurements.CountsMP",
      "type": "function",
      "description": "PennyLane API: measurements.CountsMP. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": ", qml.measurements.StateMP)     >>> def shots_measurements(m):     ...     return isinstance(m, qml.measurements.CountsMP)     >>> tape = qml.tape.QuantumScript([], [qml.expval(qml.Z(0))])     >>> val"
    },
    {
      "id": "qml.devices.preprocess.measurements_from_samples",
      "name": "qml.devices.preprocess.measurements_from_samples",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.measurements_from_samples. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": " and convert the two measurements to a single `sample` measurement:      >>> (new_tape, ), fn = qml.devices.preprocess.measurements_from_samples(tape)     >>> new_tape.measurements     [sample(wires=["
    },
    {
      "id": "qml.transforms.dynamic_one_shot",
      "name": "qml.transforms.dynamic_one_shot",
      "type": "function",
      "description": "PennyLane API: transforms.dynamic_one_shot. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": "e device should determine which mcm method to use, and explicitly include         :func:`~pennylane.transforms.dynamic_one_shot` or :func:`~pennylane.transforms.defer_measurements`         in its prep"
    },
    {
      "id": "qml.allocation.allocate",
      "name": "qml.allocation.allocate",
      "type": "function",
      "description": "PennyLane API: allocation.allocate. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": "cess import device_resolve_dynamic_wires     >>> def f():     ...     qml.H(0)     ...     with qml.allocation.allocate(1) as wires:     ...         qml.X(wires)     ...     with qml.allocation.alloca"
    },
    {
      "id": "qml.dynamic_one_shot",
      "name": "qml.dynamic_one_shot",
      "type": "function",
      "description": "PennyLane API: dynamic_one_shot. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": "tBatch from pennylane.transforms import (     defer_measurements,     diagonalize_measurements,     dynamic_one_shot,     resolve_dynamic_wires, ) from pennylane.transforms.core import transform from "
    },
    {
      "id": "qml.transforms.defer_measurements",
      "name": "qml.transforms.defer_measurements",
      "type": "function",
      "description": "PennyLane API: transforms.defer_measurements. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": " and explicitly include         :func:`~pennylane.transforms.dynamic_one_shot` or :func:`~pennylane.transforms.defer_measurements`         in its preprocess transforms if necessary. See :func:`Default"
    },
    {
      "id": "qml.devices.preprocess.measurements_from_counts",
      "name": "qml.devices.preprocess.measurements_from_counts",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.measurements_from_counts. Found in preprocess.html",
      "source_file": "preprocess.html",
      "context": " and convert the two measurements to a single `counts` measurement:      >>> (new_tape, ), fn = qml.devices.preprocess.measurements_from_counts(tape)     >>> new_tape.measurements     [CountsMP(wires="
    },
    {
      "id": "qml.dot",
      "name": "qml.dot",
      "type": "function",
      "description": "PennyLane API: dot. Found in adjoint_jacobian.html",
      "source_file": "adjoint_jacobian.html",
      "context": "many-branches  logger = logging.getLogger(__name__) logger.addHandler(logging.NullHandler())   def _dot_product_real(bra, ket, num_wires):     \"\"\"Helper for calculating the inner product for adjoint d"
    },
    {
      "id": "qml.operation.StatePrepBase",
      "name": "qml.operation.StatePrepBase",
      "type": "function",
      "description": "PennyLane API: operation.StatePrepBase. Found in adjoint_jacobian.html",
      "source_file": "adjoint_jacobian.html",
      "context": "r details on the algorithm.     \"\"\"     jacobian = []      has_state_prep = isinstance(tape[0], qml.operation.StatePrepBase)     state = create_initial_state(tape.wires, tape[0] if has_state_prep else"
    },
    {
      "id": "qml.map_wires",
      "name": "qml.map_wires",
      "type": "function",
      "description": "PennyLane API: map_wires. Found in adjoint_jacobian.html",
      "source_file": "adjoint_jacobian.html",
      "context": "pe.num_wires)):         wire_map = {w: i for i, w in enumerate(tape.wires)}         tapes, fn = qml.map_wires(tape, wire_map)         tape = fn(tapes)      ket = state if state is not None else get_fi"
    },
    {
      "id": "qml.GroverOperator",
      "name": "qml.GroverOperator",
      "type": "class",
      "description": "PennyLane API: GroverOperator. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": " math.roll(state, 1, ax)     return state   @apply_operation.register def apply_grover(     op: qml.GroverOperator,     state,     is_state_batched: bool = False,     debugger=None,     **_, ):     \"\""
    },
    {
      "id": "qml.pulse.ParametrizedEvolution",
      "name": "qml.pulse.ParametrizedEvolution",
      "type": "function",
      "description": "PennyLane API: pulse.ParametrizedEvolution. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "ble=import-outside-toplevel @apply_operation.register def apply_parametrized_evolution(     op: qml.pulse.ParametrizedEvolution,     state,     is_state_batched: bool = False,     debugger=None,     *"
    },
    {
      "id": "qml.devices.qubit.measure_with_samples",
      "name": "qml.devices.qubit.measure_with_samples",
      "type": "function",
      "description": "PennyLane API: devices.qubit.measure_with_samples. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "shots\")     else:         shots = op.hyperparameters[\"shots\"]      if shots:         snapshot = qml.devices.qubit.measure_with_samples(             [measurement],             state,             shots,"
    },
    {
      "id": "qml.devices.qubit.measure",
      "name": "qml.devices.qubit.measure",
      "type": "function",
      "description": "PennyLane API: devices.qubit.measure. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "shots\")     else:         shots = op.hyperparameters[\"shots\"]      if shots:         snapshot = qml.devices.qubit.measure_with_samples(             [measurement],             state,             shots,"
    },
    {
      "id": "qml.math.asarray",
      "name": "qml.math.asarray",
      "type": "function",
      "description": "PennyLane API: math.asarray. Found in initialize_state.html",
      "source_file": "initialize_state.html",
      "context": " = np.zeros((2,) * num_wires, dtype=complex)         state[(0,) * num_wires] = 1         return qml.math.asarray(state, like=like)      state_vector = prep_operation.state_vector(wire_order=list(wires"
    },
    {
      "id": "qml.wires.Wires.shared_wires",
      "name": "qml.wires.Wires.shared_wires",
      "type": "function",
      "description": "PennyLane API: wires.Wires.shared_wires. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "             continue         added = False         for wires in wires_list:             if len(qml.wires.Wires.shared_wires([wires, o.wires])) == 0:                 added_obs.append(o)               "
    },
    {
      "id": "qml.pauli.is_pauli_word",
      "name": "qml.pauli.is_pauli_word",
      "type": "function",
      "description": "PennyLane API: pauli.is_pauli_word. Found in sampling.html",
      "source_file": "sampling.html",
      "context": " is None:             mp_no_obs.append(mp)             mp_no_obs_indices.append(i)         elif qml.pauli.is_pauli_word(mp.obs):             mp_pauli_obs.append((i, mp))         else:             mp_o"
    },
    {
      "id": "qml.ops.LinearCombination",
      "name": "qml.ops.LinearCombination",
      "type": "function",
      "description": "PennyLane API: ops.LinearCombination. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "roups:         if isinstance(group[0], ExpectationMP) and isinstance(             group[0].obs, qml.ops.LinearCombination         ):             H_executions = _get_num_executions_for_expval_H(group[0"
    },
    {
      "id": "qml.math.abs",
      "name": "qml.math.abs",
      "type": "function",
      "description": "PennyLane API: math.abs. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "\"\"\"     rng = np.random.default_rng(rng)     norm = qml.math.sum(probs, axis=-1)     norm_err = qml.math.abs(norm - 1.0)     cutoff = 1e-07      norm_err = norm_err if is_state_batched else norm_err[."
    },
    {
      "id": "qml.math.full",
      "name": "qml.math.full",
      "type": "function",
      "description": "PennyLane API: math.full. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "    if \"probabilities contain nan\" not in str(e).lower():             raise e         samples = qml.math.full((shots.total_shots, len(wires)), 0)      processed_samples = []     for lower, upper in sh"
    },
    {
      "id": "qml.pauli.diagonalize_qwc_pauli_words",
      "name": "qml.pauli.diagonalize_qwc_pauli_words",
      "type": "function",
      "description": "PennyLane API: pauli.diagonalize_qwc_pauli_words. Found in sampling.html",
      "source_file": "sampling.html",
      "context": " mps[0].diagonalizing_gates()     elif all(mp.obs for mp in mps):         diagonalizing_gates = qml.pauli.diagonalize_qwc_pauli_words([mp.obs for mp in mps])[0]     else:         diagonalizing_gates ="
    },
    {
      "id": "qml.ops.Sum",
      "name": "qml.ops.Sum",
      "type": "function",
      "description": "PennyLane API: ops.Sum. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "ts * H_executions         elif isinstance(group[0], ExpectationMP) and isinstance(group[0].obs, qml.ops.Sum):             sum_executions = _get_num_executions_for_sum(group[0].obs)             num_exe"
    },
    {
      "id": "qml.math.any",
      "name": "qml.math.any",
      "type": "function",
      "description": "PennyLane API: math.any. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "toff = 1e-07      norm_err = norm_err if is_state_batched else norm_err[..., np.newaxis]     if qml.math.any(norm_err > cutoff):         raise ValueError(\"probabilities do not sum to 1\")      basis_st"
    },
    {
      "id": "qml.pauli.group_observables",
      "name": "qml.pauli.group_observables",
      "type": "function",
      "description": "PennyLane API: pauli.group_observables. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "1])      _, ops = obs.terms()     with qml.QueuingManager.stop_recording():         op_groups = qml.pauli.group_observables(ops)     return len(op_groups)   def get_num_shots_and_executions(tape: qml."
    },
    {
      "id": "qml.pauli.compute_partition_indices",
      "name": "qml.pauli.compute_partition_indices",
      "type": "function",
      "description": "PennyLane API: pauli.compute_partition_indices. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "end([i])     if mp_pauli_obs:         i_to_pauli_mp = dict(mp_pauli_obs)         part_indices = qml.pauli.compute_partition_indices(             [mp.obs for mp in i_to_pauli_mp.values()]         )    "
    },
    {
      "id": "qml.devices.qubit_mixed.measure_with_samples",
      "name": "qml.devices.qubit_mixed.measure_with_samples",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed.measure_with_samples. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": ".qubit_mixed.measure(measurement, state, is_state_batched)         else:             snapshot = qml.devices.qubit_mixed.measure_with_samples(                 [measurement],                 state,     "
    },
    {
      "id": "qml.QubitDensityMatrix",
      "name": "qml.QubitDensityMatrix",
      "type": "class",
      "description": "PennyLane API: QubitDensityMatrix. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "ts)] = snapshot      return state   @apply_operation.register def apply_density_matrix(     op: qml.QubitDensityMatrix,     state,     is_state_batched: bool = False,     debugger=None,     **executio"
    },
    {
      "id": "qml.math.partial_trace",
      "name": "qml.math.partial_trace",
      "type": "function",
      "description": "PennyLane API: math.partial_trace. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "s from state     # partial_trace reduces the dimension to only the complement wires     sigma = qml.math.partial_trace(state, indices=op_wires)     # sigma now has shape:     # (batch_size, 2^(n - num"
    },
    {
      "id": "qml.devices.qubit.apply_operation",
      "name": "qml.devices.qubit.apply_operation",
      "type": "function",
      "description": "PennyLane API: devices.qubit.apply_operation. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": " as alphabet  import numpy as np  import pennylane as qml from pennylane import math from pennylane.devices.qubit.apply_operation import _apply_grover_without_matrix from pennylane.operation import Ch"
    },
    {
      "id": "qml.Operation",
      "name": "qml.Operation",
      "type": "class",
      "description": "PennyLane API: Operation. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": " adjoint operation can be implemented     by shifting wires by `num_wires`.      Args:         op (.Operation): CZ, CH, CNOT, CSWAP, SWAP, Toffoli, and general MultiControlledX operation         state"
    },
    {
      "id": "qml.devices.qubit_mixed.measure",
      "name": "qml.devices.qubit_mixed.measure",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed.measure. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "      if isinstance(measurement, qml.measurements.StateMP) or not shots:             snapshot = qml.devices.qubit_mixed.measure(measurement, state, is_state_batched)         else:             snapshot"
    },
    {
      "id": "qml.T",
      "name": "qml.T",
      "type": "class",
      "description": "PennyLane API: T. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "         Performance                  Hardware & Simulators                  Learn                  Teach                     Software & Documentation     Install PennyLane                  Documentat"
    },
    {
      "id": "qml.math.zeros_like",
      "name": "qml.math.zeros_like",
      "type": "function",
      "description": "PennyLane API: math.zeros_like. Found in simulate.html",
      "source_file": "simulate.html",
      "context": "ent_axis = num_operated_wires + i + is_state_batched         state = qml.math.stack(([state] + [qml.math.zeros_like(state)]), axis=current_axis)         state = qml.math.stack(([state] + [qml.math.zer"
    },
    {
      "id": "qml.TShift",
      "name": "qml.TShift",
      "type": "class",
      "description": "PennyLane API: TShift. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": ", 0.],         [0., 0., 0.],         [0., 0., 0.]], requires_grad=True)     >>> apply_operation(qml.TShift(0), state)     tensor([[0., 0., 0.],         [0., 1., 0],         [0., 0., 0.],], requires_gr"
    },
    {
      "id": "qml.devices.qutrit_mixed.measure",
      "name": "qml.devices.qutrit_mixed.measure",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.measure. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "      if isinstance(measurement, qml.measurements.StateMP) or not shots:             snapshot = qml.devices.qutrit_mixed.measure(measurement, state, is_state_batched)         else:             snapsho"
    },
    {
      "id": "qml.devices.qutrit_mixed.measure_with_samples",
      "name": "qml.devices.qutrit_mixed.measure_with_samples",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.measure_with_samples. Found in apply_operation.html",
      "source_file": "apply_operation.html",
      "context": "qutrit_mixed.measure(measurement, state, is_state_batched)         else:             snapshot = qml.devices.qutrit_mixed.measure_with_samples(                 measurement,                 state,      "
    },
    {
      "id": "qml.math.outer",
      "name": "qml.math.outer",
      "type": "function",
      "description": "PennyLane API: math.outer. Found in initialize_state.html",
      "source_file": "initialize_state.html",
      "context": "nsion of the system.     \"\"\"      # Initialize the entire set of wires with the state     rho = qml.math.outer(state, qml.math.conj(state))     return qml.math.reshape(rho, [QUDIT_DIM] * 2 * num_wires"
    },
    {
      "id": "qml.math.arange",
      "name": "qml.math.arange",
      "type": "function",
      "description": "PennyLane API: math.arange. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "he columns of the basis samples required based on ``wires``.     powers_of_three = QUDIT_DIM ** qml.math.arange(num_wires)[::-1]     indices = qml.math.array(samples @ powers_of_three)     return mp.e"
    },
    {
      "id": "qml.math.array",
      "name": "qml.math.array",
      "type": "function",
      "description": "PennyLane API: math.array. Found in sampling.html",
      "source_file": "sampling.html",
      "context": "on ``wires``.     powers_of_three = QUDIT_DIM ** qml.math.arange(num_wires)[::-1]     indices = qml.math.array(samples @ powers_of_three)     return mp.eigvals()[indices]   def _process_counts_samples"
    },
    {
      "id": "qiskit.aer",
      "name": "qiskit.aer",
      "type": "function",
      "description": "Qiskit API: aer. Found in tests.html",
      "source_file": "tests.html",
      "context": "k flaky  The tests can also be run on an external device from a PennyLane plugin, such as ``'qiskit.aer'``. For this, make sure you have the correct dependencies installed.  Most tests query the devic"
    },
    {
      "id": "qml.RandomLayers",
      "name": "qml.RandomLayers",
      "type": "class",
      "description": "PennyLane API: RandomLayers. Found in draw.html",
      "source_file": "draw.html",
      "context": "t.qubit\"), diff_method=\"parameter-shift\")             def circ(weights, order):                 qml.RandomLayers(weights, wires=(0, 1))                 qml.Permute(order, wires=(0, 1, 2))             "
    },
    {
      "id": "qml.QFT",
      "name": "qml.QFT",
      "type": "class",
      "description": "PennyLane API: QFT. Found in draw.html",
      "source_file": "draw.html",
      "context": "htning.qubit', wires=(0,1,2,3))          @qml.qnode(dev)         def circuit(x, z):             qml.QFT(wires=(0,1,2,3))             qml.IsingXX(1.234, wires=(0,2))             qml.Toffoli(wires=(0,1,"
    },
    {
      "id": "qml.Hermitian",
      "name": "qml.Hermitian",
      "type": "class",
      "description": "PennyLane API: Hermitian. Found in draw.html",
      "source_file": "draw.html",
      "context": "=0)         ...     qml.QubitUnitary(-np.eye(4), wires=(0,1))         ...     return qml.expval(qml.Hermitian(np.eye(2), wires=1))         >>> print(qml.draw(circuit3)())         0: ──U(M0)─╭U(M1)─┤  "
    },
    {
      "id": "qml.numpy.array",
      "name": "qml.numpy.array",
      "type": "function",
      "description": "PennyLane API: numpy.array. Found in draw.html",
      "source_file": "draw.html",
      "context": "          return qml.expval(qml.PauliX(0))              order = [2, 1, 0]             weights = qml.numpy.array([[1.0, 20]])          One can print the circuit without any transforms applied by passin"
    },
    {
      "id": "qml.drawer.available_styles",
      "name": "qml.drawer.available_styles",
      "type": "function",
      "description": "PennyLane API: drawer.available_styles. Found in draw.html",
      "source_file": "draw.html",
      "context": "earance of the circuit drawings.         All available styles can be determined by evaluating ``qml.drawer.available_styles()``.         Any available string can then be passed via the kwarg ``style``"
    },
    {
      "id": "qml.gradients.param_shift",
      "name": "qml.gradients.param_shift",
      "type": "function",
      "description": "PennyLane API: gradients.param_shift. Found in draw.html",
      "source_file": "draw.html",
      "context": "s:          .. code-block:: python              from pennylane import numpy as np              @qml.gradients.param_shift(shifts=[(0.1,)])             @qml.qnode(qml.device('default.qubit', wires=1)) "
    },
    {
      "id": "qml.draw_mpl",
      "name": "qml.draw_mpl",
      "type": "function",
      "description": "PennyLane API: draw_mpl. Found in draw.html",
      "source_file": "draw.html",
      "context": "     return \"\\n\\n\".join(res)      return wrapper   # pylint: disable=too-many-arguments  [docs] def draw_mpl(     qnode: QNode | Callable,     wire_order: Sequence | None = None,     show_all_wires: b"
    },
    {
      "id": "qml.transforms.merge_rotations",
      "name": "qml.transforms.merge_rotations",
      "type": "function",
      "description": "PennyLane API: transforms.merge_rotations. Found in draw.html",
      "source_file": "draw.html",
      "context": "out any drawing. Take, for example, this circuit:          .. code-block:: python              @qml.transforms.merge_rotations             @qml.transforms.cancel_inverses             @qml.qnode(qml.de"
    },
    {
      "id": "qml.drawer.MPLDrawer",
      "name": "qml.drawer.MPLDrawer",
      "type": "function",
      "description": "PennyLane API: drawer.MPLDrawer. Found in mpldrawer.html",
      "source_file": "mpldrawer.html",
      "context": "      follows after another one.      **Example**      .. code-block:: python          drawer = qml.drawer.MPLDrawer(wire_map={i: i for i in range(5)}, n_layers=6)          drawer.label([\"0\", \"a\", r\"$"
    },
    {
      "id": "qml.drawer.use_style",
      "name": "qml.drawer.use_style",
      "type": "function",
      "description": "PennyLane API: drawer.use_style. Found in mpldrawer.html",
      "source_file": "mpldrawer.html",
      "context": " evaluating ``qml.drawer.available_styles()``.     Any available string can then be passed to ``qml.drawer.use_style``.      .. code-block:: python          qml.drawer.use_style('black_white')      .."
    },
    {
      "id": "qml.drawer.tape_mpl",
      "name": "qml.drawer.tape_mpl",
      "type": "function",
      "description": "PennyLane API: drawer.tape_mpl. Found in tape_mpl.html",
      "source_file": "tape_mpl.html",
      "context": "                                  pennylane.drawer.tape_mpl — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.drawer.tape_text",
      "name": "qml.drawer.tape_text",
      "type": "function",
      "description": "PennyLane API: drawer.tape_text. Found in tape_text.html",
      "source_file": "tape_text.html",
      "context": "                                  pennylane.drawer.tape_text — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.estimator.estimate_error",
      "name": "qml.estimator.estimate_error",
      "type": "function",
      "description": "PennyLane API: estimator.estimate_error. Found in measurement.html",
      "source_file": "measurement.html",
      "context": "xample**      >>> coeffs = [np.array([-0.32707061, 0.7896887]), np.array([0.18121046])]     >>> qml.estimator.estimate_error(coeffs, shots=100000)     np.float64(0.0032759684708248507)      .. details"
    },
    {
      "id": "qml.estimator.estimate_shots",
      "name": "qml.estimator.estimate_shots",
      "type": "function",
      "description": "PennyLane API: estimator.estimate_shots. Found in measurement.html",
      "source_file": "measurement.html",
      "context": "xample**      >>> coeffs = [np.array([-0.32707061, 0.7896887]), np.array([0.18121046])]     >>> qml.estimator.estimate_shots(coeffs)     419218      .. details::         :title: Theory          An est"
    },
    {
      "id": "qml.estimator.Identity.resource_decomp",
      "name": "qml.estimator.Identity.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.Identity.resource_decomp. Found in identity.html",
      "source_file": "identity.html",
      "context": "ntity`.      **Example**      The resources for this operation can be requested using:      >>> qml.estimator.Identity.resource_decomp()     []     \"\"\"      num_wires = 1      def __init__(self, wires"
    },
    {
      "id": "qml.estimator.GlobalPhase.resource_decomp",
      "name": "qml.estimator.GlobalPhase.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.GlobalPhase.resource_decomp. Found in identity.html",
      "source_file": "identity.html",
      "context": "Phase`.      **Example**      The resources for this operation can be requested using:      >>> qml.estimator.GlobalPhase.resource_decomp()     []      \"\"\"      num_wires = 1      def __init__(self, w"
    },
    {
      "id": "qml.estimator.ControlledPhaseShift.resource_decomp",
      "name": "qml.estimator.ControlledPhaseShift.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.ControlledPhaseShift.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "haseShift`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.ControlledPhaseShift.resource_decomp()     [(2 x CNOT), (3 x RZ)]     \"\"\"      resource_ke"
    },
    {
      "id": "qml.estimator.CRZ.resource_decomp",
      "name": "qml.estimator.CRZ.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CRZ.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ss:`~.CRZ`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CRZ.resource_decomp()     [(2 x CNOT), (2 x RZ)]     \"\"\"      resource_keys = {\"precision\""
    },
    {
      "id": "qml.estimator.CZ.resource_decomp",
      "name": "qml.estimator.CZ.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CZ.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "nylane.CZ`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CZ.resource_decomp()     [(1 x CNOT), (2 x Hadamard)]     \"\"\"      num_wires = 2      def "
    },
    {
      "id": "qml.estimator.CSWAP.resource_decomp",
      "name": "qml.estimator.CSWAP.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CSWAP.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ane.CSWAP`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CSWAP.resource_decomp()     [(1 x Toffoli), (2 x CNOT)]     \"\"\"      num_wires = 3      de"
    },
    {
      "id": "qml.estimator.MultiControlledX.resource_decomp",
      "name": "qml.estimator.MultiControlledX.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.MultiControlledX.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ntrolledX`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.MultiControlledX.resource_decomp(num_ctrl_wires=5, num_zero_ctrl=2)     [(4 x X), Allocate"
    },
    {
      "id": "qml.estimator.CRY.resource_decomp",
      "name": "qml.estimator.CRY.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CRY.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ylane.CRY`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CRY.resource_decomp()     [(2 x CNOT), (2 x RY)]     \"\"\"      resource_keys = {\"precision\""
    },
    {
      "id": "qml.estimator.CRot.resource_decomp",
      "name": "qml.estimator.CRot.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CRot.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "s:`~.CRot`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CRot.resource_decomp()     [(2 x CNOT), (3 x RZ), (2 x RY)]     \"\"\"      resource_keys = {"
    },
    {
      "id": "qml.estimator.Toffoli.resource_decomp",
      "name": "qml.estimator.Toffoli.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.Toffoli.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "e.Toffoli`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.Toffoli.resource_decomp()     [Allocate(2), (9 x CNOT), (3 x Hadamard), (1 x S), (1 x CZ),"
    },
    {
      "id": "qml.estimator.CY.resource_decomp",
      "name": "qml.estimator.CY.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CY.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "nylane.CY`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CY.resource_decomp()     [(1 x CNOT), (1 x S), (1 x Adjoint(S))]     \"\"\"      num_wires = "
    },
    {
      "id": "qml.estimator.CRX.resource_decomp",
      "name": "qml.estimator.CRX.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CRX.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ylane.CRX`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CRX.resource_decomp()     [(2 x CNOT), (2 x RZ), (2 x Hadamard)]     \"\"\"      resource_key"
    },
    {
      "id": "qml.estimator.TemporaryAND.resource_decomp",
      "name": "qml.estimator.TemporaryAND.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.TemporaryAND.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "poraryAND`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.TemporaryAND.resource_decomp()     [(1 x Toffoli)]     \"\"\"      num_wires = 3      def __i"
    },
    {
      "id": "qml.estimator.CCZ.resource_decomp",
      "name": "qml.estimator.CCZ.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CCZ.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ylane.CCZ`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CCZ.resource_decomp()     [(1 x Toffoli), (2 x Hadamard)]     \"\"\"      num_wires = 3      "
    },
    {
      "id": "qml.estimator.CH.resource_decomp",
      "name": "qml.estimator.CH.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.CH.resource_decomp. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "nylane.CH`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.CH.resource_decomp()     [(2 x Hadamard), (2 x RY), (1 x CNOT)]      \"\"\"      num_wires = "
    },
    {
      "id": "qml.estimator.QFT",
      "name": "qml.estimator.QFT",
      "type": "function",
      "description": "PennyLane API: estimator.QFT. Found in symbolic.html",
      "source_file": "symbolic.html",
      "context": "`.      **Example**      The adjoint operation can be constructed like this:          >>> qft = qml.estimator.QFT(num_wires=3)         >>> adj_qft = qml.estimator.Adjoint(qft)      We can see how the "
    },
    {
      "id": "qml.estimator.Adjoint",
      "name": "qml.estimator.Adjoint",
      "type": "function",
      "description": "PennyLane API: estimator.Adjoint. Found in symbolic.html",
      "source_file": "symbolic.html",
      "context": " constructed like this:          >>> qft = qml.estimator.QFT(num_wires=3)         >>> adj_qft = qml.estimator.Adjoint(qft)      We can see how the resources differ by choosing a suitable gateset and e"
    },
    {
      "id": "qml.estimator.S.resource_decomp",
      "name": "qml.estimator.S.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.S.resource_decomp. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "nnylane.S`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.S.resource_decomp()     [(2 x T)]     \"\"\"      num_wires = 1      def __init__(self, wires"
    },
    {
      "id": "qml.estimator.Y.resource_decomp",
      "name": "qml.estimator.Y.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.Y.resource_decomp. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "ne.PauliY`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.Y.resource_decomp()     [(1 x S), (1 x Z), (1 x Adjoint(S)), (2 x Hadamard)]     \"\"\"      "
    },
    {
      "id": "qml.estimator.Z.resource_decomp",
      "name": "qml.estimator.Z.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.Z.resource_decomp. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "ne.PauliZ`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.Z.resource_decomp()     [(2 x S)]     \"\"\"      num_wires = 1      def __init__(self, wires"
    },
    {
      "id": "qml.estimator.SWAP.resource_decomp",
      "name": "qml.estimator.SWAP.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.SWAP.resource_decomp. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "lane.SWAP`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.SWAP.resource_decomp()     [(3 x CNOT)]      \"\"\"      num_wires = 2      def __init__(self"
    },
    {
      "id": "qml.estimator.X.resource_decomp",
      "name": "qml.estimator.X.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.X.resource_decomp. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "ne.PauliX`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.X.resource_decomp()     [(2 x Hadamard), (2 x S)]     \"\"\"      num_wires = 1      def __in"
    },
    {
      "id": "qml.estimator.estimate",
      "name": "qml.estimator.estimate",
      "type": "function",
      "description": "PennyLane API: estimator.estimate. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": ">>> multi_rz = qre.MultiRZ(num_wires=3)     >>> gate_set = {\"CNOT\", \"RZ\"}     >>>     >>> print(qml.estimator.estimate(multi_rz, gate_set))     --- Resources: ---      Total wires: 3         algorithm"
    },
    {
      "id": "qml.estimator.PhaseShift.resource_decomp",
      "name": "qml.estimator.PhaseShift.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.PhaseShift.resource_decomp. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e.PhaseShift`.      **Example**      The resources for this operation are computed as:      >>> qml.estimator.PhaseShift.resource_decomp()     [(1 x RZ), (1 x GlobalPhase)]     \"\"\"      num_wires = 1 "
    },
    {
      "id": "qml.estimator.RZ.resource_decomp",
      "name": "qml.estimator.RZ.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.RZ.resource_decomp. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "nylane.RZ`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.RZ.resource_decomp(precision=1e-4)     [(24 x T)]     \"\"\"      num_wires = 1     resource_"
    },
    {
      "id": "qml.estimator.RY.resource_decomp",
      "name": "qml.estimator.RY.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.RY.resource_decomp. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "nylane.RY`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.RY.resource_decomp(precision=1e-4)     [(24 x T)]     \"\"\"      num_wires = 1     resource_"
    },
    {
      "id": "qml.estimator.RX.resource_decomp",
      "name": "qml.estimator.RX.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.RX.resource_decomp. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "nylane.RX`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.RX.resource_decomp(precision=1e-4)     [(24 x T)]     \"\"\"      num_wires = 1     resource_"
    },
    {
      "id": "qml.estimator.Rot.resource_decomp",
      "name": "qml.estimator.Rot.resource_decomp",
      "type": "function",
      "description": "PennyLane API: estimator.Rot.resource_decomp. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "ylane.Rot`.      **Example**      The resources for this operation are computed using:      >>> qml.estimator.Rot.resource_decomp()     [(1 x RY), (2 x RZ)]     \"\"\"      num_wires = 1     resource_key"
    },
    {
      "id": "qml.estimator.FirstQuantization.qubit_cost",
      "name": "qml.estimator.FirstQuantization.qubit_cost",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization.qubit_cost. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": " the functions :func:`~.pennylane.estimator.FirstQuantization.gate_cost` and     :func:`~.pennylane.estimator.FirstQuantization.qubit_cost` with a target error that has the default     value of 0.0016"
    },
    {
      "id": "qml.estimator.FirstQuantization.norm",
      "name": "qml.estimator.FirstQuantization.norm",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization.norm. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": " 10000         >>> eta = 156         >>> omega = 1145.166         >>> error = 0.001         >>> qml.estimator.FirstQuantization.norm(n, eta, omega, error)         np.float64(281053.7561251118)        "
    },
    {
      "id": "qml.estimator.FirstQuantization.gate_cost",
      "name": "qml.estimator.FirstQuantization.gate_cost",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization.gate_cost. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": "ctors need to be defined. The costs can then be     computed using the functions :func:`~.pennylane.estimator.FirstQuantization.gate_cost` and     :func:`~.pennylane.estimator.FirstQuantization.qubit_"
    },
    {
      "id": "qml.estimator.FirstQuantization._cost_qrom",
      "name": "qml.estimator.FirstQuantization._cost_qrom",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization._cost_qrom. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": "mum cost of erasing the output of a QROM          **Example**          >>> lz = 100         >>> qml.estimator.FirstQuantization._cost_qrom(lz)         21         \"\"\"         if lz <= 0 or not isinstan"
    },
    {
      "id": "qml.estimator.FirstQuantization",
      "name": "qml.estimator.FirstQuantization",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": "ctors need to be defined. The costs can then be     computed using the functions :func:`~.pennylane.estimator.FirstQuantization.gate_cost` and     :func:`~.pennylane.estimator.FirstQuantization.qubit_"
    },
    {
      "id": "qml.estimator.FirstQuantization.unitary_cost",
      "name": "qml.estimator.FirstQuantization.unitary_cost",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization.unitary_cost. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": "100000         >>> eta = 156         >>> omega = 169.69608         >>> error = 0.01         >>> qml.estimator.FirstQuantization.unitary_cost(n, eta, omega, error)         17033         \"\"\"         if "
    },
    {
      "id": "qml.estimator.FirstQuantization.success_prob",
      "name": "qml.estimator.FirstQuantization.success_prob",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization.success_prob. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": "ss for state preparation          **Example**          >>> n = 3         >>> br = 8         >>> qml.estimator.FirstQuantization.success_prob(n, br)         np.float64(0.9999928850303523)         \"\"\"  "
    },
    {
      "id": "qml.estimator.FirstQuantization.estimation_cost",
      "name": "qml.estimator.FirstQuantization.estimation_cost",
      "type": "function",
      "description": "PennyLane API: estimator.FirstQuantization.estimation_cost. Found in first_quantization.html",
      "source_file": "first_quantization.html",
      "context": " 100000         >>> eta = 156         >>> omega = 1145.166         >>> error = 0.01         >>> qml.estimator.FirstQuantization.estimation_cost(n, eta, omega, error)         102133985         \"\"\"     "
    },
    {
      "id": "qml.qchem.electron_integrals",
      "name": "qml.qchem.electron_integrals",
      "type": "function",
      "description": "PennyLane API: qchem.electron_integrals. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "  >>> mol = qml.qchem.Molecule(symbols, geometry, basis_name='sto-3g')     >>> core, one, two = qml.qchem.electron_integrals(mol)()     >>> algo = qml.estimator.DoubleFactorization(one, two)     >>> a"
    },
    {
      "id": "qml.estimator.DoubleFactorization.gate_cost",
      "name": "qml.estimator.DoubleFactorization.gate_cost",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization.gate_cost. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "      for the given Hamiltonian can then be computed using the functions         :func:`~.pennylane.estimator.DoubleFactorization.gate_cost` and         :func:`~.pennylane.estimator.DoubleFactorizatio"
    },
    {
      "id": "qml.estimator.DoubleFactorization.estimation_cost",
      "name": "qml.estimator.DoubleFactorization.estimation_cost",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization.estimation_cost. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "        **Example**          >>> lamb = 72.49779513025341         >>> error = 0.001         >>> qml.estimator.DoubleFactorization.estimation_cost(lamb, error)         113880         \"\"\"         if err"
    },
    {
      "id": "qml.qchem.factorize",
      "name": "qml.qchem.factorize",
      "type": "function",
      "description": "PennyLane API: qchem.factorize. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "plementing this method, the Hamiltonian needs to         be factorized using the :func:`~.pennylane.qchem.factorize` function following         [`PRX Quantum 2, 030305 (2021) <https://journals.aps.org"
    },
    {
      "id": "qml.estimator.DoubleFactorization.unitary_cost",
      "name": "qml.estimator.DoubleFactorization.unitary_cost",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization.unitary_cost. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": " ...           'alpha': 10,         ...           'beta': 20,         ...         }         >>> qml.estimator.DoubleFactorization.unitary_cost(**kwargs)         2007         \"\"\"         if n <= 0 or n"
    },
    {
      "id": "qml.qchem.Molecule",
      "name": "qml.qchem.Molecule",
      "type": "function",
      "description": "PennyLane API: qchem.Molecule. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": ".00662237],     ...                      [0.00000000, -1.45278171, -1.00662237]])     >>> mol = qml.qchem.Molecule(symbols, geometry, basis_name='sto-3g')     >>> core, one, two = qml.qchem.electron_i"
    },
    {
      "id": "qml.estimator.DoubleFactorization.qubit_cost",
      "name": "qml.estimator.DoubleFactorization.qubit_cost",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization.qubit_cost. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "         :func:`~.pennylane.estimator.DoubleFactorization.gate_cost` and         :func:`~.pennylane.estimator.DoubleFactorization.qubit_cost` with a target error that has the         default value of "
    },
    {
      "id": "qml.estimator.DoubleFactorization",
      "name": "qml.estimator.DoubleFactorization",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "asis_name='sto-3g')     >>> core, one, two = qml.qchem.electron_integrals(mol)()     >>> algo = qml.estimator.DoubleFactorization(one, two)     >>> algo.lamb # the 1-Norm of the Hamiltonian     np.flo"
    },
    {
      "id": "qml.estimator.DoubleFactorization.norm",
      "name": "qml.estimator.DoubleFactorization.norm",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization.norm. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": "ation step. The 1-norm of the Hamiltonian can then be computed using the         :func:`~.pennylane.estimator.DoubleFactorization.norm` function from the electron integrals         and the eigenvalues"
    },
    {
      "id": "qml.estimator.DoubleFactorization._qrom_cost",
      "name": "qml.estimator.DoubleFactorization._qrom_cost",
      "type": "function",
      "description": "PennyLane API: estimator.DoubleFactorization._qrom_cost. Found in second_quantization.html",
      "source_file": "second_quantization.html",
      "context": " QROM          **Example**          >>> constants = (151.0, 7.0, 151.0, 30.0, -1.0)         >>> qml.estimator.DoubleFactorization._qrom_cost(constants)         (168, 4)         \"\"\"         a, b, c, d,"
    },
    {
      "id": "qml.fermi.from_string",
      "name": "qml.fermi.from_string",
      "type": "function",
      "description": "PennyLane API: fermi.from_string. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "PauliSentence, Operator]: a linear combination of qubit operators      **Example**      >>> w = qml.fermi.from_string('0+ 1-')     >>> jordan_wigner(w)     (         -0.25j * (Y(0) @ X(1))       + (0."
    },
    {
      "id": "qml.FermiSentence",
      "name": "qml.FermiSentence",
      "type": "class",
      "description": "PennyLane API: FermiSentence. Found in fermionic.html",
      "source_file": "fermionic.html",
      "context": "d\"\"\"         return f\"FermiWord({self.sorted_dic})\"      def __add__(self, other):         \"\"\"Add a FermiSentence, FermiWord or constant to a FermiWord. Converts both         elements into FermiSenten"
    },
    {
      "id": "qml.FermiWord",
      "name": "qml.FermiWord",
      "type": "class",
      "description": "PennyLane API: FermiWord. Found in fermionic.html",
      "source_file": "fermionic.html",
      "context": "ort copy  from pennylane import fermi, math from pennylane.typing import TensorLike    [docs] class FermiWord(dict):     r\"\"\"Immutable dictionary used to represent a Fermi word, a product of fermionic"
    },
    {
      "id": "qml.FermiC",
      "name": "qml.FermiC",
      "type": "class",
      "description": "PennyLane API: FermiC. Found in fermionic.html",
      "source_file": "fermionic.html",
      "context": "1) a⁺(0) a(1)      >>> print(from_string('0^ 1 0^ 1'))     a⁺(0) a(1) a⁺(0) a(1)      >>> op1 = qml.FermiC(0) * qml.FermiA(1) * qml.FermiC(2) * qml.FermiA(3)     >>> op2 = from_string('0+ 1- 2+ 3-')  "
    },
    {
      "id": "qml.FermiA",
      "name": "qml.FermiA",
      "type": "class",
      "description": "PennyLane API: FermiA. Found in fermionic.html",
      "source_file": "fermionic.html",
      "context": "   >>> print(from_string('0^ 1 0^ 1'))     a⁺(0) a(1) a⁺(0) a(1)      >>> op1 = qml.FermiC(0) * qml.FermiA(1) * qml.FermiC(2) * qml.FermiA(3)     >>> op2 = from_string('0+ 1- 2+ 3-')     >>> op1 == op"
    },
    {
      "id": "qml.fourier.circuit_spectrum",
      "name": "qml.fourier.circuit_spectrum",
      "type": "function",
      "description": "PennyLane API: fourier.circuit_spectrum. Found in circuit_spectrum.html",
      "source_file": "circuit_spectrum.html",
      "context": "                                  pennylane.fourier.circuit_spectrum — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.fourier.qnode_spectrum",
      "name": "qml.fourier.qnode_spectrum",
      "type": "function",
      "description": "PennyLane API: fourier.qnode_spectrum. Found in qnode_spectrum.html",
      "source_file": "qnode_spectrum.html",
      "context": "                                  pennylane.fourier.qnode_spectrum — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.fourier.reconstruct",
      "name": "qml.fourier.reconstruct",
      "type": "function",
      "description": "PennyLane API: fourier.reconstruct. Found in reconstruct.html",
      "source_file": "reconstruct.html",
      "context": "                                  pennylane.fourier.reconstruct — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.linalg",
      "name": "qml.math.linalg",
      "type": "function",
      "description": "PennyLane API: math.linalg. Found in utils.html",
      "source_file": "utils.html",
      "context": "oat]: non-negative frequencies contributed by this input-encoding gate     \"\"\"      # todo: use qml.math.linalg once it is tested properly     evals = np.linalg.eigvalsh(matrix(generator(op, format=\"o"
    },
    {
      "id": "qml.fourier.coefficients",
      "name": "qml.fourier.coefficients",
      "type": "function",
      "description": "PennyLane API: fourier.coefficients. Found in visualize.html",
      "source_file": "visualize.html",
      "context": "d resemble that of the output of NumPy/SciPy's ``fftn`` function, or             :func:`~.pennylane.fourier.coefficients`.         n_inputs (int): The number of input variables in the function.       "
    },
    {
      "id": "qml.fourier.visualize.radial_box",
      "name": "qml.fourier.visualize.radial_box",
      "type": "function",
      "description": "PennyLane API: fourier.visualize.radial_box. Found in visualize.html",
      "source_file": "visualize.html",
      "context": "ey=True,             subplot_kw={\"polar\": True},             figsize=(15, 8)         )          qml.fourier.visualize.radial_box(coeffs, 2, ax, show_freqs=True, show_fliers=False)      .. image:: ../."
    },
    {
      "id": "qml.ftqc.cond_measure",
      "name": "qml.ftqc.cond_measure",
      "type": "function",
      "description": "PennyLane API: ftqc.cond_measure. Found in parametric_midmeasure.html",
      "source_file": "parametric_midmeasure.html",
      "context": "transform can also handle diagonalization of conditional measurements created by         :func:`qml.ftqc.cond_measure <pennylane.ftqc.cond_measure>`. This is done by replacing the         measurements"
    },
    {
      "id": "qml.I",
      "name": "qml.I",
      "type": "class",
      "description": "PennyLane API: I. Found in pauli_tracker.html",
      "source_file": "pauli_tracker.html",
      "context": "tors                  Learn                  Teach                     Software & Documentation     Install PennyLane                  Documentation                  Catalyst Compilation Docs         "
    },
    {
      "id": "qml.ftqc.GraphStatePrep",
      "name": "qml.ftqc.GraphStatePrep",
      "type": "function",
      "description": "PennyLane API: ftqc.GraphStatePrep. Found in utils.html",
      "source_file": "utils.html",
      "context": "      output_idx = graph_wires[-1]                      # Prepare the state                     qml.ftqc.GraphStatePrep(lattice.graph, wires=graph_wires)                      # entangle input and grap"
    },
    {
      "id": "qml.adjoint_metric_tensor",
      "name": "qml.adjoint_metric_tensor",
      "type": "function",
      "description": "PennyLane API: adjoint_metric_tensor. Found in adjoint_metric_tensor.html",
      "source_file": "adjoint_metric_tensor.html",
      "context": "                                  pennylane.gradients.adjoint_metric_tensor — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.metric_tensor",
      "name": "qml.metric_tensor",
      "type": "function",
      "description": "PennyLane API: metric_tensor. Found in adjoint_metric_tensor.html",
      "source_file": "adjoint_metric_tensor.html",
      "context": "                                  pennylane.gradients.adjoint_metric_tensor — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.gradients.classical_jacobian",
      "name": "qml.gradients.classical_jacobian",
      "type": "function",
      "description": "PennyLane API: gradients.classical_jacobian. Found in classical_jacobian.html",
      "source_file": "classical_jacobian.html",
      "context": "                                  pennylane.gradients.classical_jacobian — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.execute",
      "name": "qml.execute",
      "type": "function",
      "description": "PennyLane API: execute. Found in finite_difference.html",
      "source_file": "finite_difference.html",
      "context": "ocessed to retrieve the gradient:          >>> dev = qml.device(\"default.qubit\")         >>> fn(qml.execute(gradient_tapes, dev, None))         ((tensor(-0.56464251, requires_grad=True),           ten"
    },
    {
      "id": "qml.gradients.finite_diff",
      "name": "qml.gradients.finite_diff",
      "type": "function",
      "description": "PennyLane API: gradients.finite_diff. Found in finite_difference.html",
      "source_file": "finite_difference.html",
      "context": "                                  pennylane.gradients.finite_difference — PennyLane 0.45.0-dev3 documentation                       About     Research               "
    },
    {
      "id": "qml.gradients.finite_diff_jvp",
      "name": "qml.gradients.finite_diff_jvp",
      "type": "function",
      "description": "PennyLane API: gradients.finite_diff_jvp. Found in finite_difference.html",
      "source_file": "finite_difference.html",
      "context": "x * y, x**2     >>> args = (0.5, 1.2)     >>> tangents = (1.0, 1.0)     >>> results, dresults = qml.gradients.finite_diff_jvp(f, args, tangents)     >>> results     (1.2, 0.25)     >>> dresults     [n"
    },
    {
      "id": "qml.gradients.classical_fisher",
      "name": "qml.gradients.classical_fisher",
      "type": "function",
      "description": "PennyLane API: gradients.classical_fisher. Found in fisher.html",
      "source_file": "fisher.html",
      "context": "IM) by simply calling the function returned     by ``classical_fisher()``:      >>> cfim_func = qml.gradients.classical_fisher(circ)     >>> cfim_func(params)     tensor([[ 0.90156094, -0.12555804],  "
    },
    {
      "id": "qml.QuantumTape",
      "name": "qml.QuantumTape",
      "type": "class",
      "description": "PennyLane API: QuantumTape. Found in fisher.html",
      "source_file": "fisher.html",
      "context": "ta})}{\\partial \\theta_j}      for :math:`N` qubits.      Args:         tape (:class:`.QNode` or qml.QuantumTape): A :class:`.QNode` or quantum tape that may have arbitrary return types.         argnum"
    },
    {
      "id": "qml.math.jacobian",
      "name": "qml.math.jacobian",
      "type": "function",
      "description": "PennyLane API: math.jacobian. Found in fisher.html",
      "source_file": "fisher.html",
      "context": "om pennylane.workflow import execute  from .metric_tensor import metric_tensor   # TODO: create qml.math.jacobian and replace it here def _torch_jac(circ):     \"\"\"Torch jacobian as a callable function"
    },
    {
      "id": "qml.gradients.quantum_fisher",
      "name": "qml.gradients.quantum_fisher",
      "type": "function",
      "description": "PennyLane API: gradients.quantum_fisher. Found in fisher.html",
      "source_file": "fisher.html",
      "context": "ad(circ)(params)     >>> grad     array([ 0.59422561, -0.02615095, -0.05146226])     >>> qfim = qml.gradients.quantum_fisher(circ)(params)     >>> qfim     tensor([[1.        , 0.        , 0.        ]"
    },
    {
      "id": "qml.evolve",
      "name": "qml.evolve",
      "type": "function",
      "description": "PennyLane API: evolve. Found in hadamard_gradient.html",
      "source_file": "hadamard_gradient.html",
      "context": "ult.qubit')             >>> @qml.qnode(dev)             ... def circuit(x):             ...     qml.evolve(qml.X(0) @ qml.X(1) + qml.Z(0) @ qml.Z(1) + qml.H(0), x )             ...     return qml.expv"
    },
    {
      "id": "qml.gradients.hadamard_grad",
      "name": "qml.gradients.hadamard_grad",
      "type": "function",
      "description": "PennyLane API: gradients.hadamard_grad. Found in hadamard_gradient.html",
      "source_file": "hadamard_gradient.html",
      "context": "                                  pennylane.gradients.hadamard_gradient — PennyLane 0.45.0-dev3 documentation                       About     Research                 "
    },
    {
      "id": "qml.gradients.compute_jvp_single",
      "name": "qml.gradients.compute_jvp_single",
      "type": "function",
      "description": "PennyLane API: gradients.compute_jvp_single. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "lock:: pycon          >>> tangent = np.array([1.0])         >>> jac = np.array(0.2)         >>> qml.gradients.compute_jvp_single(tangent, jac)         array(0.2)      2. For a single parameter and a s"
    },
    {
      "id": "qml.gradients.jvp",
      "name": "qml.gradients.jvp",
      "type": "function",
      "description": "PennyLane API: gradients.jvp. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "                                  pennylane.gradients.jvp — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.gradients.batch_jvp",
      "name": "qml.gradients.batch_jvp",
      "type": "function",
      "description": "PennyLane API: gradients.batch_jvp. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "e.      Executing the JVP tapes, and applying the processing function:      >>> jvp_tapes, fn = qml.gradients.batch_jvp(tapes, tangents, qml.gradients.param_shift)      >>> dev = qml.device(\"default.q"
    },
    {
      "id": "qml.math.allclose",
      "name": "qml.math.allclose",
      "type": "function",
      "description": "PennyLane API: math.allclose. Found in jvp.html",
      "source_file": "jvp.html",
      "context": "      return tuple(), zero_jvp      multi_m = len(tape.measurements) > 1      try:         # if qml.math.allclose(qml.math.stack(tangent), 0):         if math.allclose(tangent, 0):             # If th"
    },
    {
      "id": "qml.gradients.compute_jvp_multi",
      "name": "qml.gradients.compute_jvp_multi",
      "type": "function",
      "description": "PennyLane API: gradients.compute_jvp_multi. Found in jvp.html",
      "source_file": "jvp.html",
      "context": " = np.array([2.0])         >>> jac = tuple([np.array([0.3]), np.array([0.2, 0.5])])         >>> qml.gradients.compute_jvp_multi(tangent, jac)         (array([0.6]), array([0.4, 1. ]))      2. For mult"
    },
    {
      "id": "qml.math.linalg.norm",
      "name": "qml.math.linalg.norm",
      "type": "function",
      "description": "PennyLane API: math.linalg.norm. Found in metric_tensor.html",
      "source_file": "metric_tensor.html",
      "context": "m of the metric tensor     with respect to the QNode ``weights`` :      >>> norm_fn = lambda x: qml.math.linalg.norm(mt_fn(x), ord=\"fro\")     >>> grad_fn = qml.grad(norm_fn)     >>> grad_fn(weights)  "
    },
    {
      "id": "qml.ops.qubit.attributes.supports_broadcasting",
      "name": "qml.ops.qubit.attributes.supports_broadcasting",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.supports_broadcasting. Found in parameter_shift.html",
      "source_file": "parameter_shift.html",
      "context": "ne way to check this is through the ``supports_broadcasting`` attribute:          >>> qml.RX in qml.ops.qubit.attributes.supports_broadcasting         True      .. details::         :title: Usage Deta"
    },
    {
      "id": "qml.gradients.split_to_single_terms",
      "name": "qml.gradients.split_to_single_terms",
      "type": "function",
      "description": "PennyLane API: gradients.split_to_single_terms. Found in parameter_shift.html",
      "source_file": "parameter_shift.html",
      "context": "      if op.name == \"LinearCombination\":             warnings.warn(                 \"Please use qml.gradients.split_to_single_terms so that the ML framework \"                 \"can compute the gradient"
    },
    {
      "id": "qml.Squeezing",
      "name": "qml.Squeezing",
      "type": "class",
      "description": "PennyLane API: Squeezing. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "    >>> @qml.qnode(dev, diff_method=\"parameter-shift\")     ... def circuit(params):     ...     qml.Squeezing(params[0], params[1], wires=[0])     ...     qml.Squeezing(params[2], params[3], wires=[0]"
    },
    {
      "id": "qml.FockState",
      "name": "qml.FockState",
      "type": "class",
      "description": "PennyLane API: FockState. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "robabilities (tapes that return :func:`~pennylane.probs` or         expectation values of :class:`~.FockStateProjector`) are not supported.      In addition, the operations must fulfill the following "
    },
    {
      "id": "qml.Displacement",
      "name": "qml.Displacement",
      "type": "class",
      "description": "PennyLane API: Displacement. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "equires_grad=False), wires=1)                # differentiable Gaussian operations               qml.Displacement(weights[0], weights[1], wires=0)               qml.Beamsplitter(weights[2], weights[3],"
    },
    {
      "id": "qml.Beamsplitter",
      "name": "qml.Beamsplitter",
      "type": "class",
      "description": "PennyLane API: Beamsplitter. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "ussian operations               qml.Displacement(weights[0], weights[1], wires=0)               qml.Beamsplitter(weights[2], weights[3], wires=[0, 1])                return qml.expval(qml.NumberOperat"
    },
    {
      "id": "qml.QuadP",
      "name": "qml.QuadP",
      "type": "class",
      "description": "PennyLane API: QuadP. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "O: if the A matrix corresponds to a known observable in PennyLane,     # for example qml.QuadX, qml.QuadP, qml.NumberOperator, we should return that     # instead. This will allow for greater device c"
    },
    {
      "id": "qml.Kerr",
      "name": "qml.Kerr",
      "type": "class",
      "description": "PennyLane API: Kerr. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "operations               qml.FockState(np.array(2, requires_grad=False), wires=0)               qml.Kerr(np.array(0.654, requires_grad=False), wires=1)                # differentiable Gaussian operati"
    },
    {
      "id": "qml.QuadX",
      "name": "qml.QuadX",
      "type": "class",
      "description": "PennyLane API: QuadX. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "      # TODO: if the A matrix corresponds to a known observable in PennyLane,     # for example qml.QuadX, qml.QuadP, qml.NumberOperator, we should return that     # instead. This will allow for great"
    },
    {
      "id": "qml.gradients.param_shift_cv",
      "name": "qml.gradients.param_shift_cv",
      "type": "function",
      "description": "PennyLane API: gradients.param_shift_cv. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": "perator(0))         >>> params = np.array([0.1, 0.2, 0.3, 0.4], requires_grad=True)         >>> qml.gradients.param_shift_cv(circuit, dev)(params)         tensor([[ 0.87516064,  0.01273285,  0.8833483"
    },
    {
      "id": "qml.NumberOperator",
      "name": "qml.NumberOperator",
      "type": "class",
      "description": "PennyLane API: NumberOperator. Found in parameter_shift_cv.html",
      "source_file": "parameter_shift_cv.html",
      "context": " matrix corresponds to a known observable in PennyLane,     # for example qml.QuadX, qml.QuadP, qml.NumberOperator, we should return that     # instead. This will allow for greater device compatibilit"
    },
    {
      "id": "qml.gradients.param_shift_hessian",
      "name": "qml.gradients.param_shift_hessian",
      "type": "function",
      "description": "PennyLane API: gradients.param_shift_hessian. Found in parameter_shift_hessian.html",
      "source_file": "parameter_shift_hessian.html",
      "context": "n qml.expval(qml.Z(0) @ qml.Z(1))      >>> x = np.array([0.5, 0.2], requires_grad=True)     >>> qml.gradients.param_shift_hessian(circuit)(x)     ((array(-0.86883595), array(0.04762358)),      (array("
    },
    {
      "id": "qml.pulse.constant",
      "name": "qml.pulse.constant",
      "type": "function",
      "description": "PennyLane API: pulse.constant. Found in pulse_gradient.html",
      "source_file": "pulse_gradient.html",
      "context": ".Z(1)         Y_plus_X = qml.dot([1/5, 3/5], [qml.Y(0), qml.X(1)])         H = 0.5 * qml.X(0) + qml.pulse.constant * ZZ + sin * Y_plus_X          def ansatz(params):             qml.evolve(H)(params, "
    },
    {
      "id": "qml.gradients.stoch_pulse_grad",
      "name": "qml.gradients.stoch_pulse_grad",
      "type": "function",
      "description": "PennyLane API: gradients.stoch_pulse_grad. Found in pulse_gradient.html",
      "source_file": "pulse_gradient.html",
      "context": "eturn qml.expval(qml.Y(1))          qnode = qml.QNode(ansatz, dev, interface=\"jax\", diff_method=qml.gradients.stoch_pulse_grad)      The program takes the two parameters :math:`v_1, v_2` for the two t"
    },
    {
      "id": "qml.gradients.pulse_odegen",
      "name": "qml.gradients.pulse_odegen",
      "type": "function",
      "description": "PennyLane API: gradients.pulse_odegen. Found in pulse_gradient_odegen.html",
      "source_file": "pulse_gradient_odegen.html",
      "context": "        dev = qml.device(\"default.qubit\")          @qml.qnode(dev, interface=\"jax\", diff_method=qml.gradients.pulse_odegen)         def circuit(params):             op = qml.evolve(H)(params, t)      "
    },
    {
      "id": "qml.math.isclose",
      "name": "qml.math.isclose",
      "type": "function",
      "description": "PennyLane API: math.isclose. Found in pulse_gradient_odegen.html",
      "source_file": "pulse_gradient_odegen.html",
      "context": "efficients             of the effective generators. Coefficients ``x`` satisfying             ``qml.math.isclose(x, 0., atol=atol, rtol=0) == True`` are neglected.      Returns:         tuple[List[Qua"
    },
    {
      "id": "qml.gradients.spsa_grad",
      "name": "qml.gradients.spsa_grad",
      "type": "function",
      "description": "PennyLane API: gradients.spsa_grad. Found in spsa_gradient.html",
      "source_file": "spsa_gradient.html",
      "context": "                                  pennylane.gradients.spsa_gradient — PennyLane 0.45.0-dev3 documentation                       About     Research                 "
    },
    {
      "id": "qml.gradients.batch_vjp",
      "name": "qml.gradients.batch_vjp",
      "type": "function",
      "description": "PennyLane API: gradients.batch_vjp. Found in vjp.html",
      "source_file": "vjp.html",
      "context": "torch.float64),     ...        torch.tensor([1.], dtype=torch.float64)]     >>> vjp_tapes, fn = qml.gradients.batch_vjp(tapes, dys, qml.gradients.param_shift)      Note that each ``dy`` has shape matc"
    },
    {
      "id": "qml.gradients.vjp",
      "name": "qml.gradients.vjp",
      "type": "function",
      "description": "PennyLane API: gradients.vjp. Found in vjp.html",
      "source_file": "vjp.html",
      "context": "                                  pennylane.gradients.vjp — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.from_pyquil",
      "name": "qml.from_pyquil",
      "type": "function",
      "description": "PennyLane API: from_pyquil. Found in io.html",
      "source_file": "io.html",
      "context": "   ) from e      return plugin_converter(quantum_circuit, measurements=measurements)     [docs] def from_pyquil(pyquil_program):     \"\"\"Loads pyQuil Program objects by using the converter in the     P"
    },
    {
      "id": "qml.from_qiskit_noise",
      "name": "qml.from_qiskit_noise",
      "type": "function",
      "description": "PennyLane API: from_qiskit_noise. Found in io.html",
      "source_file": "io.html",
      "context": "ept KeyError as e:         raise RuntimeError(_MISSING_QISKIT_PLUGIN_MESSAGE) from e     [docs] def from_qiskit_noise(noise_model, verbose=False, decimal_places=None):     \"\"\"Converts a Qiskit `NoiseM"
    },
    {
      "id": "qml.QubitChannel",
      "name": "qml.QubitChannel",
      "type": "class",
      "description": "PennyLane API: QubitChannel. Found in io.html",
      "source_file": "io.html",
      "context": "   verbose (bool): when printing a ``NoiseModel``, a complete list of Kraus matrices for each ``qml.QubitChannel``             is displayed with ``verbose=True``. By default, ``verbose=False`` and onl"
    },
    {
      "id": "qml.from_quil",
      "name": "qml.from_quil",
      "type": "function",
      "description": "PennyLane API: from_quil. Found in io.html",
      "source_file": "io.html",
      "context": "ugin_converters[\"pyquil_program\"].load()     return plugin_converter(pyquil_program)     [docs] def from_quil(quil: str):     \"\"\"Loads quantum circuits from a Quil string using the converter in the   "
    },
    {
      "id": "qml.from_qiskit_op",
      "name": "qml.from_qiskit_op",
      "type": "function",
      "description": "PennyLane API: from_qiskit_op. Found in io.html",
      "source_file": "io.html",
      "context": "ept KeyError as e:         raise RuntimeError(_MISSING_QISKIT_PLUGIN_MESSAGE) from e     [docs] def from_qiskit_op(qiskit_op, params=None, wires=None):     \"\"\"Converts a Qiskit `SparsePauliOp <https:/"
    },
    {
      "id": "qml.from_qiskit",
      "name": "qml.from_qiskit",
      "type": "function",
      "description": "PennyLane API: from_qiskit. Found in io.html",
      "source_file": "io.html",
      "context": "ennylane.io\") ) plugin_converters = {entry.name: entry for entry in __plugin_devices}    [docs] def from_qiskit(quantum_circuit, measurements=None):     r\"\"\"Converts a Qiskit `QuantumCircuit <https://"
    },
    {
      "id": "qml.from_qasm3",
      "name": "qml.from_qasm3",
      "type": "function",
      "description": "PennyLane API: from_qasm3. Found in io.html",
      "source_file": "io.html",
      "context": " **only** the measurements from the ``measurements`` argument otherwise.      .. seealso:: :func:`~.from_qasm3`, which relies on the ``openqasm3`` and ``openqasm3[parser]`` packages         instead of"
    },
    {
      "id": "qml.NoiseModel",
      "name": "qml.NoiseModel",
      "type": "class",
      "description": "PennyLane API: NoiseModel. Found in io.html",
      "source_file": "io.html",
      "context": "] def from_qiskit_noise(noise_model, verbose=False, decimal_places=None):     \"\"\"Converts a Qiskit `NoiseModel <https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html>`__     into "
    },
    {
      "id": "qml.from_qasm",
      "name": "qml.from_qasm",
      "type": "function",
      "description": "PennyLane API: from_qasm. Found in io.html",
      "source_file": "io.html",
      "context": "ept KeyError as e:         raise RuntimeError(_MISSING_QISKIT_PLUGIN_MESSAGE) from e     [docs] def from_qasm(quantum_circuit: str, measurements=None):     r\"\"\"     Loads quantum circuits from a QASM "
    },
    {
      "id": "qml.from_quil_file",
      "name": "qml.from_quil_file",
      "type": "function",
      "description": "PennyLane API: from_quil_file. Found in io.html",
      "source_file": "io.html",
      "context": "lugin_converter = plugin_converters[\"quil\"].load()     return plugin_converter(quil)     [docs] def from_quil_file(quil_filename: str):     \"\"\"Loads quantum circuits from a Quil file using the convert"
    },
    {
      "id": "qiskit.circuit.Parameter",
      "name": "qiskit.circuit.Parameter",
      "type": "function",
      "description": "Qiskit API: circuit.Parameter. Found in io.html",
      "source_file": "io.html",
      "context": "` is parametrized if it contains         `Parameter <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Parameter>`__ or         `ParameterVector <https://docs.quantum.ibm.com/api/qiskit/qiskit.ci"
    },
    {
      "id": "qiskit.circuit.ParameterVector",
      "name": "qiskit.circuit.ParameterVector",
      "type": "function",
      "description": "Qiskit API: circuit.ParameterVector. Found in io.html",
      "source_file": "io.html",
      "context": "t.circuit.Parameter>`__ or         `ParameterVector <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.ParameterVector>`__         references that need to be given defined values to evaluate the "
    },
    {
      "id": "qiskit.circuit.IfElseOp",
      "name": "qiskit.circuit.IfElseOp",
      "type": "function",
      "description": "Qiskit API: circuit.IfElseOp. Found in io.html",
      "source_file": "io.html",
      "context": "rcuit``.          Furthermore, the Qiskit `IfElseOp <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.IfElseOp>`__,         `SwitchCaseOp <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit."
    },
    {
      "id": "qiskit.quantum_info.Pauli",
      "name": "qiskit.quantum_info.Pauli",
      "type": "function",
      "description": "Qiskit API: quantum_info.Pauli. Found in io.html",
      "source_file": "io.html",
      "context": "ore details, see the         `String representation <https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Pauli>`_         section of the Qiskit documentation for the ``Pauli`` class.      **Ex"
    },
    {
      "id": "qiskit.QuantumCircuit",
      "name": "qiskit.QuantumCircuit",
      "type": "function",
      "description": "Qiskit API: QuantumCircuit. Found in io.html",
      "source_file": "io.html",
      "context": "_devices}    [docs] def from_qiskit(quantum_circuit, measurements=None):     r\"\"\"Converts a Qiskit `QuantumCircuit <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit>`_     into a "
    },
    {
      "id": "qiskit.quantum_info.SparsePauliOp",
      "name": "qiskit.quantum_info.SparsePauliOp",
      "type": "function",
      "description": "Qiskit API: quantum_info.SparsePauliOp. Found in io.html",
      "source_file": "io.html",
      "context": "ires=None):     \"\"\"Converts a Qiskit `SparsePauliOp <https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.SparsePauliOp>`__     into a PennyLane :class:`Operator <pennylane.operation.Operator>`"
    },
    {
      "id": "qiskit.circuit.QuantumCircuit",
      "name": "qiskit.circuit.QuantumCircuit",
      "type": "function",
      "description": "Qiskit API: circuit.QuantumCircuit. Found in io.html",
      "source_file": "io.html",
      "context": "ts=None):     r\"\"\"Converts a Qiskit `QuantumCircuit <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit>`_     into a PennyLane :ref:`quantum function <intro_vcirc_qfunc>`.      .. "
    },
    {
      "id": "qiskit.github.io",
      "name": "qiskit.github.io",
      "type": "function",
      "description": "Qiskit API: github.io. Found in io.html",
      "source_file": "io.html",
      "context": "se_model, verbose=False, decimal_places=None):     \"\"\"Converts a Qiskit `NoiseModel <https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html>`__     into a PennyLane :class:`~.Noise"
    },
    {
      "id": "qiskit.circuit",
      "name": "qiskit.circuit",
      "type": "function",
      "description": "Qiskit API: circuit. Found in io.html",
      "source_file": "io.html",
      "context": "e.io.io      Table of contents           Search         Using PennyLane  What is PennyLane? Quantum circuits Gradients and training Quantum operators Measurements Dynamic quantum circuits Templates In"
    },
    {
      "id": "qiskit.quantum_info",
      "name": "qiskit.quantum_info",
      "type": "function",
      "description": "Qiskit API: quantum_info. Found in io.html",
      "source_file": "io.html",
      "context": "ires=None):     \"\"\"Converts a Qiskit `SparsePauliOp <https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.SparsePauliOp>`__     into a PennyLane :class:`Operator <pennylane.operation.Operator>`"
    },
    {
      "id": "qiskit.circuit.Instruction",
      "name": "qiskit.circuit.Instruction",
      "type": "function",
      "description": "Qiskit API: circuit.Instruction. Found in io.html",
      "source_file": "io.html",
      "context": "t/qiskit.circuit.SwitchCaseOp>`__ and         `c_if <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Instruction#c_if>`__         conditional workflows are automatically translated into their P"
    },
    {
      "id": "qiskit.circuit.SwitchCaseOp",
      "name": "qiskit.circuit.SwitchCaseOp",
      "type": "function",
      "description": "Qiskit API: circuit.SwitchCaseOp. Found in io.html",
      "source_file": "io.html",
      "context": "/qiskit.circuit.IfElseOp>`__,         `SwitchCaseOp <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.SwitchCaseOp>`__ and         `c_if <https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.I"
    },
    {
      "id": "qml.ToBloq",
      "name": "qml.ToBloq",
      "type": "class",
      "description": "PennyLane API: ToBloq. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": "ops (bool): Whether to map operations to a Qualtran Bloq. Operations are wrapped             as a ``ToBloq`` when ``False``. Default is ``True``.         custom_mapping (dict | None): Dictionary to sp"
    },
    {
      "id": "qml.to_bloq",
      "name": "qml.to_bloq",
      "type": "function",
      "description": "PennyLane API: to_bloq. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": " {})      gate_counts[qt_gates.Hadamard()] = len(op.estimation_wires)     controlled_unitary = _map_to_bloq(         op.hyperparameters[\"unitary\"], call_graph=\"decomposition\"     ).controlled(CtrlSpec"
    },
    {
      "id": "qml.registers",
      "name": "qml.registers",
      "type": "function",
      "description": "PennyLane API: registers. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": "ort Operation, Operator from pennylane.queuing import AnnotatedQueue, QueuingManager from pennylane.registers import registers from pennylane.tape import make_qscript from pennylane.templates.state_pr"
    },
    {
      "id": "qml.bloq_registers",
      "name": "qml.bloq_registers",
      "type": "function",
      "description": "PennyLane API: bloq_registers. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": ".bookkeeping.Split)     def _(bloq, wires):         return None      return _to_pl_op    [docs] def bloq_registers(bloq: \"qt.Bloq\"):     \"\"\"Reads a `Qualtran Bloq <https://qualtran.readthedocs.io/en/l"
    },
    {
      "id": "qml.FromBloq",
      "name": "qml.FromBloq",
      "type": "class",
      "description": "PennyLane API: FromBloq. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": "turn None   def _get_to_pl_op():     @singledispatch     def _to_pl_op(bloq, wires):         return FromBloq(bloq=bloq, wires=wires)      @_to_pl_op.register     def _(bloq: qt.bloqs.basic_gates.CNOT,"
    },
    {
      "id": "qml.trotterize",
      "name": "qml.trotterize",
      "type": "function",
      "description": "PennyLane API: trotterize. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": "et_op_call_graph.register def _(op: qtemps.subroutines.TrotterizedQfunc):     \"\"\"Call graph for qml.trotterize\"\"\"      # From ResourceTrotterizedQfunc     n = op.hyperparameters[\"n\"]     order = op.hy"
    },
    {
      "id": "qml.QuantumPhaseEstimation",
      "name": "qml.QuantumPhaseEstimation",
      "type": "class",
      "description": "PennyLane API: QuantumPhaseEstimation. Found in qualtran_io.html",
      "source_file": "qualtran_io.html",
      "context": "a decomposition\"\"\"      return None   @_get_op_call_graph.register def _(op: qtemps.subroutines.qpe.QuantumPhaseEstimation):     \"\"\"Call graph for Quantum Phase Estimation\"\"\"      # From ResourceQFT  "
    },
    {
      "id": "qml.to_openqasm",
      "name": "qml.to_openqasm",
      "type": "function",
      "description": "PennyLane API: to_openqasm. Found in to_openqasm.html",
      "source_file": "to_openqasm.html",
      "context": "                                  pennylane.io.to_openqasm — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.kernels.target_alignment",
      "name": "qml.kernels.target_alignment",
      "type": "function",
      "description": "PennyLane API: kernels.target_alignment. Found in cost_functions.html",
      "source_file": "cost_functions.html",
      "context": "ault_rng(seed=1234)     >>> X = rng.random((4, 2))     >>> Y = np.array([-1, -1, 1, 1])     >>> qml.kernels.target_alignment(X, Y, kernel)     np.float64(0.0582...)      We can see that this is equiva"
    },
    {
      "id": "qml.templates.AngleEmbedding",
      "name": "qml.templates.AngleEmbedding",
      "type": "function",
      "description": "PennyLane API: templates.AngleEmbedding. Found in cost_functions.html",
      "source_file": "cost_functions.html",
      "context": "vice('default.qubit', wires=2)         @qml.qnode(dev)         def circuit(x1, x2):             qml.templates.AngleEmbedding(x1, wires=dev.wires)             qml.adjoint(qml.templates.AngleEmbedding)("
    },
    {
      "id": "qml.kernels.polarity",
      "name": "qml.kernels.polarity",
      "type": "function",
      "description": "PennyLane API: kernels.polarity. Found in cost_functions.html",
      "source_file": "cost_functions.html",
      "context": "ault_rng(seed=1234)     >>> X = rng.random((4, 2))     >>> Y = np.array([-1, -1, 1, 1])     >>> qml.kernels.polarity(X, Y, kernel)     np.float64(0.2196...)     \"\"\"     # pylint: disable=too-many-argu"
    },
    {
      "id": "qml.kernels.displace_matrix",
      "name": "qml.kernels.displace_matrix",
      "type": "function",
      "description": "PennyLane API: kernels.displace_matrix. Found in postprocessing.html",
      "source_file": "postprocessing.html",
      "context": "olute value of the smallest (the most negative, that is)     eigenvalue:      >>> K_displaced = qml.kernels.displace_matrix(K)     >>> np.linalg.eigvalsh(K_displaced)     array([0.,  2.,  3.])      If"
    },
    {
      "id": "qml.kernels.flip_matrix",
      "name": "qml.kernels.flip_matrix",
      "type": "function",
      "description": "PennyLane API: kernels.flip_matrix. Found in postprocessing.html",
      "source_file": "postprocessing.html",
      "context": "ve eigenvalues of the matrix, obtaining     non-negative eigenvalues only:      >>> K_flipped = qml.kernels.flip_matrix(K)     >>> np.linalg.eigvalsh(K_flipped)     array([1.,  1.,  2.])      If the i"
    },
    {
      "id": "qml.kernels.threshold_matrix",
      "name": "qml.kernels.threshold_matrix",
      "type": "function",
      "description": "PennyLane API: kernels.threshold_matrix. Found in postprocessing.html",
      "source_file": "postprocessing.html",
      "context": " 2.])      We then can threshold/truncate the eigenvalues of the matrix via      >>> K_thresh = qml.kernels.threshold_matrix(K)     >>> np.linalg.eigvalsh(K_thresh)     array([0.,  1.,  2.])      If t"
    },
    {
      "id": "qml.kernels.closest_psd_matrix",
      "name": "qml.kernels.closest_psd_matrix",
      "type": "function",
      "description": "PennyLane API: kernels.closest_psd_matrix. Found in postprocessing.html",
      "source_file": "postprocessing.html",
      "context": "alues thresholded at 0,     as computed by :func:`~.kernels.threshold_matrix`:      >>> K_psd = qml.kernels.closest_psd_matrix(K)     >>> K_psd     array([[0.95, 0.95],             [0.95, 0.95]])     "
    },
    {
      "id": "qml.kernels.kernel_matrix",
      "name": "qml.kernels.kernel_matrix",
      "type": "function",
      "description": "PennyLane API: kernels.kernel_matrix. Found in utils.html",
      "source_file": "utils.html",
      "context": "t_rng(seed=1234)     >>> X_train = rng.random((4,2))     >>> X_test = rng.random((3,2))     >>> qml.kernels.kernel_matrix(X_train, X_test, kernel)     array([[0.99656842, 0.91774724, 0.93966202],     "
    },
    {
      "id": "qml.kernels.square_kernel_matrix",
      "name": "qml.kernels.square_kernel_matrix",
      "type": "function",
      "description": "PennyLane API: kernels.square_kernel_matrix. Found in utils.html",
      "source_file": "utils.html",
      "context": "`X`` via      >>> rng = np.random.default_rng(seed=1234)     >>> X = rng.random((4, 2))     >>> qml.kernels.square_kernel_matrix(X, kernel)     array([[1.        , 0.9957817 , 0.88043387, 0.87011008],"
    },
    {
      "id": "qml.math.ndim",
      "name": "qml.math.ndim",
      "type": "function",
      "description": "PennyLane API: math.ndim. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "\"     if tol is None:         tol = 1e-10     coeffs = pauli_coefficients(H)     if single_H := qml.math.ndim(coeffs) == 1:         coeffs = [coeffs]      n = int(np.round(np.log2(qml.math.shape(coeff"
    },
    {
      "id": "qml.math.moveaxis",
      "name": "qml.math.moveaxis",
      "type": "function",
      "description": "PennyLane API: math.moveaxis. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "(because `_walsh_hadamard_transform` only takes one batch axis)     term_mat = qml.math.reshape(qml.math.moveaxis(sliced_H, 0, -1), (-1, dim))     # Apply Walsh-Hadamard transform     hadamard_transfo"
    },
    {
      "id": "qml.math.where",
      "name": "qml.math.where",
      "type": "function",
      "description": "PennyLane API: math.where. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "log2(qml.math.shape(coeffs)[1]))) // 2      H_ops = []     for _coeffs in coeffs:         ids = qml.math.where(qml.math.abs(_coeffs) > tol)[0]         sentence = PauliSentence({_idx_to_pw(idx, n): c f"
    },
    {
      "id": "qml.math.take",
      "name": "qml.math.take",
      "type": "function",
      "description": "PennyLane API: math.take. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "indices(dim)     # Apply the permutation by slicing and stacking again     sliced_H = [         qml.math.take(H[..., idx, :], _indices, axis=-1) for idx, _indices in enumerate(indices)     ]     slice"
    },
    {
      "id": "qml.math.bitwise_xor",
      "name": "qml.math.bitwise_xor",
      "type": "function",
      "description": "PennyLane API: math.bitwise_xor. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": ".\"\"\"     indices = [qml.math.arange(dim)]     for idx in range(dim - 1):         indices.append(qml.math.bitwise_xor(indices[-1], (idx + 1) ^ (idx)))     return indices   def _make_extraction_indices("
    },
    {
      "id": "qml.pauli.batched_pauli_decompose",
      "name": "qml.pauli.batched_pauli_decompose",
      "type": "function",
      "description": "PennyLane API: pauli.batched_pauli_decompose. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "), -2, -1     )     # Extract the coefficients by reordering them according to the encoding in `qml.pauli.batched_pauli_decompose`     indices = _make_extraction_indices(n)     new_shape = (dim**2,) i"
    },
    {
      "id": "qml.math.multiply",
      "name": "qml.math.multiply",
      "type": "function",
      "description": "PennyLane API: math.multiply. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "pose the two Hilbert-space-dim axes     coefficients = qml.math.moveaxis(         qml.math.real(qml.math.multiply(hadamard_transform_mat, phase_mat)), -2, -1     )     # Extract the coefficients by re"
    },
    {
      "id": "qml.pauli.trace_inner_product",
      "name": "qml.pauli.trace_inner_product",
      "type": "function",
      "description": "PennyLane API: pauli.trace_inner_product. Found in dense_util.html",
      "source_file": "dense_util.html",
      "context": "  >>> ops = [qml.X(0), qml.X(0) + qml.Y(0), qml.Y(0) + qml.Z(0)]     >>> check_orthonormal(ops, qml.pauli.trace_inner_product)     False     >>> ops_orth = orthonormalize(ops)     >>> check_orthonorma"
    },
    {
      "id": "qml.pauli.pauli_group",
      "name": "qml.pauli.pauli_group",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_group. Found in recursive_cartan_decomp.html",
      "source_file": "recursive_cartan_decomp.html",
      "context": "to the skew-Hermitian algebra elements via multiplication     by :math:`i`. Also note that :func:`~.pauli.pauli_group` returns the identity as the first     element, which is not part of the special u"
    },
    {
      "id": "qml.structure_constants",
      "name": "qml.structure_constants",
      "type": "function",
      "description": "PennyLane API: structure_constants. Found in variational_kak.html",
      "source_file": "variational_kak.html",
      "context": "nvolution=involution)         assert check_cartan_decomp(k, m)          g = k + m         adj = qml.structure_constants(g)          g, k, mtilde, a, adj = horizontal_cartan_subalgebra(g, k, m, adj, to"
    },
    {
      "id": "qml.lie_closure",
      "name": "qml.lie_closure",
      "type": "function",
      "description": "PennyLane API: lie_closure. Found in variational_kak.html",
      "source_file": "variational_kak.html",
      "context": " range(n - 1)]         gens += [Z(i) for i in range(n)]         H = qml.sum(*gens)          g = qml.lie_closure(gens)         g = [op.pauli_rep for op in g]          involution = concurrence_involutio"
    },
    {
      "id": "qml.sum",
      "name": "qml.sum",
      "type": "function",
      "description": "PennyLane API: sum. Found in variational_kak.html",
      "source_file": "variational_kak.html",
      "context": " e^{i\\mathfrak{k}}` such that      .. math:: H = K_c a K_c^\\dagger.      In particular, :math:`a = \\sum_j c_j a_j` is decomposed in terms of commuting operators :math:`a_j \\in \\mathfrak{a}`.     This "
    },
    {
      "id": "qml.exp",
      "name": "qml.exp",
      "type": "function",
      "description": "PennyLane API: exp. Found in variational_kak.html",
      "source_file": "variational_kak.html",
      "context": " License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitati"
    },
    {
      "id": "qml.QueuingManager",
      "name": "qml.QueuingManager",
      "type": "class",
      "description": "PennyLane API: QueuingManager. Found in qubit_manager.html",
      "source_file": "qubit_manager.html",
      "context": "resources.\"\"\"      def __init__(self, num_wires):         self.num_wires = num_wires         if qml.QueuingManager.recording():             self.queue()      def queue(self, context=qml.QueuingManager"
    },
    {
      "id": "qml.QueuingManager.recording",
      "name": "qml.QueuingManager.recording",
      "type": "class",
      "description": "PennyLane API: QueuingManager.recording. Found in qubit_manager.html",
      "source_file": "qubit_manager.html",
      "context": "resources.\"\"\"      def __init__(self, num_wires):         self.num_wires = num_wires         if qml.QueuingManager.recording():             self.queue()      def queue(self, context=qml.QueuingManager"
    },
    {
      "id": "qml.change_op_basis",
      "name": "qml.change_op_basis",
      "type": "function",
      "description": "PennyLane API: change_op_basis. Found in select_pauli_rot_phase_gradient.html",
      "source_file": "select_pauli_rot_phase_gradient.html",
      "context": "(wire), control=target_wire, control_values=[0]) for wire in phase_grad_wires     ]      return qml.change_op_basis(         qml.prod(*ops[::-1]),         qml.SemiAdder(angle_wires, phase_grad_wires, "
    },
    {
      "id": "qml.prod",
      "name": "qml.prod",
      "type": "function",
      "description": "PennyLane API: prod. Found in select_pauli_rot_phase_gradient.html",
      "source_file": "select_pauli_rot_phase_gradient.html",
      "context": "control_values=[0]) for wire in phase_grad_wires     ]      return qml.change_op_basis(         qml.prod(*ops[::-1]),         qml.SemiAdder(angle_wires, phase_grad_wires, work_wires[: len(angle_wires)"
    },
    {
      "id": "qml.SelectPauliRot",
      "name": "qml.SelectPauliRot",
      "type": "class",
      "description": "PennyLane API: SelectPauliRot. Found in select_pauli_rot_phase_gradient.html",
      "source_file": "select_pauli_rot_phase_gradient.html",
      "context": " phase_grad_wires: Wires,     work_wires: Wires, ) -> Operator:     \"\"\"Function that transforms the SelectPauliRot gate to the phase gradient circuit     The precision is implicitly defined by the len"
    },
    {
      "id": "qml.QROM",
      "name": "qml.QROM",
      "type": "class",
      "description": "PennyLane API: QROM. Found in select_pauli_rot_phase_gradient.html",
      "source_file": "select_pauli_rot_phase_gradient.html",
      "context": "wires)     binary_int = [_binary_repr_int(phi, precision) for phi in phis]      ops = [         qml.QROM(             binary_int, control_wires, angle_wires, work_wires=work_wires[len(angle_wires) - 1"
    },
    {
      "id": "qml.SemiAdder",
      "name": "qml.SemiAdder",
      "type": "class",
      "description": "PennyLane API: SemiAdder. Found in select_pauli_rot_phase_gradient.html",
      "source_file": "select_pauli_rot_phase_gradient.html",
      "context": "n phase_grad_wires     ]      return qml.change_op_basis(         qml.prod(*ops[::-1]),         qml.SemiAdder(angle_wires, phase_grad_wires, work_wires[: len(angle_wires) - 1]),     )    [docs] @trans"
    },
    {
      "id": "qml.liealg.check_commutation_relation",
      "name": "qml.liealg.check_commutation_relation",
      "type": "function",
      "description": "PennyLane API: liealg.check_commutation_relation. Found in cartan_decomp.html",
      "source_file": "cartan_decomp.html",
      "context": "nd any_tensors:         raise TypeError(             \"All inputs `ops1`, `ops2` and `vspace` to qml.liealg.check_commutation_relation need to either be iterables of operators or matrices.\"         )  "
    },
    {
      "id": "qml.center",
      "name": "qml.center",
      "type": "function",
      "description": "PennyLane API: center. Found in center.html",
      "source_file": "center.html",
      "context": "                                  pennylane.liealg.center — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.liealg.cartan_decomp",
      "name": "qml.liealg.cartan_decomp",
      "type": "function",
      "description": "PennyLane API: liealg.cartan_decomp. Found in horizontal_cartan_subalgebra.html",
      "source_file": "horizontal_cartan_subalgebra.html",
      "context": "g = [op.pauli_rep for op in g] # optional; turn to PauliSentence for convenience     >>> k, m = qml.liealg.cartan_decomp(g, qml.liealg.even_odd_involution)     >>> g = k + m # re-order g to separate k"
    },
    {
      "id": "qml.pauli_decompose",
      "name": "qml.pauli_decompose",
      "type": "function",
      "description": "PennyLane API: pauli_decompose. Found in horizontal_cartan_subalgebra.html",
      "source_file": "horizontal_cartan_subalgebra.html",
      "context": "ense matrices in this example, we transform the operators back to PennyLane operators using :func:`~pauli_decompose`.          >>> from pennylane.liealg import adjvec_to_op         >>> a = adjvec_to_o"
    },
    {
      "id": "qml.liealg.adjvec_to_op",
      "name": "qml.liealg.adjvec_to_op",
      "type": "function",
      "description": "PennyLane API: liealg.adjvec_to_op. Found in horizontal_cartan_subalgebra.html",
      "source_file": "horizontal_cartan_subalgebra.html",
      "context": "unc:`~adjvec_to_op` for conversion of the returned collections of adjoint vectors.      >>> a = qml.liealg.adjvec_to_op(np_a, g)     >>> a # doctest: +SKIP     [-1.0 * Z(0) @ Z(1), -1.0 * Y(0) @ Y(1),"
    },
    {
      "id": "qml.liealg.horizontal_cartan_subalgebra",
      "name": "qml.liealg.horizontal_cartan_subalgebra",
      "type": "function",
      "description": "PennyLane API: liealg.horizontal_cartan_subalgebra. Found in horizontal_cartan_subalgebra.html",
      "source_file": "horizontal_cartan_subalgebra.html",
      "context": "                                  pennylane.liealg.horizontal_cartan_subalgebra — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.liealg.check_abelian",
      "name": "qml.liealg.check_abelian",
      "type": "function",
      "description": "PennyLane API: liealg.check_abelian. Found in horizontal_cartan_subalgebra.html",
      "source_file": "horizontal_cartan_subalgebra.html",
      "context": "hese all commute with each other, as the CSA is Abelian (i.e., all operators commute).      >>> qml.liealg.check_abelian(a)     True      We can opt-in to return what we call adjoint vectors of dimens"
    },
    {
      "id": "qml.liealg.even_odd_involution",
      "name": "qml.liealg.even_odd_involution",
      "type": "function",
      "description": "PennyLane API: liealg.even_odd_involution. Found in horizontal_cartan_subalgebra.html",
      "source_file": "horizontal_cartan_subalgebra.html",
      "context": "g] # optional; turn to PauliSentence for convenience     >>> k, m = qml.liealg.cartan_decomp(g, qml.liealg.even_odd_involution)     >>> g = k + m # re-order g to separate k and m     >>> newg, k, mtil"
    },
    {
      "id": "qml.commutator",
      "name": "qml.commutator",
      "type": "function",
      "description": "PennyLane API: commutator. Found in lie_closure.html",
      "source_file": "lie_closure.html",
      "context": "enerators :math:`\\mathcal{G} = \\{G_1, .. , G_N\\}`.     For such generators, one computes all nested commutators :math:`[G_i, [G_j, .., [G_k, G_\\ell]]]` until no new operators are generated from commut"
    },
    {
      "id": "qml.math.decomposition",
      "name": "qml.math.decomposition",
      "type": "function",
      "description": "PennyLane API: math.decomposition. Found in decomposition.html",
      "source_file": "decomposition.html",
      "context": "                                  pennylane.math.decomposition — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.fidelity",
      "name": "qml.math.fidelity",
      "type": "function",
      "description": "PennyLane API: math.fidelity. Found in fidelity.html",
      "source_file": "fidelity.html",
      "context": "                                  pennylane.math.fidelity — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.dm_from_state_vector",
      "name": "qml.math.dm_from_state_vector",
      "type": "function",
      "description": "PennyLane API: math.dm_from_state_vector. Found in fidelity.html",
      "source_file": "fidelity.html",
      "context": "quantum states.      **Example**      To find the fidelity between two state vectors, call :func:`~.math.dm_from_state_vector` on the     inputs first, e.g.:      >>> state0 = qml.math.dm_from_state_v"
    },
    {
      "id": "qml.math.fidelity_statevector",
      "name": "qml.math.fidelity_statevector",
      "type": "function",
      "description": "PennyLane API: math.fidelity_statevector. Found in fidelity.html",
      "source_file": "fidelity.html",
      "context": "-0.14925137j, 0.00746879-0.04941796j]     >>> state1 = [0.99500417+0.j, 0.09983342+0.j]     >>> qml.math.fidelity_statevector(state0, state1)     0.9905158135644924      .. seealso:: :func:`pennylane."
    },
    {
      "id": "qml.math.grad",
      "name": "qml.math.grad",
      "type": "function",
      "description": "PennyLane API: math.grad. Found in grad.html",
      "source_file": "grad.html",
      "context": "                                  pennylane.math.grad — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.get_deep_interface",
      "name": "qml.math.get_deep_interface",
      "type": "function",
      "description": "PennyLane API: math.get_deep_interface. Found in interface_utils.html",
      "source_file": "interface_utils.html",
      "context": "pecially useful when converting to the appropriate interface:      >>> qml.math.asarray(x, like=qml.math.get_deep_interface(x))     Array([[1, 2],            [3, 4]], dtype=int64)      \"\"\"     itr = v"
    },
    {
      "id": "qml.math.is_independent",
      "name": "qml.math.is_independent",
      "type": "function",
      "description": "PennyLane API: math.is_independent. Found in is_independent.html",
      "source_file": "is_independent.html",
      "context": "                                  pennylane.math.is_independent — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.expand_matrix",
      "name": "qml.math.expand_matrix",
      "type": "function",
      "description": "PennyLane API: math.expand_matrix. Found in matrix_manipulation.html",
      "source_file": "matrix_manipulation.html",
      "context": "le:      >>> from scipy import sparse     >>> mat = sparse.csr_matrix([[0, 1], [1, 0]])     >>> qml.math.expand_matrix(mat, wires=[1], wire_order=[0,1]).toarray()     array([[0., 1., 0., 0.],         "
    },
    {
      "id": "qml.math.frobenius_inner_product",
      "name": "qml.math.frobenius_inner_product",
      "type": "function",
      "description": "PennyLane API: math.frobenius_inner_product. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": "   **Example**      >>> A = np.random.random((3,3))     >>> B = np.random.random((3,3))     >>> qml.math.frobenius_inner_product(A, B)     3.091948202943376     \"\"\"     A, B = np.coerce([A, B], like=l"
    },
    {
      "id": "qml.math.scatter_element_add",
      "name": "qml.math.scatter_element_add",
      "type": "function",
      "description": "PennyLane API: math.scatter_element_add. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": ".tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])     >>> index = (1, 2)     >>> value = -3.1     >>> qml.math.scatter_element_add(tensor, index, value)     tensor([[ 0.1000,  0.2000,  0.3000],             "
    },
    {
      "id": "qml.math.einsum",
      "name": "qml.math.einsum",
      "type": "function",
      "description": "PennyLane API: math.einsum. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": "    >>> b = np.arange(5)     >>> c = np.arange(6).reshape(2,3)      Trace of a matrix:      >>> qml.math.einsum('ii', a)     60      Extract the diagonal (requires explicit form):      >>> qml.math.ei"
    },
    {
      "id": "qml.math.scatter",
      "name": "qml.math.scatter",
      "type": "function",
      "description": "PennyLane API: math.scatter. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": " = np.array([4, 3, 1, 7])     >>> updates = np.array([9, 10, 11, 12])     >>> shape = 8     >>> qml.math.scatter(indices, updates, shape)     array([ 0, 11,  0, 10,  9,  0,  0, 12])     \"\"\"     return"
    },
    {
      "id": "qml.math.diag",
      "name": "qml.math.diag",
      "type": "function",
      "description": "PennyLane API: math.diag. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": "or_like: the 2D diagonal tensor      **Example**      >>> x = [1., 2., tf.Variable(3.)]     >>> qml.math.diag(x)     <tf.Tensor: shape=(3, 3), dtype=float32, numpy=     array([[1., 0., 0.],           "
    },
    {
      "id": "qml.math.block_diag",
      "name": "qml.math.block_diag",
      "type": "function",
      "description": "PennyLane API: math.block_diag. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": "     torch.tensor([[1, 2, 3], [-1, -6, -3]]),     ...     torch.tensor([[5]])     ... ]     >>> qml.math.block_diag(t)     tensor([[ 1,  2,  0,  0,  0,  0],             [ 3,  4,  0,  0,  0,  0],      "
    },
    {
      "id": "qml.math.multi_dispatch",
      "name": "qml.math.multi_dispatch",
      "type": "function",
      "description": "PennyLane API: math.multi_dispatch. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": "                                  pennylane.math.multi_dispatch — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.get_trainable_indices",
      "name": "qml.math.get_trainable_indices",
      "type": "function",
      "description": "PennyLane API: math.get_trainable_indices. Found in multi_dispatch.html",
      "source_file": "multi_dispatch.html",
      "context": " from pennylane import numpy as np     >>> def cost_fn(params):     ...     print(\"Trainable:\", qml.math.get_trainable_indices(params))     ...     return np.sum(np.sin(params[0] * params[1]))     >>>"
    },
    {
      "id": "qml.math.trace_distance",
      "name": "qml.math.trace_distance",
      "type": "function",
      "description": "PennyLane API: math.trace_distance. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "stance between two equal states is always zero:      >>> x = np.array([[1, 0], [0, 0]])     >>> qml.math.trace_distance(x, x)     0.0      It is possible to use state vectors by first transforming the"
    },
    {
      "id": "qml.math.expectation_value",
      "name": "qml.math.expectation_value",
      "type": "function",
      "description": "PennyLane API: math.expectation_value. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "/ np.sqrt(2), 0]     >>> operator_matrix = qml.matrix(qml.PauliZ(0), wire_order=[0, 1])     >>> qml.math.expectation_value(operator_matrix, state_vector)     tensor(-2.23711432e-17+0.j, requires_grad="
    },
    {
      "id": "qml.math.relative_entropy",
      "name": "qml.math.relative_entropy",
      "type": "function",
      "description": "PennyLane API: math.relative_entropy. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "always zero:      >>> x = np.array([1, 0])     >>> x = qml.math.dm_from_state_vector(x)     >>> qml.math.relative_entropy(x, x)     0.0      and the relative entropy between two non-equal pure states "
    },
    {
      "id": "qml.math.reduce_statevector",
      "name": "qml.math.reduce_statevector",
      "type": "function",
      "description": "PennyLane API: math.reduce_statevector. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "indices))`` or ``(batch_dim, 2**len(indices), 2**len(indices))``      .. seealso:: :func:`pennylane.math.reduce_statevector`, and :func:`pennylane.density_matrix`      **Example**      >>> x = np.arra"
    },
    {
      "id": "qml.math.cov_matrix",
      "name": "qml.math.cov_matrix",
      "type": "function",
      "description": "PennyLane API: math.cov_matrix. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "ayers=2, n_wires=3)     >>> weights = np.random.random(shape, requires_grad=True)     >>> cov = qml.math.cov_matrix(circuit(weights), obs_list)     >>> cov     tensor([[0.98125435, 0.4905541 ],       "
    },
    {
      "id": "qml.templates.StronglyEntanglingLayers",
      "name": "qml.templates.StronglyEntanglingLayers",
      "type": "function",
      "description": "PennyLane API: templates.StronglyEntanglingLayers. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "nsatz and observable list:      >>> obs_list = [qml.X(0) @ qml.Z(1), qml.Y(2)]     >>> ansatz = qml.templates.StronglyEntanglingLayers      We can construct a QNode to output the probability distribut"
    },
    {
      "id": "qml.templates.StronglyEntanglingLayers.shape",
      "name": "qml.templates.StronglyEntanglingLayers.shape",
      "type": "function",
      "description": "PennyLane API: templates.StronglyEntanglingLayers.shape. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "turn qml.probs(wires=[0, 1, 2])      We can now compute the covariance matrix:      >>> shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=2, n_wires=3)     >>> weights = np.random.random(s"
    },
    {
      "id": "qml.math.choi_matrix",
      "name": "qml.math.choi_matrix",
      "type": "function",
      "description": "PennyLane API: math.choi_matrix. Found in quantum.html",
      "source_file": "quantum.html",
      "context": ".      >>> import pennylane as qml     >>> Ks = [qml.matrix(qml.CNOT((0, 1)))]     >>> Lambda = qml.math.choi_matrix(Ks)     >>> Lambda.shape     (16, 16)      The resulting Choi matrix is a density m"
    },
    {
      "id": "qml.math.vn_entanglement_entropy",
      "name": "qml.math.vn_entanglement_entropy",
      "type": "function",
      "description": "PennyLane API: math.vn_entanglement_entropy. Found in quantum.html",
      "source_file": "quantum.html",
      "context": "> x = np.array([0, -1, 1, 0]) / np.sqrt(2)     >>> x = qml.math.dm_from_state_vector(x)     >>> qml.math.vn_entanglement_entropy(x, indices0=[0], indices1=[1])     0.6931471805599453      It is also p"
    },
    {
      "id": "qml.math.binary_finite_reduced_row_echelon",
      "name": "qml.math.binary_finite_reduced_row_echelon",
      "type": "function",
      "description": "PennyLane API: math.binary_finite_reduced_row_echelon. Found in utils.html",
      "source_file": "utils.html",
      "context": " [1, 0, 1, 0, 0, 0, 1, 0],     ...                           [0, 0, 0, 1, 1, 0, 0, 1]])     >>> qml.math.binary_finite_reduced_row_echelon(binary_matrix)     array([[1, 0, 0, 0, 0, 1, 0, 0],          "
    },
    {
      "id": "qml.math.is_real_obj_or_close",
      "name": "qml.math.is_real_obj_or_close",
      "type": "function",
      "description": "PennyLane API: math.is_real_obj_or_close. Found in math.html",
      "source_file": "math.html",
      "context": "    ``\"complex\"`` and returning the negated result of this.      >>> x = jnp.array(0.4)     >>> qml.math.is_real_obj_or_close(x)     True      >>> x = tf.Variable(0.4+0.2j)     >>> qml.math.is_real_ob"
    },
    {
      "id": "qml.math.get_dtype_name",
      "name": "qml.math.get_dtype_name",
      "type": "function",
      "description": "PennyLane API: math.get_dtype_name. Found in math.html",
      "source_file": "math.html",
      "context": "face independent way of getting the name of the datatype.      >>> x = tf.Variable(0.1)     >>> qml.math.get_dtype_name(tf.Variable(0.1))     'float32'     \"\"\"     return ar.get_dtype_name(x)     [doc"
    },
    {
      "id": "qml.shadow_expval",
      "name": "qml.shadow_expval",
      "type": "function",
      "description": "PennyLane API: shadow_expval. Found in classical_shadow.html",
      "source_file": "classical_shadow.html",
      "context": " an operator using the classical shadow measurement process.      Please refer to :func:`~pennylane.shadow_expval` for detailed documentation.      Args:         H (Operator, Sequence[Operator]): Oper"
    },
    {
      "id": "qml.density_matrix",
      "name": "qml.density_matrix",
      "type": "function",
      "description": "PennyLane API: density_matrix. Found in measurements.html",
      "source_file": "measurements.html",
      "context": " ...     def process_state(self, state, wire_order):     ...         # use the already defined `qml.density_matrix` measurement to compute the     ...         # reduced density matrix from the given s"
    },
    {
      "id": "qml.math.diagonal",
      "name": "qml.math.diagonal",
      "type": "function",
      "description": "PennyLane API: math.diagonal. Found in measurements.html",
      "source_file": "measurements.html",
      "context": " = qml.density_matrix(wires=self.wires).process_state(state, wire_order)     ...         return qml.math.diagonal(qml.math.real(density_matrix))      We can now execute it in a QNode:      >>> dev = q"
    },
    {
      "id": "qml.mutual_info",
      "name": "qml.mutual_info",
      "type": "function",
      "description": "PennyLane API: mutual_info. Found in mutual_info.html",
      "source_file": "mutual_info.html",
      "context": "                                  pennylane.measurements.mutual_info — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.measurements.NullMeasurement",
      "name": "qml.measurements.NullMeasurement",
      "type": "function",
      "description": "PennyLane API: measurements.NullMeasurement. Found in null_measurement.html",
      "source_file": "null_measurement.html",
      "context": "ault.qubit', wires=1), diff_method=\"parameter-shift\")     ... def circuit():     ...     return qml.measurements.NullMeasurement()     ...     >>> circuit()     array(nan)      ``np.array(np.nan)`` is"
    },
    {
      "id": "qml.purity",
      "name": "qml.purity",
      "type": "function",
      "description": "PennyLane API: purity. Found in purity.html",
      "source_file": "purity.html",
      "context": "                                  pennylane.measurements.purity — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.hstack",
      "name": "qml.math.hstack",
      "type": "function",
      "description": "PennyLane API: math.hstack. Found in sample.html",
      "source_file": "sample.html",
      "context": "          return qml.expval(qml.PauliX(0))              def cost(angle):                 return qml.math.hstack(circuit(angle))              angle = qml.numpy.array(0.1)             res = qml.jacobian"
    },
    {
      "id": "qml.measurements.add_shots",
      "name": "qml.measurements.add_shots",
      "type": "function",
      "description": "PennyLane API: measurements.add_shots. Found in shots.html",
      "source_file": "shots.html",
      "context": "         >>> s1 = Shots((5, (10, 2)))         >>> s2 = Shots((3, 2, (10, 3)))         >>> print(qml.measurements.add_shots(s1, s2))         Shots(total=60, vector=[5 shots, 10 shots x 2, 3 shots, 2 sh"
    },
    {
      "id": "qml.vn_entropy",
      "name": "qml.vn_entropy",
      "type": "function",
      "description": "PennyLane API: vn_entropy. Found in vn_entropy.html",
      "source_file": "vn_entropy.html",
      "context": "                                  pennylane.measurements.vn_entropy — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.PhaseDamping",
      "name": "qml.PhaseDamping",
      "type": "class",
      "description": "PennyLane API: PhaseDamping. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "= qml.noise.op_eq(qml.RX) & qml.noise.wires_in([0, 1])         noise1 = qml.noise.partial_wires(qml.PhaseDamping, 0.4)          fcond2 = qml.noise.op_in([qml.RX, qml.RZ])         def noise2(op, **kwar"
    },
    {
      "id": "qml.noise.wires_in",
      "name": "qml.noise.wires_in",
      "type": "function",
      "description": "PennyLane API: noise.wires_in. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "         dev = qml.device(\"default.mixed\", wires=2)          fcond1 = qml.noise.op_eq(qml.RX) & qml.noise.wires_in([0, 1])         noise1 = qml.noise.partial_wires(qml.PhaseDamping, 0.4)          fcon"
    },
    {
      "id": "qml.noise.op_eq",
      "name": "qml.noise.op_eq",
      "type": "function",
      "description": "PennyLane API: noise.op_eq. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "   .. code-block:: python          dev = qml.device(\"default.mixed\", wires=2)          fcond1 = qml.noise.op_eq(qml.RX) & qml.noise.wires_in([0, 1])         noise1 = qml.noise.partial_wires(qml.PhaseD"
    },
    {
      "id": "qml.noise.meas_eq",
      "name": "qml.noise.meas_eq",
      "type": "function",
      "description": "PennyLane API: noise.meas_eq. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "tionError(op.parameters[0] * 0.5, kwargs[\"t1\"],  kwargs[\"t2\"], 0.6, op.wires)          fcond3 = qml.noise.meas_eq(qml.expval) & qml.noise.wires_in([0, 1])         noise3 = qml.noise.partial_wires(qml."
    },
    {
      "id": "qml.workflow.get_transform_program",
      "name": "qml.workflow.get_transform_program",
      "type": "function",
      "description": "PennyLane API: workflow.get_transform_program. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "`QNode``. More details             on the following permissible values can be found in the :func:`~.workflow.get_transform_program` -              * ``str``: acceptable keys are ``\"top\"``, ``\"user\"``,"
    },
    {
      "id": "qml.noise.add_noise",
      "name": "qml.noise.add_noise",
      "type": "function",
      "description": "PennyLane API: noise.add_noise. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "                                  pennylane.noise.add_noise — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.transforms.undo_swaps",
      "name": "qml.transforms.undo_swaps",
      "type": "function",
      "description": "PennyLane API: transforms.undo_swaps. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "        dev = qml.device(\"default.mixed\", wires=2)              @qml.metric_tensor             @qml.transforms.undo_swaps             @qml.transforms.merge_rotations             @qml.transforms.cancel"
    },
    {
      "id": "qml.noise.partial_wires",
      "name": "qml.noise.partial_wires",
      "type": "function",
      "description": "PennyLane API: noise.partial_wires. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "ires=2)          fcond1 = qml.noise.op_eq(qml.RX) & qml.noise.wires_in([0, 1])         noise1 = qml.noise.partial_wires(qml.PhaseDamping, 0.4)          fcond2 = qml.noise.op_in([qml.RX, qml.RZ])      "
    },
    {
      "id": "qml.noise.op_in",
      "name": "qml.noise.op_in",
      "type": "function",
      "description": "PennyLane API: noise.op_in. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "es_in([0, 1])         noise1 = qml.noise.partial_wires(qml.PhaseDamping, 0.4)          fcond2 = qml.noise.op_in([qml.RX, qml.RZ])         def noise2(op, **kwargs):             qml.ThermalRelaxationErr"
    },
    {
      "id": "qml.ThermalRelaxationError",
      "name": "qml.ThermalRelaxationError",
      "type": "class",
      "description": "PennyLane API: ThermalRelaxationError. Found in add_noise.html",
      "source_file": "add_noise.html",
      "context": "       fcond2 = qml.noise.op_in([qml.RX, qml.RZ])         def noise2(op, **kwargs):             qml.ThermalRelaxationError(op.parameters[0] * 0.5, kwargs[\"t1\"],  kwargs[\"t2\"], 0.6, op.wires)          "
    },
    {
      "id": "qml.noise.wires_eq",
      "name": "qml.noise.wires_eq",
      "type": "function",
      "description": "PennyLane API: noise.wires_eq. Found in conditionals.html",
      "source_file": "conditionals.html",
      "context": " ``wires_eq`` with a given sequence of wires which are used as a wire set:      >>> cond_func = qml.noise.wires_eq(0)     >>> cond_func(qml.X(0))     True      >>> cond_func(qml.RY(1.23, wires=[3]))  "
    },
    {
      "id": "qml.noise.insert",
      "name": "qml.noise.insert",
      "type": "function",
      "description": "PennyLane API: noise.insert. Found in insert_ops.html",
      "source_file": "insert_ops.html",
      "context": "                                  pennylane.noise.insert_ops — PennyLane 0.45.0-dev3 documentation                       About     Research                 "
    },
    {
      "id": "qml.AmplitudeDamping",
      "name": "qml.AmplitudeDamping",
      "type": "class",
      "description": "PennyLane API: AmplitudeDamping. Found in insert_ops.html",
      "source_file": "insert_ops.html",
      "context": "lock:: python          dev = qml.device(\"default.mixed\", wires=2)          @qml.noise.insert(op=qml.AmplitudeDamping, op_args=0.2, position=\"end\")         @qml.qnode(dev)         def f(w, x, y, z):   "
    },
    {
      "id": "qml.add_noise",
      "name": "qml.add_noise",
      "type": "function",
      "description": "PennyLane API: add_noise. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "AmplitudeDamping` to     each gate of circuits executed on the device using the :func:`~.transforms.add_noise` transform:      .. code-block:: python          import pennylane as qml          dev = qm"
    },
    {
      "id": "qml.noise.richardson_extrapolate",
      "name": "qml.noise.richardson_extrapolate",
      "type": "function",
      "description": "PennyLane API: noise.richardson_extrapolate. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "factors) -1`` is also referred to as Richardson extrapolation and implemented in :func:`~.pennylane.noise.richardson_extrapolate`.         We can now visualize our fit to see how close we get to the i"
    },
    {
      "id": "qml.noise.exponential_extrapolate",
      "name": "qml.noise.exponential_extrapolate",
      "type": "function",
      "description": "PennyLane API: noise.exponential_extrapolate. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "p.random.default_rng(12345)     >>> y = np.exp(-x) + rng.normal(scale=0.1, size=len(x))     >>> qml.noise.exponential_extrapolate(x, y)     np.float64(1.015...)      \"\"\"     y = math.stack(y)     slop"
    },
    {
      "id": "qml.SimplifiedTwoDesign",
      "name": "qml.SimplifiedTwoDesign",
      "type": "class",
      "description": "PennyLane API: SimplifiedTwoDesign. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "mport fold_global, poly_extrapolate          n_wires = 2         n_layers = 2          shapes = qml.SimplifiedTwoDesign.shape(n_layers, n_wires)         rng = np.random.default_rng(12345)         w1, "
    },
    {
      "id": "qml.noise.fold_global",
      "name": "qml.noise.fold_global",
      "type": "function",
      "description": "PennyLane API: noise.fold_global. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "(1) @ qml.Z(2))       Setting ``scale_factor=1`` does not affect the circuit:      >>> folded = qml.noise.fold_global(circuit, 1)     >>> print(qml.draw(folded)(x))     0: ──RX(0.00)─╭●──RX(3.00)─────"
    },
    {
      "id": "qml.noise.poly_extrapolate",
      "name": "qml.noise.poly_extrapolate",
      "type": "function",
      "description": "PennyLane API: noise.poly_extrapolate. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "nylane.noise.mitigate_with_zne`         a differentiable polynomial fit function :func:`~.pennylane.noise.poly_extrapolate` is used.          >>> # coefficients are ordered like coeffs[0] * x**2 + coe"
    },
    {
      "id": "qml.SimplifiedTwoDesign.shape",
      "name": "qml.SimplifiedTwoDesign.shape",
      "type": "class",
      "description": "PennyLane API: SimplifiedTwoDesign.shape. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": "mport fold_global, poly_extrapolate          n_wires = 2         n_layers = 2          shapes = qml.SimplifiedTwoDesign.shape(n_layers, n_wires)         rng = np.random.default_rng(12345)         w1, "
    },
    {
      "id": "qml.noise.mitigate_with_zne",
      "name": "qml.noise.mitigate_with_zne",
      "type": "function",
      "description": "PennyLane API: noise.mitigate_with_zne. Found in mitigate.html",
      "source_file": "mitigate.html",
      "context": " folding is to artificially increase the noise for zero noise extrapolation, see :func:`~.pennylane.noise.mitigate_with_zne`.      Args:         tape (QNode or QuantumTape): the quantum circuit to be "
    },
    {
      "id": "qml.math.T",
      "name": "qml.math.T",
      "type": "function",
      "description": "PennyLane API: math.T. Found in operation.html",
      "source_file": "operation.html",
      "context": "broadcasting, respectively.'''                 decomp_ops = [qml.RX(x, wires=w) for x, w in zip(qml.math.T(theta), wires)]                 return decomp_ops          **The ``_check_batching`` method**"
    },
    {
      "id": "qml.pow",
      "name": "qml.pow",
      "type": "function",
      "description": "PennyLane API: pow. Found in operation.html",
      "source_file": "operation.html",
      "context": "method         def _add(a, b):             return qml.sum(a, b)          @staticmethod         def _pow(a, b):             return qml.pow(a, b)      return AbstractOperator   def create_operator_primi"
    },
    {
      "id": "qml.gradients.eigvals_to_frequencies",
      "name": "qml.gradients.eigvals_to_frequencies",
      "type": "function",
      "description": "PennyLane API: gradients.eigvals_to_frequencies. Found in operation.html",
      "source_file": "operation.html",
      "context": "= qml.generator(op, format=\"observable\")         >>> gen_eigvals = qml.eigvals(gen)         >>> qml.gradients.eigvals_to_frequencies(tuple(gen_eigvals))         (np.float64(1.0),)          For more de"
    },
    {
      "id": "qml.capture.autograph.ag_primitives.PRange",
      "name": "qml.capture.autograph.ag_primitives.PRange",
      "type": "function",
      "description": "PennyLane API: capture.autograph.ag_primitives.PRange. Found in operation.html",
      "source_file": "operation.html",
      "context": "           list,             tuple,             qml.wires.Wires,             range,             qml.capture.autograph.ag_primitives.PRange,             set,             *array_types,         )        "
    },
    {
      "id": "qml.Rot._unflatten",
      "name": "qml.Rot._unflatten",
      "type": "class",
      "description": "PennyLane API: Rot._unflatten. Found in operation.html",
      "source_file": "operation.html",
      "context": "  >>> op._flatten()         ((1.2,), (Wires([0, 1]), (('pauli_word', 'XY'),)))         >>> qml.PauliRot._unflatten(*op._flatten())         PauliRot(1.2, XY, wires=[0, 1])       .. details::         :t"
    },
    {
      "id": "qml.U2",
      "name": "qml.U2",
      "type": "class",
      "description": "PennyLane API: U2. Found in operation.html",
      "source_file": "operation.html",
      "context": "erator.data`` must implement their own         ``_flatten`` methods.          >>> op = qml.ctrl(qml.U2(3.4, 4.5, wires=\"a\"), (\"b\", \"c\") )         >>> op._flatten()         ((U2(3.4, 4.5, wires=['a']),"
    },
    {
      "id": "qml.eigvals",
      "name": "qml.eigvals",
      "type": "function",
      "description": "PennyLane API: eigvals. Found in operation.html",
      "source_file": "operation.html",
      "context": "epresentation via the **eigenvalue decomposition** specified by eigenvalues       (:meth:`.Operator.eigvals`) and diagonalizing gates (:meth:`.Operator.diagonalizing_gates`).      * Representation as "
    },
    {
      "id": "qml.math.requires_grad",
      "name": "qml.math.requires_grad",
      "type": "function",
      "description": "PennyLane API: math.requires_grad. Found in operation.html",
      "source_file": "operation.html",
      "context": "    \"\"\"Returns ``True`` if any of the parameters of an operator is trainable     according to ``qml.math.requires_grad``.     \"\"\"     return any(qml.math.requires_grad(p) for p in obj.parameters)    _"
    },
    {
      "id": "qml.ops.qubit.attributes.symmetric_over_all_wires",
      "name": "qml.ops.qubit.attributes.symmetric_over_all_wires",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.symmetric_over_all_wires. Found in operation.html",
      "source_file": "operation.html",
      "context": "erator     ~ops.qubit.attributes.self_inverses     ~ops.qubit.attributes.supports_broadcasting     ~ops.qubit.attributes.symmetric_over_all_wires     ~ops.qubit.attributes.symmetric_over_control_wires"
    },
    {
      "id": "qml.is_hermitian",
      "name": "qml.is_hermitian",
      "type": "function",
      "description": "PennyLane API: is_hermitian. Found in operation.html",
      "source_file": "operation.html",
      "context": "s._flatten, cls._unflatten)         cls._primitive = create_operator_primitive(cls)          if cls.is_hermitian != Operator.is_hermitian:             warnings.warn(                 \"The `is_hermitian"
    },
    {
      "id": "qml.generator",
      "name": "qml.generator",
      "type": "function",
      "description": "PennyLane API: generator. Found in operation.html",
      "source_file": "operation.html",
      "context": "sable_rotations     ~ops.qubit.attributes.diagonal_in_z_basis     ~ops.qubit.attributes.has_unitary_generator     ~ops.qubit.attributes.self_inverses     ~ops.qubit.attributes.supports_broadcasting   "
    },
    {
      "id": "qml.AmplitudeDamping.compute_kraus_matrices",
      "name": "qml.AmplitudeDamping.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: AmplitudeDamping.compute_kraus_matrices. Found in operation.html",
      "source_file": "operation.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.AmplitudeDamping.compute_kraus_matrices(0.1)         [array([[1.       , 0.       ],                "
    },
    {
      "id": "qml.operation.Operation",
      "name": "qml.operation.Operation",
      "type": "function",
      "description": "PennyLane API: operation.Operation. Found in operation.html",
      "source_file": "operation.html",
      "context": "tor.      .. code-block:: python          import pennylane as qml           class FlipAndRotate(qml.operation.Operation):              # This attribute tells PennyLane what differentiation method to u"
    },
    {
      "id": "qml.equal",
      "name": "qml.equal",
      "type": "function",
      "description": "PennyLane API: equal. Found in operation.html",
      "source_file": "operation.html",
      "context": "rocess_data(self),             )         )      def __eq__(self, other) -> bool:         return qml.equal(self, other)      def __hash__(self) -> int:         return self.hash   [docs]     @staticmeth"
    },
    {
      "id": "qml.math.linalg.eigvals",
      "name": "qml.math.linalg.eigvals",
      "type": "function",
      "description": "PennyLane API: math.linalg.eigvals. Found in operation.html",
      "source_file": "operation.html",
      "context": ".             if self.has_matrix:  # pylint: disable=using-constant-test                 return qml.math.linalg.eigvals(self.matrix())             raise EigvalsUndefinedError from e    [docs]     def "
    },
    {
      "id": "qml.math.allequal",
      "name": "qml.math.allequal",
      "type": "function",
      "description": "PennyLane API: math.allequal. Found in operation.html",
      "source_file": "operation.html",
      "context": "eturn qml.sum(self, other, lazy=False)         if isinstance(other, TensorLike):             if qml.math.allequal(other, 0):                 return self             return qml.sum(                 sel"
    },
    {
      "id": "qml.math.round",
      "name": "qml.math.round",
      "type": "function",
      "description": "PennyLane API: math.round. Found in operation.html",
      "source_file": "operation.html",
      "context": "def _mod_and_round(x, mod_val):         if mod_val is None:             return x         return qml.math.round(qml.math.real(x) % mod_val, 10)      # Use qml.math.real to take the real part. We may ge"
    },
    {
      "id": "qml.pulse.ParametrizedHamiltonian",
      "name": "qml.pulse.ParametrizedHamiltonian",
      "type": "function",
      "description": "PennyLane API: pulse.ParametrizedHamiltonian. Found in operation.html",
      "source_file": "operation.html",
      "context": "multiplication between scalars and Operators.\"\"\"         if callable(other):             return qml.pulse.ParametrizedHamiltonian([other], [self])         if isinstance(other, TensorLike):            "
    },
    {
      "id": "qml.math.toarray",
      "name": "qml.math.toarray",
      "type": "function",
      "description": "PennyLane API: math.toarray. Found in operation.html",
      "source_file": "operation.html",
      "context": "s is None:                     return \"\"                 try:                     return format(qml.math.toarray(x), f\".{decimals}f\")                 except ValueError:                     # If the pa"
    },
    {
      "id": "qml.s_prod",
      "name": "qml.s_prod",
      "type": "function",
      "description": "PennyLane API: s_prod. Found in operation.html",
      "source_file": "operation.html",
      "context": "       return qml.prod(*args)          @staticmethod         def _mul(a, b):             return qml.s_prod(b, a)          @staticmethod         def _rmul(a, b):             return qml.s_prod(b, a)    "
    },
    {
      "id": "qml.PauliRot._unflatten",
      "name": "qml.PauliRot._unflatten",
      "type": "class",
      "description": "PennyLane API: PauliRot._unflatten. Found in operation.html",
      "source_file": "operation.html",
      "context": "       >>> op._flatten()         ((1.2,), (Wires([0, 1]), (('pauli_word', 'XY'),)))         >>> qml.PauliRot._unflatten(*op._flatten())         PauliRot(1.2, XY, wires=[0, 1])       .. details::      "
    },
    {
      "id": "qml.pauli.PauliSentence",
      "name": "qml.pauli.PauliSentence",
      "type": "function",
      "description": "PennyLane API: pauli.PauliSentence. Found in operation.html",
      "source_file": "operation.html",
      "context": "ss__.__name__  #: str: name of the operator         self._id: str = id         self._pauli_rep: qml.pauli.PauliSentence | None = (             None  # Union[PauliSentence, None]: Representation of the"
    },
    {
      "id": "qml.PhaseDamping.compute_kraus_matrices",
      "name": "qml.PhaseDamping.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: PhaseDamping.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.PhaseDamping.compute_kraus_matrices(0.5)         [array([[1.        , 0.        ], [0.        , 0.70"
    },
    {
      "id": "qml.PhaseFlip.compute_kraus_matrices",
      "name": "qml.PhaseFlip.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: PhaseFlip.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.PhaseFlip.compute_kraus_matrices(0.5)         [array([[0.70710678, 0.        ], [0.        , 0.70710"
    },
    {
      "id": "qml.GeneralizedAmplitudeDamping.compute_kraus_matrices",
      "name": "qml.GeneralizedAmplitudeDamping.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: GeneralizedAmplitudeDamping.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.GeneralizedAmplitudeDamping.compute_kraus_matrices(0.3, 0.6)         [array([[0.63245553, 0.        "
    },
    {
      "id": "qml.BitFlip.compute_kraus_matrices",
      "name": "qml.BitFlip.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: BitFlip.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.BitFlip.compute_kraus_matrices(0.5)         [array([[0.70710678, 0.        ], [0.        , 0.7071067"
    },
    {
      "id": "qml.ResetError.compute_kraus_matrices",
      "name": "qml.ResetError.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: ResetError.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.ResetError.compute_kraus_matrices(0.2, 0.3)         [array([[0.70710678, 0.        ], [0.        , 0"
    },
    {
      "id": "qml.DepolarizingChannel.compute_kraus_matrices",
      "name": "qml.DepolarizingChannel.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: DepolarizingChannel.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.DepolarizingChannel.compute_kraus_matrices(0.5)         [array([[0.70710678+0.j, 0.        +0.j],   "
    },
    {
      "id": "qml.QubitChannel.compute_kraus_matrices",
      "name": "qml.QubitChannel.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: QubitChannel.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "*Example**          >>> K_list = qml.PhaseFlip(0.5, wires=0).kraus_matrices()         >>> res = qml.QubitChannel.compute_kraus_matrices(K_list)[0]         >>> all(np.allclose(r, k) for r, k  in zip(re"
    },
    {
      "id": "qml.ThermalRelaxationError.compute_kraus_matrices",
      "name": "qml.ThermalRelaxationError.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: ThermalRelaxationError.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.ThermalRelaxationError.compute_kraus_matrices(0.1, 1.2, 1.3, 0.1)         [array([[0.        , 0.   "
    },
    {
      "id": "qml.PauliError.compute_kraus_matrices",
      "name": "qml.PauliError.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: PauliError.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "    Returns:             list (array): list of Kraus matrices          **Example**          >>> qml.PauliError.compute_kraus_matrices(0.5, \"X\")         [array([[0.70710678, 0.        ], [0.        , 0"
    },
    {
      "id": "qml.FockStateProjector",
      "name": "qml.FockStateProjector",
      "type": "class",
      "description": "PennyLane API: FockStateProjector. Found in cv.html",
      "source_file": "cv.html",
      "context": "s=wires, id=id)      @staticmethod     def _heisenberg_rep(p):         return p[0]     [docs] class FockStateProjector(CVObservable):     r\"\"\"     The number state observable :math:`\\ket{n}\\bra{n}`.  "
    },
    {
      "id": "qml.FockStateVector",
      "name": "qml.FockStateVector",
      "type": "class",
      "description": "PennyLane API: FockStateVector. Found in cv.html",
      "source_file": "cv.html",
      "context": "rn base_label + f\"\\n({p})\"         return f\"|{math.asarray(self.parameters[0])}⟩\"      [docs] class FockStateVector(CVOperation):     r\"\"\"     Prepare subsystems using the given ket vector in the Fock"
    },
    {
      "id": "qml.TensorN",
      "name": "qml.TensorN",
      "type": "class",
      "description": "PennyLane API: TensorN. Found in cv.html",
      "source_file": "cv.html",
      "context": "lf, decimals=None, base_label=None, cache=None):         return base_label or \"n\"      [docs] class TensorN(CVObservable):     r\"\"\"     The tensor product of the :class:`~.NumberOperator` acting on di"
    },
    {
      "id": "qml.QuadOperator",
      "name": "qml.QuadOperator",
      "type": "class",
      "description": "PennyLane API: QuadOperator. Found in cv.html",
      "source_file": "cv.html",
      "context": "      @staticmethod     def _heisenberg_rep(p):         return np.array([0, 0, 1])     [docs] class QuadOperator(CVObservable):     r\"\"\"     The generalized quadrature observable :math:`\\x_\\phi = \\x c"
    },
    {
      "id": "qml.ops.functions.check_validity",
      "name": "qml.ops.functions.check_validity",
      "type": "function",
      "description": "PennyLane API: ops.functions.check_validity. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "anguage governing permissions and # limitations under the License. \"\"\" This module contains the qml.ops.functions.check_validity function for determining whether or not an Operator class is correctly "
    },
    {
      "id": "qml.pytrees.flatten",
      "name": "qml.pytrees.flatten",
      "type": "function",
      "description": "PennyLane API: pytrees.flatten. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "and differentiated correctly.\"\"\"      if op.num_params == 0:         return      data, struct = qml.pytrees.flatten(op)      def circuit(*args):         qml.apply(qml.pytrees.unflatten(args, struct)) "
    },
    {
      "id": "qml.decomposition.has_decomp",
      "name": "qml.decomposition.has_decomp",
      "type": "function",
      "description": "PennyLane API: decomposition.has_decomp. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "p)     if op_type.resource_params is qml.operation.Operator.resource_params:         assert not qml.decomposition.has_decomp(             op_type         ), \"resource_params must be defined for operat"
    },
    {
      "id": "qml.ops.functions.bind_new_parameters",
      "name": "qml.ops.functions.bind_new_parameters",
      "type": "function",
      "description": "PennyLane API: ops.functions.bind_new_parameters. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "te a new op with different data.\"\"\"     new_data = [d * 0.0 for d in op.data]     new_data_op = qml.ops.functions.bind_new_parameters(op, new_data)     failure_comment = \"bind_new_parameters must be a"
    },
    {
      "id": "qml.typing.TensorLike",
      "name": "qml.typing.TensorLike",
      "type": "function",
      "description": "PennyLane API: typing.TensorLike. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "ld be raised.\"\"\"     if op.has_matrix:         mat = op.matrix()         assert isinstance(mat, qml.typing.TensorLike), \"matrix must be a TensorLike\"         l = 2 ** len(op.wires)         failure_com"
    },
    {
      "id": "qml.operation.GeneratorUndefinedError",
      "name": "qml.operation.GeneratorUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.GeneratorUndefinedError. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "``GeneratorUndefinedError``.\"         )         _assert_error_raised(             op.generator, qml.operation.GeneratorUndefinedError, failure_comment=failure_comment         )()   def _check_copy(op,"
    },
    {
      "id": "qml.operation.Operator.resource_params",
      "name": "qml.operation.Operator.resource_params",
      "type": "function",
      "description": "PennyLane API: operation.Operator.resource_params. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "g the new system of decompositions.\"\"\"     op_type = type(op)     if op_type.resource_params is qml.operation.Operator.resource_params:         assert not qml.decomposition.has_decomp(             op_"
    },
    {
      "id": "qml.operation.MatrixUndefinedError",
      "name": "qml.operation.MatrixUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.MatrixUndefinedError. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "ise a ``MatrixUndefinedError``.\"         )         _assert_error_raised(             op.matrix, qml.operation.MatrixUndefinedError, failure_comment=failure_comment         )()   def _check_sparse_matr"
    },
    {
      "id": "qml.pytrees.unflatten",
      "name": "qml.pytrees.unflatten",
      "type": "function",
      "description": "PennyLane API: pytrees.unflatten. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "  return      data, struct = qml.pytrees.flatten(op)      def circuit(*args):         qml.apply(qml.pytrees.unflatten(args, struct))         return qml.probs(wires=op.wires)      qnode_ref = qml.QNode"
    },
    {
      "id": "qml.operation.DecompositionUndefinedError",
      "name": "qml.operation.DecompositionUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.DecompositionUndefinedError. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "n(                 *op.data, wires=op.wires, **op.hyperparameters             )         except (qml.operation.DecompositionUndefinedError, TypeError):             # sometimes decomposition is defined "
    },
    {
      "id": "qml.transforms.resolve_dynamic_wires",
      "name": "qml.transforms.resolve_dynamic_wires",
      "type": "function",
      "description": "PennyLane API: transforms.resolve_dynamic_wires. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "ule.get_work_wire_spec(**op.resource_params).total     if total_work_wires:         [tape], _ = qml.transforms.resolve_dynamic_wires(             [tape], zeroed=range(len(tape.wires), len(tape.wires) "
    },
    {
      "id": "qml.tape.QuantumTape.from_queue",
      "name": "qml.tape.QuantumTape.from_queue",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape.from_queue. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "ing.AnnotatedQueue() as queued_decomp:             op.decomposition()         processed_queue = qml.tape.QuantumTape.from_queue(queued_decomp)          assert isinstance(decomp, list), \"decomposition "
    },
    {
      "id": "qml.tape.QuantumScript.from_queue",
      "name": "qml.tape.QuantumScript.from_queue",
      "type": "function",
      "description": "PennyLane API: tape.QuantumScript.from_queue. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": ".AnnotatedQueue() as q:         rule(*op.data, wires=op.wires, **op.hyperparameters)     tape = qml.tape.QuantumScript.from_queue(q)      total_work_wires = rule.get_work_wire_spec(**op.resource_param"
    },
    {
      "id": "qml.operation.DiagGatesUndefinedError",
      "name": "qml.operation.DiagGatesUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.DiagGatesUndefinedError. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "s(                 *op.data, wires=op.wires, **op.hyperparameters             )         except (qml.operation.DiagGatesUndefinedError, TypeError):             # sometimes diagonalizing gates is define"
    },
    {
      "id": "qml.capture.disable",
      "name": "qml.capture.disable",
      "type": "function",
      "description": "PennyLane API: capture.disable. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "e the capture module documentation for more information.\"         ) from e     finally:         qml.capture.disable()   def _check_pickle(op):     \"\"\"Check that an operation can be dumped and reloaded"
    },
    {
      "id": "qml.operation.SparseMatrixUndefinedError",
      "name": "qml.operation.SparseMatrixUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.SparseMatrixUndefinedError. Found in assert_valid.html",
      "source_file": "assert_valid.html",
      "context": "atrixUndefinedError``.\"         _assert_error_raised(             op.sparse_matrix,             qml.operation.SparseMatrixUndefinedError,             failure_comment=failure_comment,         )()   def"
    },
    {
      "id": "qml.pauli.pauli_sentence",
      "name": "qml.pauli.pauli_sentence",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_sentence. Found in commutator.html",
      "source_file": "commutator.html",
      "context": " pauli or both_have_pauli_rep:         if not isinstance(op1, PauliSentence):             op1 = qml.pauli.pauli_sentence(op1)         if not isinstance(op2, PauliSentence):             op2 = qml.pauli"
    },
    {
      "id": "qml.math.linalg.eigvalsh",
      "name": "qml.math.linalg.eigvalsh",
      "type": "function",
      "description": "PennyLane API: math.linalg.eigvalsh. Found in eigvals.html",
      "source_file": "eigvals.html",
      "context": "ails. If the requested           :math:`k` is equal or larger than :math:`N - 1`, the regular ``qml.math.linalg.eigvalsh``           is applied on the dense matrix. For more details see the ``scipy.sp"
    },
    {
      "id": "qml.wires.Wires.all_wires",
      "name": "qml.wires.Wires.all_wires",
      "type": "function",
      "description": "PennyLane API: wires.Wires.all_wires. Found in eigvals.html",
      "source_file": "eigvals.html",
      "context": "):         [qs] = res         op_wires = [op.wires for op in qs.operations]         all_wires = qml.wires.Wires.all_wires(op_wires).tolist()         unique_wires = qml.wires.Wires.unique_wires(op_wire"
    },
    {
      "id": "qml.SparseHamiltonian",
      "name": "qml.SparseHamiltonian",
      "type": "class",
      "description": "PennyLane API: SparseHamiltonian. Found in eigvals.html",
      "source_file": "eigvals.html",
      "context": "rLike:     r\"\"\"The eigenvalues of one or more operations.      .. note::          - For a :class:`~.SparseHamiltonian` object, the eigenvalues are computed with the efficient           ``scipy.sparse."
    },
    {
      "id": "qml.math.kron",
      "name": "qml.math.kron",
      "type": "function",
      "description": "PennyLane API: math.kron. Found in eigvals.html",
      "source_file": "eigvals.html",
      "context": " op in qs.operations]          if len(ev) == 1:             return ev[0]          return reduce(qml.math.kron, ev)      return [tape], processing_fn   _modules/pennylane/ops/functions/eigvals         "
    },
    {
      "id": "qml.wires.Wires.unique_wires",
      "name": "qml.wires.Wires.unique_wires",
      "type": "function",
      "description": "PennyLane API: wires.Wires.unique_wires. Found in eigvals.html",
      "source_file": "eigvals.html",
      "context": "ations]         all_wires = qml.wires.Wires.all_wires(op_wires).tolist()         unique_wires = qml.wires.Wires.unique_wires(op_wires).tolist()          if len(all_wires) != len(unique_wires):        "
    },
    {
      "id": "qml.operation.EigvalsUndefinedError",
      "name": "qml.operation.EigvalsUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.EigvalsUndefinedError. Found in eigvals.html",
      "source_file": "eigvals.html",
      "context": " take a `wire_order` argument to mimic `matrix`     try:         return op.eigvals()     except qml.operation.EigvalsUndefinedError:         return eigvals(qml.tape.QuantumScript(op.decomposition()), "
    },
    {
      "id": "qml.HilbertSchmidt",
      "name": "qml.HilbertSchmidt",
      "type": "class",
      "description": "PennyLane API: HilbertSchmidt. Found in equal.html",
      "source_file": "equal.html",
      "context": "l_outcomes == op2.all_outcomes   @_equal_dispatch.register def _equal_hilbert_schmidt(     op1: qml.HilbertSchmidt,     op2: qml.HilbertSchmidt,     check_interface=True,     check_trainability=True, "
    },
    {
      "id": "qml.assert_equal",
      "name": "qml.assert_equal",
      "type": "function",
      "description": "PennyLane API: assert_equal. Found in equal.html",
      "source_file": "equal.html",
      "context": "if isinstance(dispatch_result, str):         return False     return dispatch_result     [docs] def assert_equal(     op1: Operator | MeasurementProcess | QuantumScript,     op2: Operator | Measuremen"
    },
    {
      "id": "qml.ops.op_math.Controlled",
      "name": "qml.ops.op_math.Controlled",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Controlled. Found in is_commuting.html",
      "source_file": "is_commuting.html",
      "context": "f op.name in _control_base_map:         return _control_base_map[op.name]     if isinstance(op, qml.ops.op_math.Controlled):         return op.base.name     return op.name   def _check_mat_commutation"
    },
    {
      "id": "qml.is_commuting",
      "name": "qml.is_commuting",
      "type": "function",
      "description": "PennyLane API: is_commuting. Found in is_commuting.html",
      "source_file": "is_commuting.html",
      "context": "                                  pennylane.ops.functions.is_commuting — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.pauli.pauli_arithmetic.PauliSentence",
      "name": "qml.pauli.pauli_arithmetic.PauliSentence",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_arithmetic.PauliSentence. Found in is_commuting.html",
      "source_file": "is_commuting.html",
      "context": "= pauli_word_2.pauli_rep      comm = pr1.commutator(pr2)     comm.simplify()     return comm == qml.pauli.pauli_arithmetic.PauliSentence({})   def _get_target_name(op):     \"\"\"Get the name for the tar"
    },
    {
      "id": "qml.operation.Channel",
      "name": "qml.operation.Channel",
      "type": "function",
      "description": "PennyLane API: operation.Channel. Found in is_commuting.html",
      "source_file": "is_commuting.html",
      "context": "1.name in unsupported_operations or isinstance(         operation1, (qml.operation.CVOperation, qml.operation.Channel)     ):         raise QuantumFunctionError(f\"Operation {operation1.name} not suppo"
    },
    {
      "id": "qml.operation.CVOperation",
      "name": "qml.operation.CVOperation",
      "type": "function",
      "description": "PennyLane API: operation.CVOperation. Found in is_commuting.html",
      "source_file": "is_commuting.html",
      "context": "tatements      if operation1.name in unsupported_operations or isinstance(         operation1, (qml.operation.CVOperation, qml.operation.Channel)     ):         raise QuantumFunctionError(f\"Operation "
    },
    {
      "id": "qml.is_unitary",
      "name": "qml.is_unitary",
      "type": "function",
      "description": "PennyLane API: is_unitary. Found in is_unitary.html",
      "source_file": "is_unitary.html",
      "context": "                                  pennylane.ops.functions.is_unitary — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.iterative_qpe",
      "name": "qml.iterative_qpe",
      "type": "function",
      "description": "PennyLane API: iterative_qpe. Found in iterative_qpe.html",
      "source_file": "iterative_qpe.html",
      "context": "                                  pennylane.ops.functions.iterative_qpe — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.coerce",
      "name": "qml.math.coerce",
      "type": "function",
      "description": "PennyLane API: math.coerce. Found in matrix.html",
      "source_file": "matrix.html",
      "context": "utomatically by ``matmul`` (See e.g. NumPy documentation)             result = qml.math.matmul(*qml.math.coerce([U, result], like=interface), like=interface)          return result      return [tape],"
    },
    {
      "id": "qml.math.matmul",
      "name": "qml.math.matmul",
      "type": "function",
      "description": "PennyLane API: math.matmul. Found in matrix.html",
      "source_file": "matrix.html",
      "context": "ndled correctly automatically by ``matmul`` (See e.g. NumPy documentation)             result = qml.math.matmul(*qml.math.coerce([U, result], like=interface), like=interface)          return result   "
    },
    {
      "id": "qml.matrix.",
      "name": "qml.matrix.",
      "type": "function",
      "description": "PennyLane API: matrix.. Found in matrix.html",
      "source_file": "matrix.html",
      "context": "ation of an operation or quantum circuit.      .. note::         This method always returns a dense matrix. For workflows with sparse objects, consider using :func:`~pennylane.operation.Operator.spars"
    },
    {
      "id": "qml.I.compute_eigvals",
      "name": "qml.I.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: I.compute_eigvals. Found in identity.html",
      "source_file": "identity.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.I.compute_eigvals())         [1. 1.]         \"\"\"         return qml.math.ones(2**n_wires)    [docs] "
    },
    {
      "id": "qml.GlobalPhase.compute_matrix",
      "name": "qml.GlobalPhase.compute_matrix",
      "type": "class",
      "description": "PennyLane API: GlobalPhase.compute_matrix. Found in identity.html",
      "source_file": "identity.html",
      "context": "alPhase.matrix`          Returns:             ndarray: matrix          **Example**          >>> qml.GlobalPhase.compute_matrix(np.pi/4, n_wires=1)         array([[0.70710678-0.70710678j, 0.        +0."
    },
    {
      "id": "qml.GlobalPhase.compute_diagonalizing_gates",
      "name": "qml.GlobalPhase.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: GlobalPhase.compute_diagonalizing_gates. Found in identity.html",
      "source_file": "identity.html",
      "context": "rns:             list[.Operator]: list of diagonalizing gates          **Example**          >>> qml.GlobalPhase.compute_diagonalizing_gates(1.2, wires=[0])         []         \"\"\"         return []    "
    },
    {
      "id": "qml.Identity.compute_diagonalizing_gates",
      "name": "qml.Identity.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: Identity.compute_diagonalizing_gates. Found in identity.html",
      "source_file": "identity.html",
      "context": "rns:             list[.Operator]: list of diagonalizing gates          **Example**          >>> qml.Identity.compute_diagonalizing_gates(wires=[0])         []         \"\"\"         return []    [docs]  "
    },
    {
      "id": "qml.Identity.compute_matrix",
      "name": "qml.Identity.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Identity.compute_matrix. Found in identity.html",
      "source_file": "identity.html",
      "context": "y.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.Identity.compute_matrix())         [[1. 0.]          [0. 1.]]         \"\"\"         return qml.math.ey"
    },
    {
      "id": "qml.Identity.compute_decomposition",
      "name": "qml.Identity.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Identity.compute_decomposition. Found in identity.html",
      "source_file": "identity.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.Identity.compute_decomposition(wires=0)         []          \"\"\"         return []    [docs]     @sta"
    },
    {
      "id": "qml.pauli.PauliWord",
      "name": "qml.pauli.PauliWord",
      "type": "function",
      "description": "PennyLane API: pauli.PauliWord. Found in identity.html",
      "source_file": "identity.html",
      "context": "perparameters = {\"n_wires\": len(self.wires)}         self._pauli_rep = qml.pauli.PauliSentence({qml.pauli.PauliWord({}): 1.0})   [docs]     def label(self, decimals=None, base_label=None, cache=None):"
    },
    {
      "id": "qml.math.ones",
      "name": "qml.math.ones",
      "type": "function",
      "description": "PennyLane API: math.ones. Found in identity.html",
      "source_file": "identity.html",
      "context": "xample**          >>> print(qml.I.compute_eigvals())         [1. 1.]         \"\"\"         return qml.math.ones(2**n_wires)    [docs]     @staticmethod     @lru_cache     def compute_matrix(n_wires=1): "
    },
    {
      "id": "qml.GlobalPhase.compute_decomposition",
      "name": "qml.GlobalPhase.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: GlobalPhase.compute_decomposition. Found in identity.html",
      "source_file": "identity.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.GlobalPhase.compute_decomposition(1.23)         []          \"\"\"         return []    [docs]     def "
    },
    {
      "id": "qml.math.cast_like",
      "name": "qml.math.cast_like",
      "type": "function",
      "description": "PennyLane API: math.cast_like. Found in identity.html",
      "source_file": "identity.html",
      "context": "   ):  # pragma: no cover (TensorFlow tests were disabled during deprecation)             phi = qml.math.cast_like(phi, 1j)         exp = qml.math.exp(-1j * phi)         ones = qml.math.ones(2**n_wire"
    },
    {
      "id": "qml.GlobalPhase.compute_eigvals",
      "name": "qml.GlobalPhase.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: GlobalPhase.compute_eigvals. Found in identity.html",
      "source_file": "identity.html",
      "context": "ase.eigvals`          Returns:             array: eigenvalues          **Example**          >>> qml.GlobalPhase.compute_eigvals(np.pi/2)         array([6.123234e-17-1.j, 6.123234e-17-1.j])         \"\"\""
    },
    {
      "id": "qml.WireCut.compute_decomposition",
      "name": "qml.WireCut.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: WireCut.compute_decomposition. Found in meta.html",
      "source_file": "meta.html",
      "context": "         list[Operator]: decomposition of the operator          **Example:**          >>> print(qml.WireCut.compute_decomposition(0))         []          \"\"\"         return []    [docs]     def label("
    },
    {
      "id": "qml.Barrier.compute_decomposition",
      "name": "qml.Barrier.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Barrier.compute_decomposition. Found in meta.html",
      "source_file": "meta.html",
      "context": "turns:             list: decomposition of the operator          **Example:**          >>> print(qml.Barrier.compute_decomposition(0))         []          \"\"\"         return []    [docs]     def label("
    },
    {
      "id": "qml.queuing.QueuingManager.remove",
      "name": "qml.queuing.QueuingManager.remove",
      "type": "function",
      "description": "PennyLane API: queuing.QueuingManager.remove. Found in meta.html",
      "source_file": "meta.html",
      "context": "with state         if isinstance(measurement, qml.measurements.MeasurementProcess):             qml.queuing.QueuingManager.remove(measurement)         else:             raise ValueError(              "
    },
    {
      "id": "qml.measurements.Shots",
      "name": "qml.measurements.Shots",
      "type": "function",
      "description": "PennyLane API: measurements.Shots. Found in meta.html",
      "source_file": "meta.html",
      "context": "urement         self.hyperparameters[\"shots\"] = (             shots if shots == \"workflow\" else qml.measurements.Shots(shots)         )         super().__init__(wires=measurement.wires)      def __rep"
    },
    {
      "id": "qml.cut_circuit",
      "name": "qml.cut_circuit",
      "type": "function",
      "description": "PennyLane API: cut_circuit. Found in meta.html",
      "source_file": "meta.html",
      "context": "ation is designed for use as part of the circuit cutting workflow.         Check out the :func:`qml.cut_circuit() <pennylane.cut_circuit>` transform for more details.      **Details:**      * Number o"
    },
    {
      "id": "qml.pauli_measure",
      "name": "qml.pauli_measure",
      "type": "function",
      "description": "PennyLane API: pauli_measure. Found in pauli_measure.html",
      "source_file": "pauli_measure.html",
      "context": "                                  pennylane.ops.mid_measure.pauli_measure — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.specs",
      "name": "qml.specs",
      "type": "function",
      "description": "PennyLane API: specs. Found in pauli_measure.html",
      "source_file": "pauli_measure.html",
      "context": "      Additionally, the number of PPM operations in a circuit can be easily inspected with :func:`~.specs`     where they are denoted as a :class:`~.ops.mid_measure.pauli_measure.PauliMeasure` gate ty"
    },
    {
      "id": "qml.SX",
      "name": "qml.SX",
      "type": "class",
      "description": "PennyLane API: SX. Found in adjoint.html",
      "source_file": "adjoint.html",
      "context": "code-block:: python          def my_ops(a, wire):             qml.RX(a, wires=wire)             qml.SX(wire)          dev = qml.device('default.qubit', wires=1)          @qml.qnode(dev)         def ci"
    },
    {
      "id": "qml.tape.make_qscript",
      "name": "qml.tape.make_qscript",
      "type": "function",
      "description": "PennyLane API: tape.make_qscript. Found in adjoint.html",
      "source_file": "adjoint.html",
      "context": "n capture is not enabled.     @wraps(qfunc)     def wrapper(*args, **kwargs):         qscript = qml.tape.make_qscript(qfunc)(*args, **kwargs)          leaves, _ = qml.pytrees.flatten((args, kwargs), l"
    },
    {
      "id": "qml.math.conjugate",
      "name": "qml.math.conjugate",
      "type": "function",
      "description": "PennyLane API: math.conjugate. Found in adjoint.html",
      "source_file": "adjoint.html",
      "context": "})\"         super().__init__(base, id=id)         if self.base.pauli_rep:             pr = {pw: qml.math.conjugate(coeff) for pw, coeff in self.base.pauli_rep.items()}             self._pauli_rep = qm"
    },
    {
      "id": "qml.QueuingManager.remove",
      "name": "qml.QueuingManager.remove",
      "type": "class",
      "description": "PennyLane API: QueuingManager.remove. Found in adjoint.html",
      "source_file": "adjoint.html",
      "context": "es, _ = qml.pytrees.flatten((args, kwargs), lambda obj: isinstance(obj, Operator))         _ = [qml.QueuingManager.remove(l) for l in leaves if isinstance(l, Operator)]          if lazy:             a"
    },
    {
      "id": "qml.PhaseAdder",
      "name": "qml.PhaseAdder",
      "type": "class",
      "description": "PennyLane API: PhaseAdder. Found in change_op_basis.html",
      "source_file": "change_op_basis.html",
      "context": "ompute, uncompute pattern is composed of     a Quantum Fourier Transform (``QFT``), followed by a ``PhaseAdder``, and finally an inverse ``QFT``.      .. code-block:: python          import pennylane "
    },
    {
      "id": "qml.ops.PauliMeasure",
      "name": "qml.ops.PauliMeasure",
      "type": "function",
      "description": "PennyLane API: ops.PauliMeasure. Found in composite.html",
      "source_file": "composite.html",
      "context": "        self._name = self.__class__.__name__         if any(isinstance(op, (qml.ops.MidMeasure, qml.ops.PauliMeasure)) for op in operands):             raise ValueError(\"Composite operators of mid-cir"
    },
    {
      "id": "qml.capture.register_custom_staging_rule",
      "name": "qml.capture.register_custom_staging_rule",
      "type": "function",
      "description": "PennyLane API: capture.register_custom_staging_rule. Found in condition.html",
      "source_file": "condition.html",
      "context": "tive(\"cond\")     cond_prim.multiple_results = True     cond_prim.prim_type = \"higher_order\"     qml.capture.register_custom_staging_rule(         cond_prim, lambda params: params[\"jaxpr_branches\"][0]."
    },
    {
      "id": "qml.capture.FlatFn",
      "name": "qml.capture.FlatFn",
      "type": "function",
      "description": "PennyLane API: capture.FlatFn. Found in condition.html",
      "source_file": "condition.html",
      "context": "mic_shapes\", True)  # doctest: +SKIP     >>> jax.config.update(\"jax_enable_x64\", True)     >>> @qml.capture.FlatFn     ... def f(x):     ...     return x + 1     >>> jax.make_jaxpr(f, abstracted_axes="
    },
    {
      "id": "qml.capture.disabled",
      "name": "qml.capture.disabled",
      "type": "function",
      "description": "PennyLane API: capture.disabled. Found in condition.html",
      "source_file": "condition.html",
      "context": "nalTransformError(             \"'elif' branches are not supported when not using @qjit and with qml.capture.disabled()\\n\"             \"if the conditional includes mid-circuit measurements.\"         ) "
    },
    {
      "id": "qml.measurements.get_mcm_predicates",
      "name": "qml.measurements.get_mcm_predicates",
      "type": "function",
      "description": "PennyLane API: measurements.get_mcm_predicates. Found in condition.html",
      "source_file": "condition.html",
      "context": "     \"and other classical conditions as predicates.\"                 )             conditions = qml.measurements.get_mcm_predicates(mcm_conditions)          for pred, jaxpr, const_slice in zip(conditi"
    },
    {
      "id": "qml.ops.MeasurementValue",
      "name": "qml.ops.MeasurementValue",
      "type": "function",
      "description": "PennyLane API: ops.MeasurementValue. Found in condition.html",
      "source_file": "condition.html",
      "context": "hen the QNode     will apply the :func:`defer_measurements` transform.      Args:         expr (qml.ops.MeasurementValue): the measurement outcome value to consider         then_op (Operation): the Pe"
    },
    {
      "id": "qml.QueuingManager.append",
      "name": "qml.QueuingManager.append",
      "type": "class",
      "description": "PennyLane API: QueuingManager.append. Found in controlled.html",
      "source_file": "controlled.html",
      "context": "   # new barrier should exist after the X             qml.QueuingManager.remove(op)             qml.QueuingManager.append(op)  # requeue in proper place         return op      if isinstance(op, qml.Qu"
    },
    {
      "id": "qml.Barrier",
      "name": "qml.Barrier",
      "type": "class",
      "description": "PennyLane API: Barrier. Found in controlled.html",
      "source_file": "controlled.html",
      "context": "eturn ops_with_custom_ctrl_ops[custom_key](*op.data, control + op.wires)      if isinstance(op, qml.Barrier):         if qml.QueuingManager.recording():             # for example             # op = Ba"
    },
    {
      "id": "qml.MultiControlledX.compute_decomposition",
      "name": "qml.MultiControlledX.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: MultiControlledX.compute_decomposition. Found in controlled.html",
      "source_file": "controlled.html",
      "context": "ntrol_wires) == 1:         return qml.Toffoli.compute_decomposition(wires=op.wires)      return qml.MultiControlledX.compute_decomposition(         wires=op.wires,         work_wires=op.work_wires,   "
    },
    {
      "id": "qml.Toffoli.compute_decomposition",
      "name": "qml.Toffoli.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Toffoli.compute_decomposition. Found in controlled.html",
      "source_file": "controlled.html",
      "context": ".wires)]      if isinstance(op.base, qml.PauliX) and len(op.control_wires) == 2:         return qml.Toffoli.compute_decomposition(wires=op.wires)      if isinstance(op.base, qml.CNOT) and len(op.contr"
    },
    {
      "id": "qml.CRY.compute_matrix",
      "name": "qml.CRY.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CRY.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.CRY.compute_matrix(torch.tensor(0.5))         tensor([[ 1.0000+0.j,  0.0000+0.j,  0.0000+0.j,  0.000"
    },
    {
      "id": "qml.ControlledPhaseShift.compute_eigvals",
      "name": "qml.ControlledPhaseShift.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: ControlledPhaseShift.compute_eigvals. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": " shift          Returns:             tensor_like: eigenvalues          **Example**          >>> qml.ControlledPhaseShift.compute_eigvals(torch.tensor(0.5))         tensor([1.0000+0.0000j, 1.0000+0.000"
    },
    {
      "id": "qml.CCZ.compute_decomposition",
      "name": "qml.CCZ.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CCZ.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CCZ.compute_decomposition((0,1,2))         [CNOT(wires=[1, 2]),          Adjoint(T(2)),          CNO"
    },
    {
      "id": "qml.CRY.compute_decomposition",
      "name": "qml.CRY.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CRY.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CRY.compute_decomposition(1.2, wires=(0,1))         [RY(0.6, wires=[1]),         CNOT(wires=[0, 1]),"
    },
    {
      "id": "qml.CCZ.compute_matrix",
      "name": "qml.CCZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CCZ.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": ".matrix`           Returns:             ndarray: matrix          **Example**          >>> print(qml.CCZ.compute_matrix())         [[ 1  0  0  0  0  0  0  0]         [ 0  1  0  0  0  0  0  0]         ["
    },
    {
      "id": "qml.MultiControlledX.compute_matrix",
      "name": "qml.MultiControlledX.compute_matrix",
      "type": "class",
      "description": "PennyLane API: MultiControlledX.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "Returns:             tensor_like: matrix representation          **Example**          >>> print(qml.MultiControlledX.compute_matrix([0], [1]))         [[1. 0. 0. 0.]          [0. 1. 0. 0.]          [0"
    },
    {
      "id": "qml.math.log2",
      "name": "qml.math.log2",
      "type": "function",
      "description": "PennyLane API: math.log2. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "     work_wires = Wires(() if work_wires is None else work_wires)          num_base_wires = int(qml.math.log2(qml.math.shape(base)[-1]))         target_wires = wires[-num_base_wires:]         control_"
    },
    {
      "id": "qml.CH.compute_matrix",
      "name": "qml.CH.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CH.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": ".matrix`           Returns:             ndarray: matrix          **Example**          >>> print(qml.CH.compute_matrix())         [[ 1.          0.          0.          0.        ]          [ 0.       "
    },
    {
      "id": "qml.math.sqrt",
      "name": "qml.math.sqrt",
      "type": "function",
      "description": "PennyLane API: math.sqrt. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "_worker,     multi_control_decomp_zyz_rule,     single_ctrl_decomp_zyz_rule, )  INV_SQRT2 = 1 / qml.math.sqrt(2)  stack_last = partial(qml.math.stack, axis=-1)    [docs] class ControlledQubitUnitary(C"
    },
    {
      "id": "qml.CRZ.compute_eigvals",
      "name": "qml.CRZ.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: CRZ.compute_eigvals. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": " angle          Returns:             tensor_like: eigenvalues          **Example**          >>> qml.CRZ.compute_eigvals(torch.tensor(0.5))         tensor([1.0000+0.0000j, 1.0000+0.0000j, 0.9689-0.2474"
    },
    {
      "id": "qml.X.compute_matrix",
      "name": "qml.X.compute_matrix",
      "type": "class",
      "description": "PennyLane API: X.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "      tensor_like: matrix representation          **Example**          >>> print(qml.MultiControlledX.compute_matrix([0], [1]))         [[1. 0. 0. 0.]          [0. 1. 0. 0.]          [0. 0. 0. 1.]    "
    },
    {
      "id": "qml.CNOT.compute_matrix",
      "name": "qml.CNOT.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CNOT.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": ".matrix`           Returns:             ndarray: matrix          **Example**          >>> print(qml.CNOT.compute_matrix())         [[1 0 0 0]          [0 1 0 0]          [0 0 0 1]          [0 0 1 0]] "
    },
    {
      "id": "qml.CRot.compute_matrix",
      "name": "qml.CRot.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CRot.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.CRot.compute_matrix(torch.tensor(0.1), torch.tensor(0.2), torch.tensor(0.3))         tensor([[ 1.000"
    },
    {
      "id": "qml.CSWAP.compute_decomposition",
      "name": "qml.CSWAP.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CSWAP.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.CSWAP.compute_decomposition((0,1,2)))         [Toffoli(wires=[0, 2, 1]), Toffoli(wires=[0, 1, 2]), T"
    },
    {
      "id": "qml.CRZ.compute_decomposition",
      "name": "qml.CRZ.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CRZ.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CRZ.compute_decomposition(1.2, wires=(0,1))         [PhaseShift(0.6, wires=[1]),         CNOT(wires="
    },
    {
      "id": "qml.CH.compute_decomposition",
      "name": "qml.CH.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CH.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.CH.compute_decomposition([0, 1]))         [RY(-0.7853981633974483, wires=[1]), CZ(wires=[0, 1]), RY("
    },
    {
      "id": "qml.CSWAP.compute_matrix",
      "name": "qml.CSWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CSWAP.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "P.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.CSWAP.compute_matrix())         [[1 0 0 0 0 0 0 0]          [0 1 0 0 0 0 0 0]          [0 0 1 0 0 0 "
    },
    {
      "id": "qml.CZ.compute_matrix",
      "name": "qml.CZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CZ.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "Z.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.CZ.compute_matrix())         [[ 1  0  0  0]          [ 0  1  0  0]          [ 0  0  1  0]          ["
    },
    {
      "id": "qml.CY.compute_decomposition",
      "name": "qml.CY.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CY.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.CY.compute_decomposition([0, 1]))         [CRY(3.141592653589793, wires=[0, 1])), S(0)]          \"\"\""
    },
    {
      "id": "qml.CRot.compute_decomposition",
      "name": "qml.CRot.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CRot.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CRot.compute_decomposition(1.234, 2.34, 3.45, wires=[0, 1])         [RZ(-1.108, wires=[1]),         "
    },
    {
      "id": "qml.ControlledPhaseShift.compute_decomposition",
      "name": "qml.ControlledPhaseShift.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ControlledPhaseShift.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.ControlledPhaseShift.compute_decomposition(1.234, wires=(0,1))         [PhaseShift(0.617, wires=[0])"
    },
    {
      "id": "qml.DecompositionUndefinedError",
      "name": "qml.DecompositionUndefinedError",
      "type": "class",
      "description": "PennyLane API: DecompositionUndefinedError. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "rs of the operator, as stored in the ``hyperparameters`` attribute          Raises:             qml.DecompositionUndefinedError         \"\"\"         raise qml.operation.DecompositionUndefinedError     "
    },
    {
      "id": "qml.math.ones_like",
      "name": "qml.math.ones_like",
      "type": "function",
      "description": "PennyLane API: math.ones_like. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ity to reals when back propagating         c = (1 + 0j) * c         js = -1j * s         ones = qml.math.ones_like(js)         zeros = qml.math.zeros_like(js)         matrix = [             [ones, zer"
    },
    {
      "id": "qml.CY.compute_matrix",
      "name": "qml.CY.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CY.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": ".matrix`           Returns:             ndarray: matrix          **Example**          >>> print(qml.CY.compute_matrix())         [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]          [ 0.+0.j  1.+0.j  0.+0.j  0"
    },
    {
      "id": "qml.allocation.AllocateState.ZERO",
      "name": "qml.allocation.AllocateState.ZERO",
      "type": "function",
      "description": "PennyLane API: allocation.AllocateState.ZERO. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "ces, work_wires={\"zeroed\": 1}) def _toffoli_elbow(wires: WiresLike, **__):     with allocate(1, qml.allocation.AllocateState.ZERO, restored=True) as work_wires:         qml.change_op_basis(           "
    },
    {
      "id": "qml.CRX.compute_matrix",
      "name": "qml.CRX.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CRX.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.CRX.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j, 0.0000+0.0000"
    },
    {
      "id": "qml.CRX.compute_decomposition",
      "name": "qml.CRX.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CRX.compute_decomposition. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CRX.compute_decomposition(1.2, wires=(0,1))         [RZ(np.float64(1.5707963267948966), wires=[1]), "
    },
    {
      "id": "qml.ControlledPhaseShift.compute_matrix",
      "name": "qml.ControlledPhaseShift.compute_matrix",
      "type": "class",
      "description": "PennyLane API: ControlledPhaseShift.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "t          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.ControlledPhaseShift.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.000"
    },
    {
      "id": "qml.Toffoli.compute_matrix",
      "name": "qml.Toffoli.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Toffoli.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": ".matrix`           Returns:             ndarray: matrix          **Example**          >>> print(qml.Toffoli.compute_matrix())         [[1 0 0 0 0 0 0 0]          [0 1 0 0 0 0 0 0]          [0 0 1 0 0 "
    },
    {
      "id": "qml.CRZ.compute_matrix",
      "name": "qml.CRZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CRZ.compute_matrix. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.CRZ.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j, 0.0000+0.0000"
    },
    {
      "id": "qml.decomposition.adjoint_resource_rep",
      "name": "qml.decomposition.adjoint_resource_rep",
      "type": "function",
      "description": "PennyLane API: decomposition.adjoint_resource_rep. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": "(wires=wires[2]),         ]     def _ccz_resources():     return {         qml.CNOT: 6,         qml.decomposition.adjoint_resource_rep(qml.T, {}): 3,         qml.T: 4,         qml.Hadamard: 2,     }  "
    },
    {
      "id": "qml.Elbow",
      "name": "qml.Elbow",
      "type": "class",
      "description": "PennyLane API: Elbow. Found in controlled_ops.html",
      "source_file": "controlled_ops.html",
      "context": " def _toffoli_elbow_resources():     return {         change_op_basis_resource_rep(             qml.Elbow,             qml.CNOT,         ): 1,     }   @register_resources(_toffoli_elbow_resources, wor"
    },
    {
      "id": "qml.TemporaryAND",
      "name": "qml.TemporaryAND",
      "type": "class",
      "description": "PennyLane API: TemporaryAND. Found in controlled_decompositions.html",
      "source_file": "controlled_decompositions.html",
      "context": "e == \"borrowed\":         return {ops.Toffoli: 4 * (num_control_wires - 2)}     return {         qml.TemporaryAND: num_control_wires - 2,         adjoint_resource_rep(qml.TemporaryAND): num_control_wir"
    },
    {
      "id": "qml.ctrl_decomp_zyz",
      "name": "qml.ctrl_decomp_zyz",
      "type": "function",
      "description": "PennyLane API: ctrl_decomp_zyz. Found in controlled_decompositions.html",
      "source_file": "controlled_decompositions.html",
      "context": "op in q.queue:  # pragma: no cover             queuing.apply(op)      return q.queue     [docs] def ctrl_decomp_zyz(     target_operation: Operator,     control_wires: Wires,     work_wires: Wires | N"
    },
    {
      "id": "qml.ops.ctrl_decomp_zyz",
      "name": "qml.ops.ctrl_decomp_zyz",
      "type": "function",
      "description": "PennyLane API: ops.ctrl_decomp_zyz. Found in controlled_decompositions.html",
      "source_file": "controlled_decompositions.html",
      "context": "  @qml.qnode(dev)         def decomp_circuit(op):             qml.Hadamard(wires=0)             qml.ops.ctrl_decomp_zyz(op, [0])             return qml.probs()      Measurements on both circuits will "
    },
    {
      "id": "qml.ops.rs_decomposition",
      "name": "qml.ops.rs_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.rs_decomposition. Found in ross_selinger.html",
      "source_file": "ross_selinger.html",
      "context": "phi = \\pi/3`:      .. code-block:: python          op  = qml.RZ(np.pi/3, wires=0)         ops = qml.ops.rs_decomposition(op, epsilon=1e-3)          # Get the approximate matrix from the ops         ma"
    },
    {
      "id": "qml.math.mod",
      "name": "qml.math.mod",
      "type": "function",
      "description": "PennyLane API: math.mod. Found in ross_selinger.html",
      "source_file": "ross_selinger.html",
      "context": "(op) for op in new_tape.operations]      interface = qml.math.get_interface(angle)     phase += qml.math.mod(g_phase, 2) * math.pi     if is_qjit:         if not is_jax:             raise ImportError("
    },
    {
      "id": "qml.switch",
      "name": "qml.switch",
      "type": "function",
      "description": "PennyLane API: switch. Found in ross_selinger.html",
      "source_file": "ross_selinger.html",
      "context": "d_fn = cases[0]      # Remaining cases handled as \"elif\"     elifs = cases[1:]      # TODO: use qml.switch once available     return qml.cond(head_cond, head_fn, elifs=elifs)   # pylint: disable=no-va"
    },
    {
      "id": "qml.math.sort",
      "name": "qml.math.sort",
      "type": "function",
      "description": "PennyLane API: math.sort. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "k=10)          prune_ixs = []         for dist, indx in zip(dists, indxs):             eq_idx = qml.math.sort(indx[qml.math.where(dist.round(8) == 0.0)])             prune_ixs.extend(eq_idx[qml.math.a"
    },
    {
      "id": "qml.math.linalg.eig",
      "name": "qml.math.linalg.eig",
      "type": "function",
      "description": "PennyLane API: math.linalg.eig. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "e qml.RY(phi, [0])      # Get the similarity transormation matrices S and S.adjoint().     ud = qml.math.linalg.eig(matrix)[1]     vwd = qml.math.linalg.eig(qml.matrix(v @ w @ v.adjoint() @ w.adjoint("
    },
    {
      "id": "qml.math.arcsin",
      "name": "qml.math.arcsin",
      "type": "function",
      "description": "PennyLane API: math.arcsin. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "hi comes from the Eq. 10 in the Solovay-Kitaev algorithm paper (arXiv:0505030).     phi = 2.0 * qml.math.arcsin(qml.math.sqrt(qml.math.sqrt(0.5 - 0.5 * qml.math.cos(theta / 2))))      # Begin decompos"
    },
    {
      "id": "qml.math.angle",
      "name": "qml.math.angle",
      "type": "function",
      "description": "PennyLane API: math.angle. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": " # We put the phase first in [0, \\pi] and then convert it to [0, \\pi)     gphase = qml.math.mod(qml.math.angle(factor), 2 * math.pi) / 2     rphase = (-1) ** qml.math.isclose(gphase, math.pi)      # G"
    },
    {
      "id": "qml.math.clip",
      "name": "qml.math.clip",
      "type": "function",
      "description": "PennyLane API: math.clip. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "on errors.     quaternion = _quaternion_transform(matrix)     theta, axis = 2 * qml.math.arccos(qml.math.clip(quaternion[0], -1.0, 1.0)), quaternion[1:]      # Early return for the case where matrix i"
    },
    {
      "id": "qml.math.arccos",
      "name": "qml.math.arccos",
      "type": "function",
      "description": "PennyLane API: math.arccos. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "ng point precision errors.     quaternion = _quaternion_transform(matrix)     theta, axis = 2 * qml.math.arccos(qml.math.clip(quaternion[0], -1.0, 1.0)), quaternion[1:]      # Early return for the cas"
    },
    {
      "id": "qml.ops.sk_decomposition",
      "name": "qml.ops.sk_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.sk_decomposition. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "qml.RZ(np.pi/3, wires=0)          # Get the gate decomposition in ['H', 'S', 'T']         ops = qml.ops.sk_decomposition(op, epsilon=1e-3)          # Get the approximate matrix from the ops         ma"
    },
    {
      "id": "qml.ops.op_math.rs_decomposition",
      "name": "qml.ops.op_math.rs_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.op_math.rs_decomposition. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "    \"Solovay-Kitaev decomposition is not supported with QJIT or JAX-JIT. \"                 \"Use qml.ops.op_math.rs_decomposition (Ross-Selinger decomposition) instead.\"             )          # Build "
    },
    {
      "id": "qml.math.norm",
      "name": "qml.math.norm",
      "type": "function",
      "description": "PennyLane API: math.norm. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "|^2),             # which is simply the L2-norm for the first row of the matrix.             if qml.math.norm(gate_mat[0] - u_prime[0]) <= epsilon:                 break             # Approximate the "
    },
    {
      "id": "qml.math.linalg.det",
      "name": "qml.math.linalg.det",
      "type": "function",
      "description": "PennyLane API: math.linalg.det. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "ings.catch_warnings():         warnings.simplefilter(\"ignore\", RuntimeWarning)         factor = qml.math.linalg.det(matrix)      # We put the phase first in [0, \\pi] and then convert it to [0, \\pi)   "
    },
    {
      "id": "qml.math.argsort",
      "name": "qml.math.argsort",
      "type": "function",
      "description": "PennyLane API: math.argsort. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": "= qml.math.sort(indx[qml.math.where(dist.round(8) == 0.0)])             prune_ixs.extend(eq_idx[qml.math.argsort(tsum[eq_idx])][1:])          for ix in sorted(set(prune_ixs), reverse=True):           "
    },
    {
      "id": "qml.math.unwrap",
      "name": "qml.math.unwrap",
      "type": "function",
      "description": "PennyLane API: math.unwrap. Found in solovay_kitaev.html",
      "source_file": "solovay_kitaev.html",
      "context": " interface = qml.math.get_deep_interface(op_matrix)         gate_mat, gate_gph = _SU2_transform(qml.math.unwrap(op_matrix))         gate_qat = _quaternion_transform(gate_mat)          def _solovay_kit"
    },
    {
      "id": "qml.ops.multi_qubit_decomposition",
      "name": "qml.ops.multi_qubit_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.multi_qubit_decomposition. Found in unitary_decompositions.html",
      "source_file": "unitary_decompositions.html",
      "context": " code-block:: pycon          >>> matrix_target = qml.matrix(qml.QFT([0,1,2]))         >>> ops = qml.ops.multi_qubit_decomposition(matrix_target, [0,1,2])         >>> matrix_decomposition = qml.matrix("
    },
    {
      "id": "qml.ops.two_qubit_decomposition",
      "name": "qml.ops.two_qubit_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.two_qubit_decomposition. Found in unitary_decompositions.html",
      "source_file": "unitary_decompositions.html",
      "context": "   We can compute its decompositon like so:      >>> from pprint import pprint     >>> decomp = qml.ops.two_qubit_decomposition(np.array(U), wires=[0, 1])     >>> pprint(decomp) # doctest: +SKIP     ["
    },
    {
      "id": "qml.ops.one_qubit_decomposition",
      "name": "qml.ops.one_qubit_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.one_qubit_decomposition. Found in unitary_decompositions.html",
      "source_file": "unitary_decompositions.html",
      "context": "import pprint     >>> U = np.array([[1, 1], [1, -1]]) / np.sqrt(2)  # Hadamard     >>> decomp = qml.ops.one_qubit_decomposition(U, 0, rotations='ZYZ', return_global_phase=True)     >>> pprint(decomp) "
    },
    {
      "id": "qml.ops.op_math.Evolution",
      "name": "qml.ops.op_math.Evolution",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Evolution. Found in evolution.html",
      "source_file": "evolution.html",
      "context": "       U(\\phi) = e^{-i\\phi (0.5 Y + Z\\otimes X)}          we get the generator          >>> U = qml.ops.op_math.Evolution(0.5 * qml.Y(0) + qml.Z(0) @ qml.X(1), 1)         >>> print(U)         Evolutio"
    },
    {
      "id": "qml.ops.Evolution",
      "name": "qml.ops.Evolution",
      "type": "function",
      "description": "PennyLane API: ops.Evolution. Found in evolution.html",
      "source_file": "evolution.html",
      "context": ".      >>> @qml.qnode(qml.device('default.qubit', wires=1))     ... def circuit(x):     ...     qml.ops.Evolution(qml.X(0), 0.5 * x)     ...     return qml.expval(qml.Z(0))     >>> print(qml.draw(circ"
    },
    {
      "id": "qml.ops.op_math.SProd",
      "name": "qml.ops.op_math.SProd",
      "type": "function",
      "description": "PennyLane API: ops.op_math.SProd. Found in evolution.html",
      "source_file": "evolution.html",
      "context": "    def simplify(self):         new_base = self.base.simplify()         if isinstance(new_base, qml.ops.op_math.SProd):             return Evolution(new_base.base, self.param * new_base.scalar)       "
    },
    {
      "id": "qml.IsingXY",
      "name": "qml.IsingXY",
      "type": "class",
      "description": "PennyLane API: IsingXY. Found in exp.html",
      "source_file": "exp.html",
      "context": " @ qml.Y(1)     >>> isingxy = qml.exp(t, 0.25j * x)     >>> qml.math.allclose(isingxy.matrix(), qml.IsingXY(x, wires=(0,1)).matrix())     True      If the coefficient is purely imaginary and the base "
    },
    {
      "id": "qml.PCPhase",
      "name": "qml.PCPhase",
      "type": "class",
      "description": "PennyLane API: PCPhase. Found in exp.html",
      "source_file": "exp.html",
      "context": "_:         op_class = getattr(qml.ops.qubit, op_name)         if op_class not in {qml.PauliRot, qml.PCPhase} and op_class.has_generator:             if op_class.num_wires == num_wires:                "
    },
    {
      "id": "qml.ops.SProd",
      "name": "qml.ops.SProd",
      "type": "function",
      "description": "PennyLane API: ops.SProd. Found in exp.html",
      "source_file": "exp.html",
      "context": ".stop_recording():         base = base.simplify()     coeff = params[0]     if isinstance(base, qml.ops.SProd):         coeff, base = params[0] * base.scalar, base.base     coeff = 2j * coeff  # The 2"
    },
    {
      "id": "qml.ops.qubit.__all__",
      "name": "qml.ops.qubit.__all__",
      "type": "function",
      "description": "PennyLane API: ops.qubit.__all__. Found in exp.html",
      "source_file": "exp.html",
      "context": "lasses with generators     has_generator_types = []     any_wires_types = []     for op_name in qml.ops.qubit.__all__:         op_class = getattr(qml.ops.qubit, op_name)         if op_class not in {qm"
    },
    {
      "id": "qml.ops.qubit",
      "name": "qml.ops.qubit",
      "type": "function",
      "description": "PennyLane API: ops.qubit. Found in exp.html",
      "source_file": "exp.html",
      "context": "lasses with generators     has_generator_types = []     any_wires_types = []     for op_name in qml.ops.qubit.__all__:         op_class = getattr(qml.ops.qubit, op_name)         if op_class not in {qm"
    },
    {
      "id": "qml.pauli.pauli_word_to_string",
      "name": "qml.pauli.pauli_word_to_string",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_word_to_string. Found in exp.html",
      "source_file": "exp.html",
      "context": "lse math.real_if_close(2j * coeff)  # only cast to real if close         )         pauli_word = qml.pauli.pauli_word_to_string(base)         return [qml.PauliRot(theta=coeff, pauli_word=pauli_word, wi"
    },
    {
      "id": "qml.math.expand_vector",
      "name": "qml.math.expand_vector",
      "type": "function",
      "description": "PennyLane API: math.expand_vector. Found in linear_combination.html",
      "source_file": "linear_combination.html",
      "context": "rlapping_ops:             if len(ops) == 1:                 eigvals.append(                     qml.math.expand_vector(ops[0].eigvals(), list(ops[0].wires), list(self.wires))                 )        "
    },
    {
      "id": "qml.math.concatenate",
      "name": "qml.math.concatenate",
      "type": "function",
      "description": "PennyLane API: math.concatenate. Found in linear_combination.html",
      "source_file": "linear_combination.html",
      "context": "= 0:             return self          if isinstance(H, LinearCombination):             coeffs = qml.math.concatenate([self_coeffs, H.coeffs], axis=0)             ops.extend(H.ops)             if (pr1 "
    },
    {
      "id": "qml.queuing.QueuingManager.recording",
      "name": "qml.queuing.QueuingManager.recording",
      "type": "function",
      "description": "PennyLane API: queuing.QueuingManager.recording. Found in prod.html",
      "source_file": "prod.html",
      "context": "` is applied to the state before :math:`\\hat{A}` in the quantum circuit.         \"\"\"         if qml.queuing.QueuingManager.recording():             return [qml.apply(op) for op in self[::-1]]         "
    },
    {
      "id": "qml.ops.Prod",
      "name": "qml.ops.Prod",
      "type": "function",
      "description": "PennyLane API: ops.Prod. Found in prod.html",
      "source_file": "prod.html",
      "context": "t the :meth:`~Prod.terms` method always simplifies and flattens the operands.          >>> op = qml.ops.Prod(qml.X(0), qml.sum(qml.Y(0), qml.Z(1)))         >>> op.terms()         ([1j, 1.0], [Z(0), X("
    },
    {
      "id": "qml.ops.CompositeOp",
      "name": "qml.ops.CompositeOp",
      "type": "function",
      "description": "PennyLane API: ops.CompositeOp. Found in sprod.html",
      "source_file": "sprod.html",
      "context": "r__(self):         \"\"\"Constructor-call-like representation.\"\"\"         if isinstance(self.base, qml.ops.CompositeOp):             return f\"{self.scalar} * ({self.base})\"         return f\"{self.scalar}"
    },
    {
      "id": "qml.math.size",
      "name": "qml.math.size",
      "type": "function",
      "description": "PennyLane API: math.size. Found in symbolicop.html",
      "source_file": "symbolicop.html",
      "context": "e_batch_size             else:                 # coeff is batched                 scalar_size = qml.math.size(self.scalar)                 if base_batch_size is not None and base_batch_size != scalar_"
    },
    {
      "id": "qml.QubitSum",
      "name": "qml.QubitSum",
      "type": "class",
      "description": "PennyLane API: QubitSum. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "es[0], wires[2], wires[3]])   add_decomps(QubitCarry, _qubitcarry_to_cnot_toffolis)    [docs] class QubitSum(Operation):     r\"\"\"QubitSum(wires)     Apply a ``QubitSum`` operation on three input wires"
    },
    {
      "id": "qml.QubitCarry",
      "name": "qml.QubitCarry",
      "type": "class",
      "description": "PennyLane API: QubitCarry. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "rom pennylane.typing import TensorLike from pennylane.wires import Wires, WiresLike    [docs] class QubitCarry(Operation):     r\"\"\"QubitCarry(wires)     Apply the ``QubitCarry`` operation to four inpu"
    },
    {
      "id": "qml.IntegerComparator.compute_decomposition",
      "name": "qml.IntegerComparator.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: IntegerComparator.compute_decomposition. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "r]: decomposition into lower level operations          **Example:**          >>> print(qml.draw(qml.IntegerComparator.compute_decomposition)(4, wires=[0, 1, 2, 3]))         0: ─╭●────╭●────╭●────┤    "
    },
    {
      "id": "qml.QubitSum.compute_matrix",
      "name": "qml.QubitSum.compute_matrix",
      "type": "class",
      "description": "PennyLane API: QubitSum.compute_matrix. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "m.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.QubitSum.compute_matrix())         [[1 0 0 0 0 0 0 0]          [0 1 0 0 0 0 0 0]          [0 0 0 1 0"
    },
    {
      "id": "qml.QubitCarry.compute_matrix",
      "name": "qml.QubitCarry.compute_matrix",
      "type": "class",
      "description": "PennyLane API: QubitCarry.compute_matrix. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "y.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.QubitCarry.compute_matrix())         [[1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]          [0 1 0 0 0 0 0 0 0 "
    },
    {
      "id": "qml.IntegerComparator",
      "name": "qml.IntegerComparator",
      "type": "class",
      "description": "PennyLane API: IntegerComparator. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "mps(\"Adjoint(QubitSum)\", self_adjoint) add_decomps(\"Pow(QubitSum)\", pow_involutory)    [docs] class IntegerComparator(Operation):     r\"\"\"IntegerComparator(value, geq, wires)     Apply a controlled Pa"
    },
    {
      "id": "qml.QubitSum.compute_decomposition",
      "name": "qml.QubitSum.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QubitSum.compute_decomposition. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "s:             list[Operator]: decomposition of the operator          **Example:**          >>> qml.QubitSum.compute_decomposition((0,1,2))         [CNOT(wires=[1, 2]), CNOT(wires=[0, 2])]          \"\""
    },
    {
      "id": "qml.IntegerComparator.compute_matrix",
      "name": "qml.IntegerComparator.compute_matrix",
      "type": "class",
      "description": "PennyLane API: IntegerComparator.compute_matrix. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": " Returns:            tensor_like: matrix representation          **Example**          >>> print(qml.IntegerComparator.compute_matrix(control_wires=[0, 1], value=2))         [[1. 0. 0. 0. 0. 0. 0. 0.] "
    },
    {
      "id": "qml.QubitCarry.compute_decomposition",
      "name": "qml.QubitCarry.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QubitCarry.compute_decomposition. Found in arithmetic_ops.html",
      "source_file": "arithmetic_ops.html",
      "context": "s:             list[Operator]: decomposition of the operator          **Example:**          >>> qml.QubitCarry.compute_decomposition((0,1,2,4))         [Toffoli(wires=[1, 2, 4]), CNOT(wires=[1, 2]), T"
    },
    {
      "id": "qml.DiagonalQubitUnitary.compute_decomposition",
      "name": "qml.DiagonalQubitUnitary.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: DiagonalQubitUnitary.compute_decomposition. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "       **Example:**          >>> diag = np.exp(1j * np.array([0.4, 2.1, 0.5, 1.8]))         >>> qml.DiagonalQubitUnitary.compute_decomposition(diag, wires=[0, 1])         [DiagonalQubitUnitary(array(["
    },
    {
      "id": "qml.DiagonalQubitUnitary.compute_matrix",
      "name": "qml.DiagonalQubitUnitary.compute_matrix",
      "type": "class",
      "description": "PennyLane API: DiagonalQubitUnitary.compute_matrix. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "x          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.DiagonalQubitUnitary.compute_matrix(torch.tensor([1, -1]))         tensor([[ 1,  0],                "
    },
    {
      "id": "qml.ops.op_math.decompositions.multi_qubit_decomposition",
      "name": "qml.ops.op_math.decompositions.multi_qubit_decomposition",
      "type": "function",
      "description": "PennyLane API: ops.op_math.decompositions.multi_qubit_decomposition. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "         )              return qml.ops.two_qubit_decomposition(U, Wires(wires))          return qml.ops.op_math.decompositions.multi_qubit_decomposition(U, Wires(wires))       # pylint: disable=argume"
    },
    {
      "id": "qml.DiagonalQubitUnitary.compute_eigvals",
      "name": "qml.DiagonalQubitUnitary.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: DiagonalQubitUnitary.compute_eigvals. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "matrix          Returns:             tensor_like: eigenvalues          **Example**          >>> qml.DiagonalQubitUnitary.compute_eigvals(torch.tensor([1, -1]))         tensor([ 1, -1])         \"\"\"    "
    },
    {
      "id": "qml.BlockEncode.compute_matrix",
      "name": "qml.BlockEncode.compute_matrix",
      "type": "class",
      "description": "PennyLane API: BlockEncode.compute_matrix. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": ",0.2],[0.3,0.4]])         >>> A         array([[0.1, 0.2],             [0.3, 0.4]])         >>> qml.BlockEncode.compute_matrix(A, subspace=[2,2,4])         array([[ 0.1       ,  0.2       ,  0.9728378"
    },
    {
      "id": "qml.QubitUnitary.compute_matrix",
      "name": "qml.QubitUnitary.compute_matrix",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.compute_matrix. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": " U = np.array([[0.98877108+0.j, 0.-0.14943813j], [0.-0.14943813j, 0.98877108+0.j]])         >>> qml.QubitUnitary.compute_matrix(U)          array([[0.988...+0.j        , 0.        -0.149...j],        "
    },
    {
      "id": "qml.QubitUnitary.compute_decomposition",
      "name": "qml.QubitUnitary.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.compute_decomposition. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "**Example:**          >>> U = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]])         >>> decomp = qml.QubitUnitary.compute_decomposition(U, 0)         >>> from pprint import pprint         >>> pprint(de"
    },
    {
      "id": "qml.math.maximum",
      "name": "qml.math.maximum",
      "type": "function",
      "description": "PennyLane API: math.maximum. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "eshape(A, [1, len(A)])                 shape_a = qml.math.shape(A)              normalization = qml.math.maximum(                 math.norm(A @ qml.math.transpose(qml.math.conj(A)), ord=pnp.inf),     "
    },
    {
      "id": "qml.BlockEncode",
      "name": "qml.BlockEncode",
      "type": "class",
      "description": "PennyLane API: BlockEncode. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "* z, wires=wires)   add_decomps(\"Pow(DiagonalQubitUnitary)\", _pow_diagonal_unitary)    [docs] class BlockEncode(Operation):     r\"\"\"BlockEncode(A, wires)     Construct a unitary :math:`U(A)` such that"
    },
    {
      "id": "qml.math.concat",
      "name": "qml.math.concat",
      "type": "function",
      "description": "PennyLane API: math.concat. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "low tests were disabled during deprecation)             axis = 1 if h else 0             return qml.math.concat(lst, like=like, axis=axis)         return qml.math.hstack(lst) if h else qml.math.vstack"
    },
    {
      "id": "qml.QubitUnitary.compute_sparse_matrix",
      "name": "qml.QubitUnitary.compute_sparse_matrix",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.compute_sparse_matrix. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "eserve the sparsity of the matrix,         including :func:`~.adjoint`, :func:`~.pow`, and :meth:`~.QubitUnitary.compute_sparse_matrix`.         Differentiability is not supported for sparse matrices."
    },
    {
      "id": "qml.math.vstack",
      "name": "qml.math.vstack",
      "type": "function",
      "description": "PennyLane API: math.vstack. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "return qml.math.concat(lst, like=like, axis=axis)         return qml.math.hstack(lst) if h else qml.math.vstack(lst)      interface = qml.math.get_interface(A)      if qml.math.sum(shape_a) <= 2:     "
    },
    {
      "id": "qml.math.linalg.matrix_power",
      "name": "qml.math.linalg.matrix_power",
      "type": "function",
      "description": "PennyLane API: math.linalg.matrix_power. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": " isinstance(z, int) and qml.math.get_deep_interface(mat) != \"tensorflow\":             pow_mat = qml.math.linalg.matrix_power(mat, z)         elif self.batch_size is not None or qml.math.shape(z) != ()"
    },
    {
      "id": "qml.DiagonalQubitUnitary",
      "name": "qml.DiagonalQubitUnitary",
      "type": "class",
      "description": "PennyLane API: DiagonalQubitUnitary. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "e=work_wire_type,     )   add_decomps(\"C(QubitUnitary)\", _controlled_qubit_unitary)    [docs] class DiagonalQubitUnitary(Operation):     r\"\"\"DiagonalQubitUnitary(D, wires)     Apply an arbitrary diago"
    },
    {
      "id": "qml.S.compute_matrix",
      "name": "qml.S.compute_matrix",
      "type": "class",
      "description": "PennyLane API: S.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "S.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.S.compute_matrix())         [[1.+0.j 0.+0.j]          [0.+0.j 0.+1.j]]         \"\"\"         return np"
    },
    {
      "id": "qml.Y.compute_eigvals",
      "name": "qml.Y.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: Y.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.Y.compute_eigvals())         [ 1. -1.]         \"\"\"         return qml.pauli.pauli_eigs(1)    [docs] "
    },
    {
      "id": "qml.ECR.compute_decomposition",
      "name": "qml.ECR.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ECR.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "evel operations          **Example:**          >>> from pprint import pprint         >>> pprint(qml.ECR.compute_decomposition((0,1)))         [Z(0),         CNOT(wires=[0, 1]),         SX(1),         "
    },
    {
      "id": "qml.X.compute_decomposition",
      "name": "qml.X.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: X.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.X.compute_decomposition(0))         [RX(3.141592653589793, wires=[0]),         GlobalPhase(-1.570796"
    },
    {
      "id": "qml.ISWAP.compute_decomposition",
      "name": "qml.ISWAP.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ISWAP.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.ISWAP.compute_decomposition((0,1)))         [S(0),         S(1),         H(0),         CNOT(wires=[0"
    },
    {
      "id": "qml.SISWAP",
      "name": "qml.SISWAP",
      "type": "class",
      "description": "PennyLane API: SISWAP. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "peration.Operator]:         z_mod4 = z % 4         if abs(z_mod4 - 0.5) < 1e-6:             return [SISWAP(wires=self.wires)]         if abs(z_mod4 - 2) < 1e-6:             return [qml.Z(wires=self.wi"
    },
    {
      "id": "qml.Hadamard.compute_matrix",
      "name": "qml.Hadamard.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Hadamard.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "d.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.Hadamard.compute_matrix())         [[ 0.70710678  0.70710678]          [ 0.70710678 -0.70710678]]   "
    },
    {
      "id": "qml.Y.compute_diagonalizing_gates",
      "name": "qml.Y.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: Y.compute_diagonalizing_gates. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "           list[.Operator]: list of diagonalizing gates          **Example**          >>> print(qml.Y.compute_diagonalizing_gates(wires=[0]))         [Z(0), S(0), H(0)]         \"\"\"         return [   "
    },
    {
      "id": "qml.SWAP.compute_sparse_matrix",
      "name": "qml.SWAP.compute_sparse_matrix",
      "type": "class",
      "description": "PennyLane API: SWAP.compute_sparse_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "atrix`          Returns:             csr_matrix: matrix          **Example**          >>> print(qml.SWAP.compute_sparse_matrix())         <Compressed Sparse Row sparse matrix of dtype 'int64'         "
    },
    {
      "id": "qml.Hadamard.compute_diagonalizing_gates",
      "name": "qml.Hadamard.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: Hadamard.compute_diagonalizing_gates. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "           list[.Operator]: list of diagonalizing gates          **Example**          >>> print(qml.Hadamard.compute_diagonalizing_gates(wires=[0]))         [RY(-0.7853981633974483, wires=[0])]       "
    },
    {
      "id": "qml.T.compute_matrix",
      "name": "qml.T.compute_matrix",
      "type": "class",
      "description": "PennyLane API: T.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "T.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.T.compute_matrix())         [[1.        +0.j         0.        +0.j        ]         [0.        +0.j"
    },
    {
      "id": "qml.ISWAP.compute_matrix",
      "name": "qml.ISWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: ISWAP.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "P.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.ISWAP.compute_matrix())         [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]          [0.+0.j 0.+0.j 0.+1.j 0.+0.j"
    },
    {
      "id": "qml.X.compute_diagonalizing_gates",
      "name": "qml.X.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: X.compute_diagonalizing_gates. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "           list[.Operator]: list of diagonalizing gates          **Example**          >>> print(qml.X.compute_diagonalizing_gates(wires=[0]))         [H(0)]         \"\"\"         return [Hadamard(wires="
    },
    {
      "id": "qml.Z.compute_decomposition",
      "name": "qml.Z.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Z.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.Z.compute_decomposition(0))         [PhaseShift(3.141592653589793, wires=[0])]          \"\"\"         "
    },
    {
      "id": "qml.pauli.pauli_eigs",
      "name": "qml.pauli.pauli_eigs",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_eigs. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "         >>> print(qml.Hadamard.compute_eigvals())         [ 1. -1.]         \"\"\"         return qml.pauli.pauli_eigs(1)    [docs]     @staticmethod     def compute_diagonalizing_gates(wires: WiresLike"
    },
    {
      "id": "qml.SISWAP.compute_matrix",
      "name": "qml.SISWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SISWAP.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": " ndarray: matrix          **Example**          >>> from pprint import pprint         >>> pprint(qml.SISWAP.compute_matrix())         array([[1.        +0.j        , 0.        +0.j        ,            "
    },
    {
      "id": "qml.SWAP.compute_matrix",
      "name": "qml.SWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SWAP.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "P.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.SWAP.compute_matrix())         [[1 0 0 0]          [0 0 1 0]          [0 1 0 0]          [0 0 0 1]] "
    },
    {
      "id": "qml.S.compute_eigvals",
      "name": "qml.S.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: S.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.S.compute_eigvals())         [1.+0.j 0.+1.j]         \"\"\"         return np.array([1, 1j])    [docs] "
    },
    {
      "id": "qml.Z.compute_matrix",
      "name": "qml.Z.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Z.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "Z.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.Z.compute_matrix())         [[ 1  0]          [ 0 -1]]         \"\"\"         return np.array([[1, 0], "
    },
    {
      "id": "qml.Z.compute_diagonalizing_gates",
      "name": "qml.Z.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: Z.compute_diagonalizing_gates. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "           list[.Operator]: list of diagonalizing gates          **Example**          >>> print(qml.Z.compute_diagonalizing_gates(wires=[0]))         []         \"\"\"         return []    [docs]     @st"
    },
    {
      "id": "qml.SQISW",
      "name": "qml.SQISW",
      "type": "class",
      "description": "PennyLane API: SQISW. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "ation):     r\"\"\"SISWAP(wires)     The square root of i-swap operator. Can also be accessed as ``qml.SQISW``      .. math:: SISWAP = \\begin{bmatrix}             1 & 0 & 0 & 0 \\\\             0 & 1/ \\sqr"
    },
    {
      "id": "qml.Hadamard.compute_eigvals",
      "name": "qml.Hadamard.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: Hadamard.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.Hadamard.compute_eigvals())         [ 1. -1.]         \"\"\"         return qml.pauli.pauli_eigs(1)    "
    },
    {
      "id": "qml.T.compute_decomposition",
      "name": "qml.T.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: T.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.T.compute_decomposition(0))         [PhaseShift(0.7853981633974483, wires=[0])]          \"\"\"        "
    },
    {
      "id": "qml.Y.compute_decomposition",
      "name": "qml.Y.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Y.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.Y.compute_decomposition(0))         [RY(3.141592653589793, wires=[0]),         GlobalPhase(-1.570796"
    },
    {
      "id": "qml.SX.compute_matrix",
      "name": "qml.SX.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SX.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "X.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.SX.compute_matrix())         [[0.5+0.5j 0.5-0.5j]          [0.5-0.5j 0.5+0.5j]]         \"\"\"         "
    },
    {
      "id": "qml.X.compute_eigvals",
      "name": "qml.X.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: X.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.X.compute_eigvals())         [ 1. -1.]         \"\"\"         return qml.pauli.pauli_eigs(1)    [docs] "
    },
    {
      "id": "qml.S.compute_decomposition",
      "name": "qml.S.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: S.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.S.compute_decomposition(0))         [PhaseShift(1.5707963267948966, wires=[0])]          \"\"\"        "
    },
    {
      "id": "qml.ECR.compute_matrix",
      "name": "qml.ECR.compute_matrix",
      "type": "class",
      "description": "PennyLane API: ECR.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "ype: tensor_like          **Example**          >>> from pprint import pprint         >>> pprint(qml.ECR.compute_matrix())         array([[ 0.        +0.j        ,  0.        +0.j        ,             "
    },
    {
      "id": "qml.SX.compute_decomposition",
      "name": "qml.SX.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SX.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.SX.compute_decomposition(0))         [RZ(1.5707963267948966, wires=[0]),         RY(1.57079632679489"
    },
    {
      "id": "qml.SISWAP.compute_eigvals",
      "name": "qml.SISWAP.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: SISWAP.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "vals`           Returns:             array: eigenvalues          **Example**          >>> print(qml.SISWAP.compute_eigvals())         [0.70710678+0.70710678j 0.70710678-0.70710678j 1.        +0.j 1.  "
    },
    {
      "id": "qml.SX.compute_eigvals",
      "name": "qml.SX.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: SX.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "vals`           Returns:             array: eigenvalues          **Example**          >>> print(qml.SX.compute_eigvals())         [1.+0.j 0.+1.j]         \"\"\"         return np.array([1, 1j])    [docs]"
    },
    {
      "id": "qml.ECR.compute_eigvals",
      "name": "qml.ECR.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: ECR.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "vals`           Returns:             array: eigenvalues          **Example**          >>> print(qml.ECR.compute_eigvals())         [ 1 -1  1 -1]         \"\"\"          return np.array([1, -1, 1, -1])   "
    },
    {
      "id": "qml.Y.compute_matrix",
      "name": "qml.Y.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Y.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "Y.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.Y.compute_matrix())         [[ 0.+0.j -0.-1.j]          [ 0.+1.j  0.+0.j]]         \"\"\"         retur"
    },
    {
      "id": "qml.SISWAP.compute_decomposition",
      "name": "qml.SISWAP.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SISWAP.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.SISWAP.compute_decomposition((0,1)))         [SX(0),         RZ(1.5707963267948966, wires=[0]),     "
    },
    {
      "id": "qml.Hadamard.compute_decomposition",
      "name": "qml.Hadamard.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Hadamard.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "         list[Operator]: decomposition of the operator          **Example:**          >>> print(qml.Hadamard.compute_decomposition(0))         [PhaseShift(1.5707963267948966, wires=[0]),         RX(1."
    },
    {
      "id": "qml.Z.compute_eigvals",
      "name": "qml.Z.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: Z.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.Z.compute_eigvals())         [ 1. -1.]         \"\"\"         return qml.pauli.pauli_eigs(1)    [docs] "
    },
    {
      "id": "qml.SWAP.compute_decomposition",
      "name": "qml.SWAP.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SWAP.compute_decomposition. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t[Operator]: decomposition into lower level operations          **Example:**          >>> print(qml.SWAP.compute_decomposition((0,1)))         [CNOT(wires=[0, 1]), CNOT(wires=[1, 0]), CNOT(wires=[0, 1"
    },
    {
      "id": "qml.T.compute_eigvals",
      "name": "qml.T.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: T.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.T.compute_eigvals())         [1.        +0.j         0.70710678+0.70710678j]         \"\"\"         ret"
    },
    {
      "id": "qml.ISWAP.compute_eigvals",
      "name": "qml.ISWAP.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: ISWAP.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "vals`           Returns:             array: eigenvalues          **Example**          >>> print(qml.ISWAP.compute_eigvals())         [ 0.+1.j -0.-1.j  1.+0.j  1.+0.j]         \"\"\"         return np.arr"
    },
    {
      "id": "qml.Hermitian.compute_matrix",
      "name": "qml.Hermitian.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Hermitian.compute_matrix. Found in observables.html",
      "source_file": "observables.html",
      "context": "al matrix          **Example**          >>> A = np.array([[6+0j, 1-2j],[1+2j, -1]])         >>> qml.Hermitian.compute_matrix(A)         array([[ 6.+0.j,  1.-2.j],                [ 1.+2.j, -1.+0.j]])  "
    },
    {
      "id": "qml.pauli.conversion.pauli_decompose",
      "name": "qml.pauli.conversion.pauli_decompose",
      "type": "function",
      "description": "PennyLane API: pauli.conversion.pauli_decompose. Found in observables.html",
      "source_file": "observables.html",
      "context": "cient for this large of a matrix.\",                 UserWarning,             )          return [qml.pauli.conversion.pauli_decompose(A, wire_order=wires, pauli=False)]    [docs]     @staticmethod     "
    },
    {
      "id": "qml.Hermitian.compute_decomposition",
      "name": "qml.Hermitian.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Hermitian.compute_decomposition. Found in observables.html",
      "source_file": "observables.html",
      "context": "ml.X(0) + qml.Y(1) + 2 * qml.X(0) @ qml.Z(3)         >>> op_matrix = qml.matrix(op)         >>> qml.Hermitian.compute_decomposition(op_matrix, wires=['a', 'b', 'aux'])         [(               1.0 * ("
    },
    {
      "id": "qml.math.dtype",
      "name": "qml.math.dtype",
      "type": "function",
      "description": "PennyLane API: math.dtype. Found in observables.html",
      "source_file": "observables.html",
      "context": "   wires = Wires(wires)          if qml.math.get_interface(state) == \"jax\":             dtype = qml.math.dtype(state)             if not (np.issubdtype(dtype, np.integer) or np.issubdtype(dtype, bool)"
    },
    {
      "id": "qml.SparseHamiltonian.compute_matrix",
      "name": "qml.SparseHamiltonian.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SparseHamiltonian.compute_matrix. Found in observables.html",
      "source_file": "observables.html",
      "context": "    >>> H = np.array([[6+0j, 1-2j],[1+2j, -1]])         >>> H = csr_matrix(H)         >>> res = qml.SparseHamiltonian.compute_matrix(H)         >>> res         array([[ 6.+0.j,  1.-2.j],              "
    },
    {
      "id": "qml.SparseHamiltonian.compute_sparse_matrix",
      "name": "qml.SparseHamiltonian.compute_sparse_matrix",
      "type": "class",
      "description": "PennyLane API: SparseHamiltonian.compute_sparse_matrix. Found in observables.html",
      "source_file": "observables.html",
      "context": "       This method returns a dense matrix. For a sparse matrix representation, see         :meth:`~.SparseHamiltonian.compute_sparse_matrix`.          Args:             H (scipy.sparse.csr_matrix): sp"
    },
    {
      "id": "qml.math.nonzero",
      "name": "qml.math.nonzero",
      "type": "function",
      "description": "PennyLane API: math.nonzero. Found in observables.html",
      "source_file": "observables.html",
      "context": "parameters[0]         n_wires = int(qml.math.log2(len(state_vector)))         basis_state_idx = qml.math.nonzero(state_vector)[0]          if len(basis_state_idx) == 1:             basis_string = f\"{b"
    },
    {
      "id": "qml.Hermitian.compute_diagonalizing_gates",
      "name": "qml.Hermitian.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: Hermitian.compute_diagonalizing_gates. Found in observables.html",
      "source_file": "observables.html",
      "context": " A = np.array([[-6, 2 + 1j], [2 - 1j, 0]])         >>> _, evecs = np.linalg.eigh(A)         >>> qml.Hermitian.compute_diagonalizing_gates(evecs, wires=[0])         [QubitUnitary(array([[-0.94915323+0."
    },
    {
      "id": "qml.math.to_numpy",
      "name": "qml.math.to_numpy",
      "type": "function",
      "description": "PennyLane API: math.to_numpy. Found in observables.html",
      "source_file": "observables.html",
      "context": "igenvectors of the Hermitian observable         \"\"\"         Hmat = self.matrix()         Hmat = qml.math.to_numpy(Hmat)         Hkey = tuple(Hmat.flatten().tolist())         if Hkey not in Hermitian._"
    },
    {
      "id": "qml.CPhaseShift10.compute_matrix",
      "name": "qml.CPhaseShift10.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CPhaseShift10.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "ft          Returns:             TensorLike: canonical matrix          **Example**          >>> qml.CPhaseShift10.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j, 0.0"
    },
    {
      "id": "qml.IsingZZ.compute_eigvals",
      "name": "qml.IsingZZ.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: IsingZZ.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "e angle          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.IsingZZ.compute_eigvals(torch.tensor(0.5))         tensor([0.9689-0.2474j, 0.9689+0.2474j, 0.9689+0."
    },
    {
      "id": "qml.PauliRot.compute_matrix",
      "name": "qml.PauliRot.compute_matrix",
      "type": "class",
      "description": "PennyLane API: PauliRot.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "rd          Returns:             TensorLike: canonical matrix          **Example**          >>> qml.PauliRot.compute_matrix(0.5, 'X')         array([[0.96891242+0.j        , 0.        -0.24740396j],  "
    },
    {
      "id": "qml.PSWAP.compute_eigvals",
      "name": "qml.PSWAP.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: PSWAP.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "e angle          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.PSWAP.compute_eigvals(0.5)         array([ 1.        +0.j        ,  1.        +0.j        ,         "
    },
    {
      "id": "qml.PauliRot.compute_decomposition",
      "name": "qml.PauliRot.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: PauliRot.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.PauliRot.compute_decomposition(1.2, wires=(0,1), pauli_word=\"XY\")         [H(0), RX(1.57079632679489"
    },
    {
      "id": "qml.CPhaseShift01.compute_decomposition",
      "name": "qml.CPhaseShift01.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CPhaseShift01.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CPhaseShift01.compute_decomposition(1.234, wires=(0,1))         [X(0),         PhaseShift(0.617, wir"
    },
    {
      "id": "qml.IsingZZ.compute_decomposition",
      "name": "qml.IsingZZ.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: IsingZZ.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.IsingZZ.compute_decomposition(1.23, wires=[0, 1])         [CNOT(wires=[0, 1]), RZ(1.23, wires=[1]), "
    },
    {
      "id": "qml.MultiRZ.compute_decomposition",
      "name": "qml.MultiRZ.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: MultiRZ.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.MultiRZ.compute_decomposition(1.2, wires=(0,1))         [CNOT(wires=[1, 0]), RZ(1.2, wires=[0]), CNO"
    },
    {
      "id": "qml.CPhaseShift00.compute_decomposition",
      "name": "qml.CPhaseShift00.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CPhaseShift00.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CPhaseShift00.compute_decomposition(1.234, wires=(0,1))         [X(0),         X(1),         PhaseSh"
    },
    {
      "id": "qml.MultiRZ.compute_matrix",
      "name": "qml.MultiRZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: MultiRZ.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "on          Returns:             TensorLike: canonical matrix          **Example**          >>> qml.MultiRZ.compute_matrix(torch.tensor(0.1), 2)         tensor([[0.9988-0.0500j, 0.0000+0.0000j, 0.0000"
    },
    {
      "id": "qml.IsingXY.compute_matrix",
      "name": "qml.IsingXY.compute_matrix",
      "type": "class",
      "description": "PennyLane API: IsingXY.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "gle          Returns:            TensorLike: canonical matrix          **Example**          >>> qml.IsingXY.compute_matrix(0.5)         array([[1.        +0.j        , 0.        +0.j        ,        0"
    },
    {
      "id": "qml.IsingZZ.compute_matrix",
      "name": "qml.IsingZZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: IsingZZ.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "gle          Returns:            TensorLike: canonical matrix          **Example**          >>> qml.IsingZZ.compute_matrix(torch.tensor(0.5))         tensor([[0.9689-0.2474j, 0.0000+0.0000j, 0.0000+0."
    },
    {
      "id": "qml.CPhaseShift10.compute_eigvals",
      "name": "qml.CPhaseShift10.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: CPhaseShift10.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "e shift          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.CPhaseShift10.compute_eigvals(torch.tensor(0.5))         tensor([1.0000+0.0000j, 1.0000+0.0000j, 0.8"
    },
    {
      "id": "qml.CPhaseShift01.compute_matrix",
      "name": "qml.CPhaseShift01.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CPhaseShift01.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "ft          Returns:             TensorLike: canonical matrix          **Example**          >>> qml.CPhaseShift01.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j, 0.0"
    },
    {
      "id": "qml.CPhaseShift00.compute_matrix",
      "name": "qml.CPhaseShift00.compute_matrix",
      "type": "class",
      "description": "PennyLane API: CPhaseShift00.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "ft          Returns:             TensorLike: canonical matrix          **Example**          >>> qml.CPhaseShift00.compute_matrix(torch.tensor(0.5))         tensor([[0.8776+0.4794j, 0.0000+0.0000j, 0.0"
    },
    {
      "id": "qml.CPhaseShift00.compute_eigvals",
      "name": "qml.CPhaseShift00.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: CPhaseShift00.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "e shift          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.CPhaseShift00.compute_eigvals(torch.tensor(0.5))         tensor([0.8776+0.4794j, 1.0000+0.0000j, 1.0"
    },
    {
      "id": "qml.IsingXX.compute_decomposition",
      "name": "qml.IsingXX.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: IsingXX.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.IsingXX.compute_decomposition(1.23, wires=(0,1))         [CNOT(wires=[0, 1]), RX(1.23, wires=[0]), C"
    },
    {
      "id": "qml.PSWAP.compute_decomposition",
      "name": "qml.PSWAP.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: PSWAP.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.PSWAP.compute_decomposition(1.23, wires=(0,1))         [SWAP(wires=[0, 1]), CNOT(wires=[0, 1]), Phas"
    },
    {
      "id": "qml.PauliRot.compute_eigvals",
      "name": "qml.PauliRot.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: PauliRot.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "gvals`           Returns:             TensorLike: eigenvalues          **Example**          >>> qml.PauliRot.compute_eigvals(torch.tensor(0.5), \"X\")         tensor([0.9689-0.2474j, 0.9689+0.2474j], dt"
    },
    {
      "id": "qml.IsingXX.compute_matrix",
      "name": "qml.IsingXX.compute_matrix",
      "type": "class",
      "description": "PennyLane API: IsingXX.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "gle          Returns:            TensorLike: canonical matrix          **Example**          >>> qml.IsingXX.compute_matrix(torch.tensor(0.5))         tensor([[0.9689+0.0000j, 0.0000+0.0000j, 0.0000+0."
    },
    {
      "id": "qml.IsingXY.compute_eigvals",
      "name": "qml.IsingXY.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: IsingXY.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "e angle          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.IsingXY.compute_eigvals(0.5)         array([0.96891242+0.24740396j, 0.96891242-0.24740396j,       1."
    },
    {
      "id": "qml.pauli.string_to_pauli_word",
      "name": "qml.pauli.string_to_pauli_word",
      "type": "function",
      "description": "PennyLane API: pauli.string_to_pauli_word. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": " {w: i for i, w in enumerate(self.wires)}          return qml.Hamiltonian(             [-0.5], [qml.pauli.string_to_pauli_word(pauli_word, wire_map=wire_map)]         )    [docs]     @staticmethod    "
    },
    {
      "id": "qml.CPhaseShift01.compute_eigvals",
      "name": "qml.CPhaseShift01.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: CPhaseShift01.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "e shift          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.CPhaseShift01.compute_eigvals(torch.tensor(0.5))         tensor([1.0000+0.0000j, 0.8776+0.4794j, 1.0"
    },
    {
      "id": "qml.IsingYY.compute_matrix",
      "name": "qml.IsingYY.compute_matrix",
      "type": "class",
      "description": "PennyLane API: IsingYY.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "gle          Returns:            TensorLike: canonical matrix          **Example**          >>> qml.IsingYY.compute_matrix(torch.tensor(0.5))         tensor([[0.9689+0.0000j, 0.0000+0.0000j, 0.0000+0."
    },
    {
      "id": "qml.IsingYY.compute_decomposition",
      "name": "qml.IsingYY.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: IsingYY.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.IsingYY.compute_decomposition(1.23, wires=(0,1))         [CY(wires=[0, 1]), RY(1.23, wires=[0]), CY("
    },
    {
      "id": "qml.MultiRZ.compute_eigvals",
      "name": "qml.MultiRZ.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: MultiRZ.compute_eigvals. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "acts on          Returns:             TensorLike: eigenvalues          **Example**          >>> qml.MultiRZ.compute_eigvals(torch.tensor(0.5), 3)         tensor([0.9689-0.2474j, 0.9689+0.2474j, 0.9689"
    },
    {
      "id": "qml.IsingXY.compute_decomposition",
      "name": "qml.IsingXY.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: IsingXY.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.IsingXY.compute_decomposition(1.23, wires=(0,1))         [H(0), CY(wires=[0, 1]), RY(0.615, wires=[0"
    },
    {
      "id": "qml.PSWAP.compute_matrix",
      "name": "qml.PSWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: PSWAP.compute_matrix. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "gle          Returns:            TensorLike: canonical matrix          **Example**          >>> qml.PSWAP.compute_matrix(0.5)         array([[1.        +0.j        , 0.        +0.j        ,           "
    },
    {
      "id": "qml.CPhaseShift10.compute_decomposition",
      "name": "qml.CPhaseShift10.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CPhaseShift10.compute_decomposition. Found in parametric_ops_multi_qubit.html",
      "source_file": "parametric_ops_multi_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.CPhaseShift10.compute_decomposition(1.234, wires=(0,1))         [X(1),         PhaseShift(0.617, wir"
    },
    {
      "id": "qml.PhaseShift.compute_matrix",
      "name": "qml.PhaseShift.compute_matrix",
      "type": "class",
      "description": "PennyLane API: PhaseShift.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "t          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.PhaseShift.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j],      "
    },
    {
      "id": "qml.U3",
      "name": "qml.U3",
      "type": "class",
      "description": "PennyLane API: U3. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": ")     U2(new_phi, new_delta, wires=wires)   add_decomps(\"Adjoint(U2)\", _adjoint_u2)    [docs] class U3(Operation):     r\"\"\"     Arbitrary single qubit unitary.      .. math::          U_3(\\theta, \\phi"
    },
    {
      "id": "qml.PhaseShift.compute_decomposition",
      "name": "qml.PhaseShift.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: PhaseShift.compute_decomposition. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.PhaseShift.compute_decomposition(1.234, wires=0)         [RZ(1.234, wires=[0]), GlobalPhase(-0.617, "
    },
    {
      "id": "qml.Rot.compute_matrix",
      "name": "qml.Rot.compute_matrix",
      "type": "class",
      "description": "PennyLane API: Rot.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.Rot.compute_matrix(torch.tensor(0.1), torch.tensor(0.2), torch.tensor(0.3))         tensor([[ 0.9752"
    },
    {
      "id": "qml.U3.compute_decomposition",
      "name": "qml.U3.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: U3.compute_decomposition. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.U3.compute_decomposition(1.23, 2.34, 3.45, wires=0)         [Rot(3.45, 1.23, -3.45, wires=[0]),     "
    },
    {
      "id": "qml.PhaseShift.compute_eigvals",
      "name": "qml.PhaseShift.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: PhaseShift.compute_eigvals. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": " shift          Returns:             tensor_like: eigenvalues          **Example**          >>> qml.PhaseShift.compute_eigvals(torch.tensor(0.5))         tensor([1.0000+0.0000j, 0.8776+0.4794j])      "
    },
    {
      "id": "qml.U2.compute_decomposition",
      "name": "qml.U2.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: U2.compute_decomposition. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.U2.compute_decomposition(1.23, 2.34, wires=0)         [Rot(2.34, np.float64(1.5707963267948966), -2."
    },
    {
      "id": "qml.RX.compute_matrix",
      "name": "qml.RX.compute_matrix",
      "type": "class",
      "description": "PennyLane API: RX.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.RX.compute_matrix(torch.tensor(0.5))         tensor([[0.9689+0.0000j, 0.0000-0.2474j],              "
    },
    {
      "id": "qml.RY.compute_matrix",
      "name": "qml.RY.compute_matrix",
      "type": "class",
      "description": "PennyLane API: RY.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.RY.compute_matrix(torch.tensor(0.5))         tensor([[ 0.9689+0.j, -0.2474-0.j],                 [ 0"
    },
    {
      "id": "qml.RZ.compute_eigvals",
      "name": "qml.RZ.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: RZ.compute_eigvals. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": " angle          Returns:             tensor_like: eigenvalues          **Example**          >>> qml.RZ.compute_eigvals(torch.tensor(0.5))         tensor([0.9689-0.2474j, 0.9689+0.2474j])         \"\"\"  "
    },
    {
      "id": "qml.U3.compute_matrix",
      "name": "qml.U3.compute_matrix",
      "type": "class",
      "description": "PennyLane API: U3.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.U3.compute_matrix(torch.tensor(0.1), torch.tensor(0.2), torch.tensor(0.3))         tensor([[ 0.9988+"
    },
    {
      "id": "qml.Rot.compute_decomposition",
      "name": "qml.Rot.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Rot.compute_decomposition. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.Rot.compute_decomposition(1.2, 2.3, 3.4, wires=0)         [RZ(1.2, wires=[0]), RY(2.3, wires=[0]), R"
    },
    {
      "id": "qml.U1.compute_matrix",
      "name": "qml.U1.compute_matrix",
      "type": "class",
      "description": "PennyLane API: U1.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.U1.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j],              "
    },
    {
      "id": "qml.RZ.compute_matrix",
      "name": "qml.RZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: RZ.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.RZ.compute_matrix(torch.tensor(0.5))         tensor([[0.9689-0.2474j, 0.0000+0.0000j],              "
    },
    {
      "id": "qml.U1.compute_decomposition",
      "name": "qml.U1.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: U1.compute_decomposition. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.U1.compute_decomposition(1.234, wires=0)         [PhaseShift(1.234, wires=[0])]          \"\"\"        "
    },
    {
      "id": "qml.U2.compute_matrix",
      "name": "qml.U2.compute_matrix",
      "type": "class",
      "description": "PennyLane API: U2.compute_matrix. Found in parametric_ops_single_qubit.html",
      "source_file": "parametric_ops_single_qubit.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.U2.compute_matrix(torch.tensor(0.1), torch.tensor(0.2))         tensor([[ 0.7071+0.0000j, -0.6930-0."
    },
    {
      "id": "qml.FermionicSWAP.compute_decomposition",
      "name": "qml.FermionicSWAP.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: FermionicSWAP.compute_decomposition. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.FermionicSWAP.compute_decomposition(0.2, wires=(0, 1))         [H(0),          H(1),          MultiR"
    },
    {
      "id": "qml.DoubleExcitation.compute_decomposition",
      "name": "qml.DoubleExcitation.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: DoubleExcitation.compute_decomposition. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.DoubleExcitation.compute_decomposition(1.23, wires=(0,1,2,3))         [CNOT(wires=[2, 3]),         C"
    },
    {
      "id": "qml.OrbitalRotation.compute_decomposition",
      "name": "qml.OrbitalRotation.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: OrbitalRotation.compute_decomposition. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.OrbitalRotation.compute_decomposition(1.2, wires=[0, 1, 2, 3])         [FermionicSWAP(3.141592653589"
    },
    {
      "id": "qml.SingleExcitation.compute_decomposition",
      "name": "qml.SingleExcitation.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SingleExcitation.compute_decomposition. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.SingleExcitation.compute_decomposition(1.23, wires=(0,1))         [H(0),          CNOT(wires=[0, 1])"
    },
    {
      "id": "qml.FermionicSWAP.compute_matrix",
      "name": "qml.FermionicSWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: FermionicSWAP.compute_matrix. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "gle          Returns:           tensor_like: canonical matrix          **Example**          >>> qml.FermionicSWAP.compute_matrix(torch.tensor(0.5))         tensor([[1.0000+0.0000j, 0.0000+0.0000j, 0.0"
    },
    {
      "id": "qml.SingleExcitation.compute_matrix",
      "name": "qml.SingleExcitation.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SingleExcitation.compute_matrix. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "gle          Returns:           tensor_like: canonical matrix          **Example**          >>> qml.SingleExcitation.compute_matrix(torch.tensor(0.5))         tensor([[ 1.0000,  0.0000,  0.0000,  0.00"
    },
    {
      "id": "qml.SingleExcitationPlus.compute_decomposition",
      "name": "qml.SingleExcitationPlus.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SingleExcitationPlus.compute_decomposition. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "el operations          **Example:**          >>> from pprint import pprint         >>> decomp = qml.SingleExcitationPlus.compute_decomposition(1.23, wires=(0,1))         >>> pprint(decomp)         [H("
    },
    {
      "id": "qml.SingleExcitationPlus.compute_matrix",
      "name": "qml.SingleExcitationPlus.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SingleExcitationPlus.compute_matrix. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "gle          Returns:           tensor_like: canonical matrix          **Example**          >>> qml.SingleExcitationPlus.compute_matrix(torch.tensor(0.5))         tensor([[ 0.9689+0.2474j,  0.0000+0.0"
    },
    {
      "id": "qml.SingleExcitationMinus.compute_matrix",
      "name": "qml.SingleExcitationMinus.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SingleExcitationMinus.compute_matrix. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "gle          Returns:           tensor_like: canonical matrix          **Example**          >>> qml.SingleExcitationMinus.compute_matrix(torch.tensor(0.5))         tensor([[ 0.9689-0.2474j,  0.0000+0."
    },
    {
      "id": "qml.FermionicSWAP",
      "name": "qml.FermionicSWAP",
      "type": "class",
      "description": "PennyLane API: FermionicSWAP. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "p operator, implemented in PennyLane as the     :class:`~.SingleExcitation` operation and :class:`~.FermionicSWAP` operation, respectively. This     implementation is a modified version of the one giv"
    },
    {
      "id": "qml.SingleExcitationMinus.compute_decomposition",
      "name": "qml.SingleExcitationMinus.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SingleExcitationMinus.compute_decomposition. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.SingleExcitationMinus.compute_decomposition(1.23, wires=(0,1))         [H(1),          CNOT(wires=[1"
    },
    {
      "id": "qml.OrbitalRotation",
      "name": "qml.OrbitalRotation",
      "type": "class",
      "description": "PennyLane API: OrbitalRotation. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "nMinus)\", adjoint_rotation) add_decomps(\"Pow(DoubleExcitationMinus)\", pow_rotation)    [docs] class OrbitalRotation(Operation):     r\"\"\"     Spin-adapted spatial orbital rotation.      For two neighbo"
    },
    {
      "id": "qml.SingleExcitation",
      "name": "qml.SingleExcitation",
      "type": "class",
      "description": "PennyLane API: SingleExcitation. Found in qchem_ops.html",
      "source_file": "qchem_ops.html",
      "context": "TensorLike) -> TensorLike:     \"\"\"This helper function unifies the `compute_matrix` methods     of `SingleExcitation`, `SingleExcitationPlus` and `SingleExcitationMinus`.     `phase_prefactor` determi"
    },
    {
      "id": "qml.ops.qubit.special_unitary.pauli_basis_strings",
      "name": "qml.ops.qubit.special_unitary.pauli_basis_strings",
      "type": "function",
      "description": "PennyLane API: ops.qubit.special_unitary.pauli_basis_strings. Found in special_unitary.html",
      "source_file": "special_unitary.html",
      "context": ") in     lexicographical order, which looks like the following for one and two qubits:      >>> qml.ops.qubit.special_unitary.pauli_basis_strings(1) # 4**1-1 = 3 Pauli words     ['X', 'Y', 'Z']     >>"
    },
    {
      "id": "qml.SpecialUnitary",
      "name": "qml.SpecialUnitary",
      "type": "class",
      "description": "PennyLane API: SpecialUnitary. Found in special_unitary.html",
      "source_file": "special_unitary.html",
      "context": "overning permissions and # limitations under the License. \"\"\" This submodule contains the operation SpecialUnitary and its utility functions. \"\"\" # pylint: disable=arguments-differ, import-outside-top"
    },
    {
      "id": "qml.SpecialUnitary.compute_matrix",
      "name": "qml.SpecialUnitary.compute_matrix",
      "type": "class",
      "description": "PennyLane API: SpecialUnitary.compute_matrix. Found in special_unitary.html",
      "source_file": "special_unitary.html",
      "context": "lt precision).          **Example**          >>> theta = np.array([0.5, 0.1, -0.3])         >>> qml.SpecialUnitary.compute_matrix(theta, num_wires=1)         array([[ 0.83004499-0.28280371j,  0.094267"
    },
    {
      "id": "qml.math.detach",
      "name": "qml.math.detach",
      "type": "function",
      "description": "PennyLane API: math.detach. Found in special_unitary.html",
      "source_file": "special_unitary.html",
      "context": "acobian. The adjoint of U(theta) is realized via -theta         U_dagger = self.compute_matrix(-qml.math.detach(theta), num_wires)         # After contracting, move the parameter derivative axis to th"
    },
    {
      "id": "qml.math.expm",
      "name": "qml.math.expm",
      "type": "function",
      "description": "PennyLane API: math.expm. Found in special_unitary.html",
      "source_file": "special_unitary.html",
      "context": ":             # jax.numpy.expm does not support broadcasting             return qml.math.stack([qml.math.expm(1j * _A) for _A in A])         return qml.math.expm(1j * A)    [docs]     def get_one_para"
    },
    {
      "id": "qml.StatePrep.compute_decomposition",
      "name": "qml.StatePrep.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: StatePrep.compute_decomposition. Found in state_preparation.html",
      "source_file": "state_preparation.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.StatePrep.compute_decomposition(np.array([1, 0, 0, 0]), wires=range(2))         [MottonenStatePrepar"
    },
    {
      "id": "qml.MottonenStatePreparation",
      "name": "qml.MottonenStatePreparation",
      "type": "class",
      "description": "PennyLane API: MottonenStatePreparation. Found in state_preparation.html",
      "source_file": "state_preparation.html",
      "context": "ration import Operation, Operator, StatePrepBase from pennylane.templates.state_preparations import MottonenStatePreparation from pennylane.typing import TensorLike from pennylane.wires import Wires, "
    },
    {
      "id": "qml.BasisState.compute_decomposition",
      "name": "qml.BasisState.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: BasisState.compute_decomposition. Found in state_preparation.html",
      "source_file": "state_preparation.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.BasisState.compute_decomposition([1,0], wires=(0,1))         [X(0)]          \"\"\"          if not qml"
    },
    {
      "id": "qml.QutritDepolarizingChannel",
      "name": "qml.QutritDepolarizingChannel",
      "type": "class",
      "description": "PennyLane API: QutritDepolarizingChannel. Found in channel.html",
      "source_file": "channel.html",
      "context": "  from pennylane import math from pennylane.operation import Channel  QUDIT_DIM = 3    [docs] class QutritDepolarizingChannel(Channel):     r\"\"\"     Single-qutrit symmetrically depolarizing error chan"
    },
    {
      "id": "qml.TritFlip.compute_kraus_matrices",
      "name": "qml.TritFlip.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: TritFlip.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "f Kraus matrices          **Example**          >>> from pprint import pprint         >>> pprint(qml.TritFlip.compute_kraus_matrices(0.05, 0.01, 0.10))         [array([[0.91651514, 0.        , 0.      "
    },
    {
      "id": "qml.QutritDepolarizingChannel.compute_kraus_matrices",
      "name": "qml.QutritDepolarizingChannel.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: QutritDepolarizingChannel.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "aus matrices          **Example**          >>> import pprint         >>> pprint.pprint(np.round(qml.QutritDepolarizingChannel.compute_kraus_matrices(0.5), 3))         array([[[ 0.707+0.j   ,  0.   +0."
    },
    {
      "id": "qml.QutritChannel.compute_kraus_matrices",
      "name": "qml.QutritChannel.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: QutritChannel.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "   >>> K_list = qml.QutritDepolarizingChannel(0.75, wires=0).kraus_matrices()         >>> res = qml.QutritChannel.compute_kraus_matrices(K_list)         >>> all(np.allclose(r, k) for r, k  in zip(res["
    },
    {
      "id": "qml.QutritAmplitudeDamping.compute_kraus_matrices",
      "name": "qml.QutritAmplitudeDamping.compute_kraus_matrices",
      "type": "class",
      "description": "PennyLane API: QutritAmplitudeDamping.compute_kraus_matrices. Found in channel.html",
      "source_file": "channel.html",
      "context": "f Kraus matrices          **Example**          >>> from pprint import pprint         >>> pprint(qml.QutritAmplitudeDamping.compute_kraus_matrices(0.5, 0.25, 0.36))         [array([[1.        , 0.     "
    },
    {
      "id": "qml.QutritUnitary.compute_matrix",
      "name": "qml.QutritUnitary.compute_matrix",
      "type": "class",
      "description": "PennyLane API: QutritUnitary.compute_matrix. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "         >>> U = np.array([[1, 1, 0], [1, -1, 0], [0, 0, np.sqrt(2)]]) / np.sqrt(2)         >>> qml.QutritUnitary.compute_matrix(U)         array([[ 0.70710678,  0.70710678,  0.        ],             "
    },
    {
      "id": "qml.ControlledQutritUnitary",
      "name": "qml.ControlledQutritUnitary",
      "type": "class",
      "description": "PennyLane API: ControlledQutritUnitary. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "hat the number         # of wires fits the dimensions of the matrix         if not isinstance(self, ControlledQutritUnitary):             U = params[0]             U_shape = qml.math.shape(U)         "
    },
    {
      "id": "qml.ControlledQutritUnitary.compute_matrix",
      "name": "qml.ControlledQutritUnitary.compute_matrix",
      "type": "class",
      "description": "PennyLane API: ControlledQutritUnitary.compute_matrix. Found in matrix_ops.html",
      "source_file": "matrix_ops.html",
      "context": "         >>> U = np.array([[1, 1, 0], [1, -1, 0], [0, 0, np.sqrt(2)]]) / np.sqrt(2)         >>> qml.ControlledQutritUnitary.compute_matrix(U, control_wires=[0], u_wires=[1], control_values=\"1\")       "
    },
    {
      "id": "qml.TAdd.compute_matrix",
      "name": "qml.TAdd.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TAdd.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "d.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.TAdd.compute_matrix())         [[1 0 0 0 0 0 0 0 0]          [0 1 0 0 0 0 0 0 0]          [0 0 1 0 0"
    },
    {
      "id": "qml.TClock.compute_matrix",
      "name": "qml.TClock.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TClock.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "k.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.TClock.compute_matrix())         [[ 1. +0.j         0. +0.j         0. +0.j       ]          [ 0. +0"
    },
    {
      "id": "qml.THadamard.compute_matrix",
      "name": "qml.THadamard.compute_matrix",
      "type": "class",
      "description": "PennyLane API: THadamard.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "Hadamard.          Returns:             ndarray: matrix          **Example**          >>> print(qml.THadamard.compute_matrix(subspace=(0, 2)))         [[ 0.70710678+0.j  0.        +0.j  0.70710678+0.j"
    },
    {
      "id": "qml.TSWAP.compute_eigvals",
      "name": "qml.TSWAP.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: TSWAP.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.TSWAP.compute_eigvals())         [ 1. -1.  1. -1.  1. -1.  1.  1.  1.]         \"\"\"         return np"
    },
    {
      "id": "qml.TSWAP.compute_matrix",
      "name": "qml.TSWAP.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TSWAP.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "P.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.TSWAP.compute_matrix())         [[1 0 0 0 0 0 0 0 0]          [0 0 0 1 0 0 0 0 0]          [0 0 0 0 "
    },
    {
      "id": "qml.THadamard",
      "name": "qml.THadamard",
      "type": "class",
      "description": "PennyLane API: THadamard. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "ow(z % 2)    [docs]     def adjoint(self):         return TSWAP(wires=self.wires)      [docs] class THadamard(Operation):     r\"\"\"THadamard(wires, subspace)     The ternary Hadamard operator      Perf"
    },
    {
      "id": "qml.TShift.compute_eigvals",
      "name": "qml.TShift.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: TShift.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.TShift.compute_eigvals())         [-0.5+0.8660254j -0.5-0.8660254j  1. +0.j       ]         \"\"\"     "
    },
    {
      "id": "qml.TShift.compute_matrix",
      "name": "qml.TShift.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TShift.compute_matrix. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "t.matrix`          Returns:             ndarray: matrix          **Example**          >>> print(qml.TShift.compute_matrix())         [[0 0 1]          [1 0 0]          [0 1 0]]         \"\"\"         ret"
    },
    {
      "id": "qml.TAdd.compute_eigvals",
      "name": "qml.TAdd.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: TAdd.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.TAdd.compute_eigvals())         [-0.5+0.8660254j -0.5-0.8660254j  1. +0.j        -0.5+0.8660254j -0."
    },
    {
      "id": "qml.TClock.compute_eigvals",
      "name": "qml.TClock.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: TClock.compute_eigvals. Found in non_parametric_ops.html",
      "source_file": "non_parametric_ops.html",
      "context": "gvals`          Returns:             array: eigenvalues          **Example**          >>> print(qml.TClock.compute_eigvals())         [ 1. +0.j        -0.5+0.8660254j -0.5-0.8660254j]         \"\"\"     "
    },
    {
      "id": "qml.GellMann.compute_diagonalizing_gates",
      "name": "qml.GellMann.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: GellMann.compute_diagonalizing_gates. Found in observables.html",
      "source_file": "observables.html",
      "context": "rns:             list[.Operator]: list of diagonalizing gates          **Example**          >>> qml.GellMann.compute_diagonalizing_gates(wires=0, index=4)         [QutritUnitary(array([[ 0.70710678-0."
    },
    {
      "id": "qml.THermitian.compute_diagonalizing_gates",
      "name": "qml.THermitian.compute_diagonalizing_gates",
      "type": "class",
      "description": "PennyLane API: THermitian.compute_diagonalizing_gates. Found in observables.html",
      "source_file": "observables.html",
      "context": "      >>> _, evecs = np.linalg.eigh(A)         >>> from pprint import pprint         >>> pprint(qml.THermitian.compute_diagonalizing_gates(evecs, wires=[0]))         [QutritUnitary(array([[-0.94915323"
    },
    {
      "id": "qml.GellMann.compute_matrix",
      "name": "qml.GellMann.compute_matrix",
      "type": "class",
      "description": "PennyLane API: GellMann.compute_matrix. Found in observables.html",
      "source_file": "observables.html",
      "context": "e          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.GellMann.compute_matrix(8)         array([[ 0.57735027+0.j,  0.        +0.j,  0.        +0.j],      "
    },
    {
      "id": "qml.THermitian.compute_matrix",
      "name": "qml.THermitian.compute_matrix",
      "type": "class",
      "description": "PennyLane API: THermitian.compute_matrix. Found in observables.html",
      "source_file": "observables.html",
      "context": "  **Example**          >>> A = np.array([[6+0j, 1-2j, 0],[1+2j, -1, 0], [0, 0, 1]])         >>> qml.THermitian.compute_matrix(A)         array([[ 6.+0.j,  1.-2.j,  0.+0.j],                [ 1.+2.j, -1"
    },
    {
      "id": "qml.GellMann.compute_eigvals",
      "name": "qml.GellMann.compute_eigvals",
      "type": "class",
      "description": "PennyLane API: GellMann.compute_eigvals. Found in observables.html",
      "source_file": "observables.html",
      "context": " 8 inclusive          Returns:             array: eigenvalues          **Example**          >>> qml.GellMann.compute_eigvals(1)         array([ 1, -1,  0])         \"\"\"         if index != 8:          "
    },
    {
      "id": "qml.TClock",
      "name": "qml.TClock",
      "type": "class",
      "description": "PennyLane API: TClock. Found in observables.html",
      "source_file": "observables.html",
      "context": ")     >>> @qml.qnode(dev)     ... def test_qnode():     ...     qml.TShift(wires=0)     ...     qml.TClock(wires=0)     ...     qml.TShift(wires=1)     ...     qml.TAdd(wires=[0, 1])     ...     retur"
    },
    {
      "id": "qml.TAdd",
      "name": "qml.TAdd",
      "type": "class",
      "description": "PennyLane API: TAdd. Found in observables.html",
      "source_file": "observables.html",
      "context": "qml.TShift(wires=0)     ...     qml.TClock(wires=0)     ...     qml.TShift(wires=1)     ...     qml.TAdd(wires=[0, 1])     ...     return qml.expval(qml.GellMann(wires=0, index=1))     >>> print(test_"
    },
    {
      "id": "qml.TRX.compute_matrix",
      "name": "qml.TRX.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TRX.compute_matrix. Found in parametric_ops.html",
      "source_file": "parametric_ops.html",
      "context": "n          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.TRX.compute_matrix(torch.tensor(0.5), subspace=(0, 2))         tensor([[0.9689+0.0000j, 0.0000+0.000"
    },
    {
      "id": "qml.TRZ",
      "name": "qml.TRZ",
      "type": "class",
      "description": "PennyLane API: TRZ. Found in parametric_ops.html",
      "source_file": "parametric_ops.html",
      "context": "         return [TRY(self.data[0] * z, wires=self.wires, subspace=self.subspace)]      [docs] class TRZ(Operation):     r\"\"\"The single qutrit Z rotation      Performs the RZ operation on the specified"
    },
    {
      "id": "qml.TRY",
      "name": "qml.TRY",
      "type": "class",
      "description": "PennyLane API: TRY. Found in parametric_ops.html",
      "source_file": "parametric_ops.html",
      "context": "         return [TRX(self.data[0] * z, wires=self.wires, subspace=self.subspace)]      [docs] class TRY(Operation):     r\"\"\"     The single qutrit Y rotation      Performs the RY operation on the spec"
    },
    {
      "id": "qml.TRY.compute_matrix",
      "name": "qml.TRY.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TRY.compute_matrix. Found in parametric_ops.html",
      "source_file": "parametric_ops.html",
      "context": "n          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.TRY.compute_matrix(torch.tensor(0.5), subspace=(0, 2))         tensor([[ 0.9689+0.j, -0.0000-0.j, -0"
    },
    {
      "id": "qml.TRZ.compute_matrix",
      "name": "qml.TRZ.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TRZ.compute_matrix. Found in parametric_ops.html",
      "source_file": "parametric_ops.html",
      "context": "n          Returns:             tensor_like: canonical matrix          **Example**          >>> qml.TRZ.compute_matrix(torch.tensor(0.5), subspace=(0, 2))         tensor([[0.9689-0.2474j, 0.0000+0.000"
    },
    {
      "id": "qml.QutritBasisState.compute_decomposition",
      "name": "qml.QutritBasisState.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QutritBasisState.compute_decomposition. Found in state_preparation.html",
      "source_file": "state_preparation.html",
      "context": "   list[Operator]: decomposition into lower level operations          **Example:**          >>> qml.QutritBasisState.compute_decomposition([1,0], wires=(0,1))         [QutritBasisStatePreparation(arra"
    },
    {
      "id": "qml.qchem.molecular_hamiltonian",
      "name": "qml.qchem.molecular_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.molecular_hamiltonian. Found in adaptive.html",
      "source_file": "adaptive.html",
      "context": "                      [1.87262415, -0.00815842, 0.0]], requires_grad=False)     >>> H, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, charge = 1)      The collection of gates to grow the "
    },
    {
      "id": "qml.qchem.hf_state",
      "name": "qml.qchem.hf_state",
      "type": "function",
      "description": "PennyLane API: qchem.hf_state. Found in adaptive.html",
      "source_file": "adaptive.html",
      "context": "tate and returning the expectation value of the     Hamiltonian is defined:      >>> hf_state = qml.qchem.hf_state(n_electrons, qubits)     >>> dev = qml.device(\"default.qubit\", wires=qubits)     >>> "
    },
    {
      "id": "qml.qchem.excitations",
      "name": "qml.qchem.excitations",
      "type": "function",
      "description": "PennyLane API: qchem.excitations. Found in adaptive.html",
      "source_file": "adaptive.html",
      "context": "ains all single and double     excitations:      >>> n_electrons = 2     >>> singles, doubles = qml.qchem.excitations(n_electrons, qubits)     >>> singles_excitations = [qml.SingleExcitation(0.0, x) f"
    },
    {
      "id": "qml.MomentumQNGOptimizer",
      "name": "qml.MomentumQNGOptimizer",
      "type": "class",
      "description": "PennyLane API: MomentumQNGOptimizer. Found in momentum_qng.html",
      "source_file": "momentum_qng.html",
      "context": "lane import numpy as pnp  from .qng import QNGOptimizer, _flatten_np, _unflatten_np    [docs] class MomentumQNGOptimizer(QNGOptimizer):     r\"\"\"A generalization of the Quantum Natural Gradient (QNG) o"
    },
    {
      "id": "qml.MomentumQNGOptimizerQJIT",
      "name": "qml.MomentumQNGOptimizerQJIT",
      "type": "class",
      "description": "PennyLane API: MomentumQNGOptimizerQJIT. Found in momentum_qng_qjit.html",
      "source_file": "momentum_qng_qjit.html",
      "context": "st interface\"\"\"  from pennylane import math  from .qng_qjit import QNGOptimizerQJIT    [docs] class MomentumQNGOptimizerQJIT(QNGOptimizerQJIT):     r\"\"\"Optax-like and ``jax.jit``/``qml.qjit``-compatib"
    },
    {
      "id": "qml.QNGOptimizer",
      "name": "qml.QNGOptimizer",
      "type": "class",
      "description": "PennyLane API: QNGOptimizer. Found in qng.html",
      "source_file": "qng.html",
      "context": "dd regularization     tensor += lam * math.eye(size, like=tensor)     return tensor    [docs] class QNGOptimizer(GradientDescentOptimizer):     r\"\"\"Optimizer with adaptive learning rate, via calculati"
    },
    {
      "id": "qml.QNGOptimizerQJIT",
      "name": "qml.QNGOptimizerQJIT",
      "type": "class",
      "description": "PennyLane API: QNGOptimizerQJIT. Found in qng_qjit.html",
      "source_file": "qng_qjit.html",
      "context": " has_jax = True try:     import jax except ModuleNotFoundError:     has_jax = False    [docs] class QNGOptimizerQJIT:     r\"\"\"Optax-like and ``jax.jit``/``qml.qjit``-compatible implementation of the :"
    },
    {
      "id": "qml.RiemannianGradientOptimizer",
      "name": "qml.RiemannianGradientOptimizer",
      "type": "class",
      "description": "PennyLane API: RiemannianGradientOptimizer. Found in riemannian_gradient.html",
      "source_file": "riemannian_gradient.html",
      "context": "\"Calculate the Riemannian gradient in the Lie algebra with the parameter shift rule     (see :meth:`RiemannianGradientOptimizer.get_omegas`).      Args:         tape (.QuantumTape or .QNode): input ci"
    },
    {
      "id": "qml.optimize.RotoselectOptimizer",
      "name": "qml.optimize.RotoselectOptimizer",
      "type": "function",
      "description": "PennyLane API: optimize.RotoselectOptimizer. Found in rotoselect.html",
      "source_file": "rotoselect.html",
      "context": "    choose the initial generators, and set the number of steps to optimize over.      >>> opt = qml.optimize.RotoselectOptimizer()     >>> x = [0.3, 0.7]     >>> generators = [qml.RX, qml.RY]     >>> "
    },
    {
      "id": "qml.optimize.RotosolveOptimizer",
      "name": "qml.optimize.RotosolveOptimizer",
      "type": "function",
      "description": "PennyLane API: optimize.RotosolveOptimizer. Found in rotosolve.html",
      "source_file": "rotosolve.html",
      "context": "run Rotosolve itself for three iterations.      >>> opt_kwargs = {\"num_steps\": 4}     >>> opt = qml.optimize.RotosolveOptimizer(substep_optimizer=\"brute\", substep_kwargs=opt_kwargs)     >>> num_steps "
    },
    {
      "id": "qml.ShotAdaptiveOptimizer",
      "name": "qml.ShotAdaptiveOptimizer",
      "type": "class",
      "description": "PennyLane API: ShotAdaptiveOptimizer. Found in shot_adaptive.html",
      "source_file": "shot_adaptive.html",
      "context": ", construct_tape, set_shots  from .gradient_descent import GradientDescentOptimizer    [docs] class ShotAdaptiveOptimizer(GradientDescentOptimizer):     r\"\"\"Optimizer where the shot rate is adaptively"
    },
    {
      "id": "qml.AngleEmbedding",
      "name": "qml.AngleEmbedding",
      "type": "class",
      "description": "PennyLane API: AngleEmbedding. Found in spsa.html",
      "source_file": "spsa.html",
      "context": "    >>> @qml.qnode(dev, interface=\"tf\")     ... def layer_fn_spsa(inputs, weights):     ...     qml.AngleEmbedding(inputs, wires=range(n_qubits))     ...     qml.BasicEntanglerLayers(weights, wires=ra"
    },
    {
      "id": "qml.BasicEntanglerLayers",
      "name": "qml.BasicEntanglerLayers",
      "type": "class",
      "description": "PennyLane API: BasicEntanglerLayers. Found in spsa.html",
      "source_file": "spsa.html",
      "context": "psa(inputs, weights):     ...     qml.AngleEmbedding(inputs, wires=range(n_qubits))     ...     qml.BasicEntanglerLayers(weights, wires=range(n_qubits))     ...     return qml.expval(qml.Z(0))     ..."
    },
    {
      "id": "qml.SPSAOptimizer",
      "name": "qml.SPSAOptimizer",
      "type": "class",
      "description": "PennyLane API: SPSAOptimizer. Found in spsa.html",
      "source_file": "spsa.html",
      "context": " \"\"\"SPSA optimizer\"\"\"  import numpy as np  from pennylane.measurements import Shots    [docs] class SPSAOptimizer:     r\"\"\"The Simultaneous Perturbation Stochastic Approximation method (SPSA)     is a"
    },
    {
      "id": "qml.math.max",
      "name": "qml.math.max",
      "type": "function",
      "description": "PennyLane API: math.max. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "ng:         shape = qml.math.shape(matrix)         num_qubits = int(qml.math.ceil(qml.math.log2(qml.math.max(shape))))         if shape[0] != shape[1] or shape[0] != 2**num_qubits:             padd_di"
    },
    {
      "id": "qml.math.pad",
      "name": "qml.math.pad",
      "type": "function",
      "description": "PennyLane API: math.pad. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "               else ((padd_diffs[0], 0), (padd_diffs[1], 0))             )             matrix = qml.math.pad(matrix, padding, mode=\"constant\", constant_values=0)      shape = qml.math.shape(matrix)   "
    },
    {
      "id": "qml.pauli.conversion._generalized_pauli_decompose_sparse",
      "name": "qml.pauli.conversion._generalized_pauli_decompose_sparse",
      "type": "function",
      "description": "PennyLane API: pauli.conversion._generalized_pauli_decompose_sparse. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "0], [0, -1, 0, 0.5], [0.5, 0, -1, 0], [0, 0.5, 0, 1]]         ... )         >>> coeffs, terms = qml.pauli.conversion._generalized_pauli_decompose_sparse(         ...     sparse_matrix, wire_order=[0, "
    },
    {
      "id": "qml.pauli.conversion._generalized_pauli_decompose",
      "name": "qml.pauli.conversion._generalized_pauli_decompose",
      "type": "function",
      "description": "PennyLane API: pauli.conversion._generalized_pauli_decompose. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "2+1j, -2, -2], [-2-1j,  0,  0, -1], [-2,  0, -2, -1], [-2, -1, -1,  1j]])     >>> coeffs, obs = qml.pauli.conversion._generalized_pauli_decompose(A)     >>> coeffs     array([-1. +0.25j, -1.5+0.j  , -"
    },
    {
      "id": "qml.math.gather",
      "name": "qml.math.gather",
      "type": "function",
      "description": "PennyLane API: math.gather. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "ces[-1], (idx + 1) ^ (idx)))     term_mat = qml.math.cast(         qml.math.stack(             [qml.math.gather(matrix[idx], indice) for idx, indice in enumerate(indices)]         ),         complex, "
    },
    {
      "id": "qml.math.ceil",
      "name": "qml.math.ceil",
      "type": "function",
      "description": "PennyLane API: math.ceil. Found in conversion.html",
      "source_file": "conversion.html",
      "context": "a power of two.     if padding:         shape = qml.math.shape(matrix)         num_qubits = int(qml.math.ceil(qml.math.log2(qml.math.max(shape))))         if shape[0] != shape[1] or shape[0] != 2**num"
    },
    {
      "id": "qml.pauli.are_identical_pauli_words",
      "name": "qml.pauli.are_identical_pauli_words",
      "type": "function",
      "description": "PennyLane API: pauli.are_identical_pauli_words. Found in group_observables.html",
      "source_file": "group_observables.html",
      "context": "inal observables,             for ind, observable in enumerate(observables):                 if qml.pauli.are_identical_pauli_words(pauli_word, observable):                     indices_this_group.appe"
    },
    {
      "id": "qml.math.add",
      "name": "qml.math.add",
      "type": "function",
      "description": "PennyLane API: math.add. Found in pauli_arithmetic.html",
      "source_file": "pauli_arithmetic.html",
      "context": "ds[i] for i in indices], wire_order)              full_matrix = mat if full_matrix is None else qml.math.add(full_matrix, mat)         return full_matrix   [docs]     def dot(self, vector, wire_order="
    },
    {
      "id": "qml.math.all",
      "name": "qml.math.all",
      "type": "function",
      "description": "PennyLane API: math.all. Found in pauli_arithmetic.html",
      "source_file": "pauli_arithmetic.html",
      "context": "      summands.append(                 pw_op                 if not math.is_abstract(coeff) and qml.math.all(coeff == 1)                 else SProd(coeff, pw_op, _pauli_rep=rep)             )         "
    },
    {
      "id": "qml.wires.WireError",
      "name": "qml.wires.WireError",
      "type": "function",
      "description": "PennyLane API: wires.WireError. Found in pauli_arithmetic.html",
      "source_file": "pauli_arithmetic.html",
      "context": "   try:             op_sparse_idx = _ps_to_sparse_index(pauli_words, wire_order)         except qml.wires.WireError as e:             raise ValueError(                 \"Can't get the matrix for the sp"
    },
    {
      "id": "qml.pauli.PauliVSpace",
      "name": "qml.pauli.PauliVSpace",
      "type": "function",
      "description": "PennyLane API: pauli.PauliVSpace. Found in pauli_vspace.html",
      "source_file": "pauli_vspace.html",
      "context": "independent operator to its basis.          >>> ops = [qml.X(0), qml.X(1)]         >>> vspace = qml.pauli.PauliVSpace(ops)         >>> vspace.add(qml.Y(0))         [1.0 * X(0), 1.0 * X(1), 1.0 * Y(0)]"
    },
    {
      "id": "qml.pauli.partition_pauli_group",
      "name": "qml.pauli.partition_pauli_group",
      "type": "function",
      "description": "PennyLane API: pauli.partition_pauli_group. Found in utils.html",
      "source_file": "utils.html",
      "context": "qubit-wise commuting groups containing Pauli words as         strings      **Example**      >>> qml.pauli.partition_pauli_group(3)     [['III', 'IIZ', 'IZI', 'IZZ', 'ZII', 'ZIZ', 'ZZI', 'ZZZ'],      ["
    },
    {
      "id": "qml.pulse.rect",
      "name": "qml.pulse.rect",
      "type": "function",
      "description": "PennyLane API: pulse.rect. Found in convenience_functions.html",
      "source_file": "convenience_functions.html",
      "context": ", 3])         time = jnp.linspace(0, 10, 1000)         windows = [(1, 7)]          windowed_f = qml.pulse.rect(f, windows=windows)          y1 = f(p, time)         y2 = jax.vmap(windowed_f, (None, 0))"
    },
    {
      "id": "qml.pulse.pwc",
      "name": "qml.pulse.pwc",
      "type": "function",
      "description": "PennyLane API: pulse.pwc. Found in convenience_functions.html",
      "source_file": "convenience_functions.html",
      "context": "y([1, 2, 3, 4, 5])         time = jnp.linspace(0, 10, 1000)         timespan=(2, 7)         y = qml.pulse.pwc(timespan)(params, time)         plt.plot(time, y, label=f\"params={params}, timespan={times"
    },
    {
      "id": "qml.pulse.pwc_from_function",
      "name": "qml.pulse.pwc_from_function",
      "type": "function",
      "description": "PennyLane API: pulse.pwc_from_function. Found in convenience_functions.html",
      "source_file": "convenience_functions.html",
      "context": "rams[0] * t + params[1]          timespan = 10         num_bins = 10          binned_function = qml.pulse.pwc_from_function(timespan, num_bins)(smooth_function)      >>> binned_function([2, 4], 3), sm"
    },
    {
      "id": "qml.pulse.rydberg_interaction",
      "name": "qml.pulse.rydberg_interaction",
      "type": "function",
      "description": "PennyLane API: pulse.rydberg_interaction. Found in rydberg.html",
      "source_file": "rydberg.html",
      "context": " [5, 10], [10, 0], [10, 5], [10, 10]]         wires = [1, 5, 0, 2, 4, 3, 8, 6, 7]         H_i = qml.pulse.rydberg_interaction(atom_coordinates, wires=wires)      >>> H_i     HardwareHamiltonian: terms"
    },
    {
      "id": "qml.pulse.rydberg_drive",
      "name": "qml.pulse.rydberg_drive",
      "type": "function",
      "description": "PennyLane API: pulse.rydberg_drive. Found in rydberg.html",
      "source_file": "rydberg.html",
      "context": "bda p, t: p * jnp.sin(jnp.pi * t) ** 2         phase = 0.25         detuning = 1.         H_d = qml.pulse.rydberg_drive(amplitude, phase, detuning, wires)      >>> H_i     HardwareHamiltonian: terms=6"
    },
    {
      "id": "qml.pulse.transmon_interaction",
      "name": "qml.pulse.transmon_interaction",
      "type": "function",
      "description": "PennyLane API: pulse.transmon_interaction. Found in transmon.html",
      "source_file": "transmon.html",
      "context": "alues.      .. code-block::          connections = [[0, 1], [1, 3], [2, 1], [4, 5]]         H = qml.pulse.transmon_interaction(qubit_freq=0.5, connections=connections, coupling=1., wires=range(6))    "
    },
    {
      "id": "qml.pulse.transmon_drive",
      "name": "qml.pulse.transmon_drive",
      "type": "function",
      "description": "PennyLane API: pulse.transmon_drive. Found in transmon.html",
      "source_file": "transmon.html",
      "context": ".exp(-t**2)          def phase(phi0, t):             return phi0          freq = 0          H = qml.pulse.transmon_drive(amp, phase, freq, 0)          t = 0.         A = 1.         phi0 = jnp.pi/2    "
    },
    {
      "id": "qml.qaoa.max_weight_cycle",
      "name": "qml.qaoa.max_weight_cycle",
      "type": "function",
      "description": "PennyLane API: qaoa.max_weight_cycle. Found in cost.html",
      "source_file": "cost.html",
      "context": "he mapping from wires to edges can be loaded         using:          >>> cost, mixer, mapping = qml.qaoa.max_weight_cycle(g, constrained=True)          Since we are using ``constrained=True``, we must"
    },
    {
      "id": "qml.qaoa.maxcut",
      "name": "qml.qaoa.maxcut",
      "type": "function",
      "description": "PennyLane API: qaoa.maxcut. Found in cost.html",
      "source_file": "cost.html",
      "context": "e :math:`i`-th and :math:`j`-th wire respectively.      The mixer Hamiltonian returned from :func:`~qaoa.maxcut` is :func:`~qaoa.x_mixer` applied to all wires.      .. note::          **Recommended in"
    },
    {
      "id": "qml.qchem.load_basisset",
      "name": "qml.qchem.load_basisset",
      "type": "function",
      "description": "PennyLane API: qchem.load_basisset. Found in basis_data.html",
      "source_file": "basis_data.html",
      "context": "basis function      **Example**      >>> basis = '6-31g'     >>> element = 'He'     >>> basis = qml.qchem.load_basisset(basis, element)     >>> basis     {'orbitals': ['S', 'S'],      'exponents': [[3"
    },
    {
      "id": "qml.qchem.import_state",
      "name": "qml.qchem.import_state",
      "type": "function",
      "description": "PennyLane API: qchem.import_state. Found in convert.html",
      "source_file": "convert.html",
      "context": "sto6g')     >>> myhf = scf.UHF(mol).run()     >>> myci = ci.UCISD(myhf).run()     >>> wf_cisd = qml.qchem.import_state(myci, tol=1e-1)     >>> print(wf_cisd)     [ 0.        +0.j  0.        +0.j  0.  "
    },
    {
      "id": "qml.to_openfermion",
      "name": "qml.to_openfermion",
      "type": "function",
      "description": "PennyLane API: to_openfermion. Found in convert_openfermion.html",
      "source_file": "convert_openfermion.html",
      "context": "rt LinearCombination, Sum from pennylane.qchem.convert import _openfermion_to_pennylane, _pennylane_to_openfermion   def _import_of():     \"\"\"Import openfermion.\"\"\"     try:         # pylint: disable="
    },
    {
      "id": "qml.fermi.fermionic._to_string",
      "name": "qml.fermi.fermionic._to_string",
      "type": "function",
      "description": "PennyLane API: fermi.fermionic._to_string. Found in convert_openfermion.html",
      "source_file": "convert_openfermion.html",
      "context": "mapping is not supported for fermionic operators.\")      return openfermion.ops.FermionOperator(qml.fermi.fermionic._to_string(ops, of=True))   @_to_openfermion_dispatch.register def _(pl_op: FermiSen"
    },
    {
      "id": "qml.from_openfermion",
      "name": "qml.from_openfermion",
      "type": "function",
      "description": "PennyLane API: from_openfermion. Found in convert_openfermion.html",
      "source_file": "convert_openfermion.html",
      "context": "nstalled with: pip install openfermion.\"         ) from Error      return openfermion    [docs] def from_openfermion(openfermion_op, wires=None, tol=1e-16):     r\"\"\"Convert OpenFermion     `FermionOpe"
    },
    {
      "id": "qml.numpy.tensor",
      "name": "qml.numpy.tensor",
      "type": "function",
      "description": "PennyLane API: numpy.tensor. Found in dipole.html",
      "source_file": "dipole.html",
      "context": "e_orbitals     )      if method == \"dhf\":          if args is None and isinstance(geometry_dhf, qml.numpy.tensor):             geometry_dhf.requires_grad = False         mol = qml.qchem.Molecule(     "
    },
    {
      "id": "qml.math.ix_",
      "name": "qml.math.ix_",
      "type": "function",
      "description": "PennyLane API: math.ix_. Found in dipole.html",
      "source_file": "dipole.html",
      "context": " core_y = core_y + 2 * d_y[i][i]             core_z = core_z + 2 * d_z[i][i]          d_x = d_x[qml.math.ix_(active, active)]         d_y = d_y[qml.math.ix_(active, active)]         d_z = d_z[qml.math"
    },
    {
      "id": "qml.qchem.convert._process_wires",
      "name": "qml.qchem.convert._process_wires",
      "type": "function",
      "description": "PennyLane API: qchem.convert._process_wires. Found in dipole.html",
      "source_file": "dipole.html",
      "context": "ive=active, mapping=mapping             )()         )         if wires:             wires_new = qml.qchem.convert._process_wires(wires)             wires_map = dict(zip(range(len(wires_new)), list(wir"
    },
    {
      "id": "qml.qchem.molecular_dipole",
      "name": "qml.qchem.molecular_dipole",
      "type": "function",
      "description": "PennyLane API: qchem.molecular_dipole. Found in dipole.html",
      "source_file": "dipole.html",
      "context": "2, 0.0]])     >>> mol = qml.qchem.Molecule(symbols, coordinates, charge=1)     >>> dipole_obs = qml.qchem.molecular_dipole(mol, method=\"openfermion\")     >>> dipole_obs[0] # x-component of D     (    "
    },
    {
      "id": "qml.qchem.dipole_moment",
      "name": "qml.qchem.dipole_moment",
      "type": "function",
      "description": "PennyLane API: qchem.dipole_moment. Found in dipole.html",
      "source_file": "dipole.html",
      "context": "molecule.coeff,         )          requires_grad = args is not None         dip = (             qml.qchem.dipole_moment(mol, cutoff=cutoff, core=core, active=active, mapping=mapping)(                 "
    },
    {
      "id": "qml.qchem.dipole_of",
      "name": "qml.qchem.dipole_of",
      "type": "function",
      "description": "PennyLane API: qchem.dipole_of. Found in dipole.html",
      "source_file": "dipole.html",
      "context": ")             dip = [qml.map_wires(op, wires_map) for op in dip]          return dip      dip = qml.qchem.dipole_of(         symbols,         geometry_hf,         molecule.name,         molecule.charg"
    },
    {
      "id": "qml.qchem.active_space",
      "name": "qml.qchem.active_space",
      "type": "function",
      "description": "PennyLane API: qchem.active_space. Found in dipole.html",
      "source_file": "dipole.html",
      "context": "pported. Change the charge or spin multiplicity of the molecule.\"         )      core, active = qml.qchem.active_space(         molecule.n_electrons, molecule.n_orbitals, molecule.mult, active_electro"
    },
    {
      "id": "qml.qchem.factorization._chemist_transform",
      "name": "qml.qchem.factorization._chemist_transform",
      "type": "function",
      "description": "PennyLane API: qchem.factorization._chemist_transform. Found in factorization.html",
      "source_file": "factorization.html",
      "context": "olecule(symbols, geometry)     >>> core, one, two = qml.qchem.electron_integrals(mol)()     >>> qml.qchem.factorization._chemist_transform(two_body_tensor=two, spatial_basis=True)     (tensor([[-0.427"
    },
    {
      "id": "qml.math.argmax",
      "name": "qml.math.argmax",
      "type": "function",
      "description": "PennyLane API: math.argmax. Found in factorization.html",
      "source_file": "factorization.html",
      "context": "factor:             cholesky_vecs = cholesky_vecs[:, :idx]             break          max_idx = qml.math.argmax(cholesky_diag)         cholesky_mat = cholesky_vecs[:, :idx]         cholesky_vec = (   "
    },
    {
      "id": "qml.math.linalg.eigh",
      "name": "qml.math.linalg.eigh",
      "type": "function",
      "description": "PennyLane API: math.linalg.eigh. Found in factorization.html",
      "source_file": "factorization.html",
      "context": "factors, and truncated eigenvectors of the generated factors     \"\"\"     eigvals_r, eigvecs_r = qml.math.linalg.eigh(two)     eigvals_r = qml.math.array([val for val in eigvals_r if abs(val) > tol_fac"
    },
    {
      "id": "qml.qchem.fermionic_observable",
      "name": "qml.qchem.fermionic_observable",
      "type": "function",
      "description": "PennyLane API: qchem.fermionic_observable. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": "ls, geometry_hf, charge, mult, basis, active_electrons, active_orbitals         )          hf = qml.qchem.fermionic_observable(core_constant, one_mo, two_mo)          qubits = len(hf.wires)          i"
    },
    {
      "id": "qml.math.swapaxes",
      "name": "qml.math.swapaxes",
      "type": "function",
      "description": "PennyLane API: math.swapaxes. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": "l)(*args)         one = qml.math.einsum(\"qr,rs,st->qt\", coeffs.T, h_core, coeffs)         two = qml.math.swapaxes(             qml.math.einsum(                 \"ab,cd,bdeg,ef,gh->acfh\", coeffs.T, coef"
    },
    {
      "id": "qml.qchem.openfermion_pyscf._openfermion_hamiltonian",
      "name": "qml.qchem.openfermion_pyscf._openfermion_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.openfermion_pyscf._openfermion_hamiltonian. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": " tol=1.0e-10)          h_pl = h_pl.simplify()          return h_pl, len(h_pl.wires)      h_pl = qml.qchem.openfermion_pyscf._openfermion_hamiltonian(         symbols,         geometry_hf,         name"
    },
    {
      "id": "qml.jordan_wigner",
      "name": "qml.jordan_wigner",
      "type": "function",
      "description": "PennyLane API: jordan_wigner. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": "c_hamiltonian     [docs] def diff_hamiltonian(mol, cutoff=1.0e-12, core=None, active=None, mapping=\"jordan_wigner\"):     r\"\"\"Return a function that computes the qubit Hamiltonian.      Args:         m"
    },
    {
      "id": "qml.parity_transform",
      "name": "qml.parity_transform",
      "type": "function",
      "description": "PennyLane API: parity_transform. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": "igner(hf, wire_map=wires_map, tol=1.0e-10)         elif mapping == \"parity\":             h_pl = qml.parity_transform(hf, qubits, wire_map=wires_map, tol=1.0e-10)         elif mapping == \"bravyi_kitaev"
    },
    {
      "id": "qml.qchem.diff_hamiltonian",
      "name": "qml.qchem.diff_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.diff_hamiltonian. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": ">>> mol = qml.qchem.Molecule(symbols, geometry, alpha=alpha)     >>> args = [alpha]     >>> h = qml.qchem.diff_hamiltonian(mol)(*args)     >>> h.terms()[0]     [tensor(0.29817878, requires_grad=True),"
    },
    {
      "id": "qml.bravyi_kitaev",
      "name": "qml.bravyi_kitaev",
      "type": "function",
      "description": "PennyLane API: bravyi_kitaev. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": "e fermion-to-qubit mapping. Input values can             be ``'jordan_wigner'``, ``'parity'`` or ``'bravyi_kitaev'``.      Returns:         function: function that computes the qubit hamiltonian      "
    },
    {
      "id": "qml.qchem.openfermion_pyscf._pyscf_integrals",
      "name": "qml.qchem.openfermion_pyscf._pyscf_integrals",
      "type": "function",
      "description": "PennyLane API: qchem.openfermion_pyscf._pyscf_integrals. Found in hamiltonian.html",
      "source_file": "hamiltonian.html",
      "context": "oad_data=load_data,         )     if method == \"pyscf\":         core_constant, one_mo, two_mo = qml.qchem.openfermion_pyscf._pyscf_integrals(             symbols, geometry_hf, charge, mult, basis, act"
    },
    {
      "id": "qml.math.gammainc",
      "name": "qml.math.gammainc",
      "type": "function",
      "description": "PennyLane API: math.gammainc. Found in integrals.html",
      "source_file": "integrals.html",
      "context": " function     \"\"\"     return qml.math.where(         t == 0.0,         1 / (2 * n + 1),         qml.math.gammainc(n + 0.5, t + (t == 0.0))         * qml.math.gamma(n + 0.5)         / (2 * (t + (t == 0"
    },
    {
      "id": "qml.math.gamma",
      "name": "qml.math.gamma",
      "type": "function",
      "description": "PennyLane API: math.gamma. Found in integrals.html",
      "source_file": "integrals.html",
      "context": " function     \"\"\"     return qml.math.where(         t == 0.0,         1 / (2 * n + 1),         qml.math.gammainc(n + 0.5, t + (t == 0.0))         * qml.math.gamma(n + 0.5)         / (2 * (t + (t == 0"
    },
    {
      "id": "qml.math.isnan",
      "name": "qml.math.isnan",
      "type": "function",
      "description": "PennyLane API: math.isnan. Found in matrices.html",
      "source_file": "matrices.html",
      "context": " a), (j, b), (k, c), (l, d) in it.product(enumerate(basis_functions), repeat=4):             if qml.math.isnan(e_calc[(i, j, k, l)]):                 args_abcd = []                 if args:           "
    },
    {
      "id": "qml.qchem.scf",
      "name": "qml.qchem.scf",
      "type": "function",
      "description": "PennyLane API: qchem.scf. Found in molecule.html",
      "source_file": "molecule.html",
      "context": "0]], requires_grad = False)         >>> mol = qml.qchem.Molecule(symbols, geometry)         >>> qml.qchem.scf(mol)() # run scf to obtain the optimized molecular orbitals         >>> mo = mol.molecular"
    },
    {
      "id": "qml.math.argwhere",
      "name": "qml.math.argwhere",
      "type": "function",
      "description": "PennyLane API: math.argwhere. Found in observable_hf.html",
      "source_file": "observable_hf.html",
      "context": "perators = [[]]     else:         operators = []      if one is not None:         indices_one = qml.math.argwhere(abs(one) >= cutoff)         # up-up + down-down terms         operators_one = (indices"
    },
    {
      "id": "qml.math.tile",
      "name": "qml.math.tile",
      "type": "function",
      "description": "PennyLane API: math.tile. Found in observable_hf.html",
      "source_file": "observable_hf.html",
      "context": "perators_one = (indices_one * 2).tolist() + (indices_one * 2 + 1).tolist()         coeffs_one = qml.math.tile(one[abs(one) >= cutoff], 2)         coeffs = qml.math.convert_like(coeffs, one)         co"
    },
    {
      "id": "qml.qchem.convert.import_operator",
      "name": "qml.qchem.convert.import_operator",
      "type": "function",
      "description": "PennyLane API: qchem.convert.import_operator. Found in openfermion_pyscf.html",
      "source_file": "openfermion_pyscf.html",
      "context": "ap the fermionic operator to a qubit operator     if mapping == \"bravyi_kitaev\":         return qml.qchem.convert.import_operator(             openfermion.transforms.bravyi_kitaev(mb_obs), wires=wires"
    },
    {
      "id": "qml.qchem.meanfield",
      "name": "qml.qchem.meanfield",
      "type": "function",
      "description": "PennyLane API: qchem.meanfield. Found in openfermion_pyscf.html",
      "source_file": "openfermion_pyscf.html",
      "context": "ic_numbers:             raise ValueError(f\"Requested element {i} doesn't exist\")      hf_file = qml.qchem.meanfield(symbols, coordinates, name, charge, mult, basis, package, outpath)      hf = openfer"
    },
    {
      "id": "qml.taper",
      "name": "qml.taper",
      "type": "function",
      "description": "PennyLane API: taper. Found in tapering.html",
      "source_file": "tapering.html",
      "context": "                                  pennylane.qchem.tapering — PennyLane 0.45.0-dev3 documentation                       About     Research                  "
    },
    {
      "id": "qml.taper_operation",
      "name": "qml.taper_operation",
      "type": "function",
      "description": "PennyLane API: taper_operation. Found in tapering.html",
      "source_file": "tapering.html",
      "context": "rguments,too-many-positional-arguments # pylint: disable=inconsistent-return-statements  [docs] def taper_operation(     operation, generators, paulixops, paulix_sector, wire_order, op_wires=None, op_"
    },
    {
      "id": "qml.qchem.symmetry_generators",
      "name": "qml.qchem.symmetry_generators",
      "type": "function",
      "description": "PennyLane API: qchem.symmetry_generators. Found in tapering.html",
      "source_file": "tapering.html",
      "context": "]])     >>> H, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry)     >>> generators = qml.qchem.symmetry_generators(H)     >>> paulixops = paulix_ops(generators, 4)     >>> paulix_sector = ["
    },
    {
      "id": "qml.qchem.optimal_sector",
      "name": "qml.qchem.optimal_sector",
      "type": "function",
      "description": "PennyLane API: qchem.optimal_sector. Found in tapering.html",
      "source_file": "tapering.html",
      "context": "ar_hamiltonian(symbols, geometry)     >>> generators = qml.qchem.symmetry_generators(H)     >>> qml.qchem.optimal_sector(H, generators, 2)         [1, -1, -1]     \"\"\"      if active_electrons < 1:    "
    },
    {
      "id": "qml.qchem.paulix_ops",
      "name": "qml.qchem.paulix_ops",
      "type": "function",
      "description": "PennyLane API: qchem.paulix_ops. Found in tapering.html",
      "source_file": "tapering.html",
      "context": "lec = mol.n_electrons     >>> generators = qml.qchem.symmetry_generators(H)     >>> paulixops = qml.qchem.paulix_ops(generators, 4)     >>> paulix_sector = qml.qchem.optimal_sector(H, generators, n_el"
    },
    {
      "id": "qml.qchem.vibrational.christiansen_hamiltonian",
      "name": "qml.qchem.vibrational.christiansen_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.vibrational.christiansen_hamiltonian. Found in christiansen_ham.html",
      "source_file": "christiansen_ham.html",
      "context": "olecule(symbols, geometry)     >>> pes = qml.qchem.vibrational_pes(mol, optimize=False)     >>> qml.qchem.vibrational.christiansen_hamiltonian(pes, n_states = 4)     (         0.08527499987546708 * I("
    },
    {
      "id": "qml.qchem.vibrational.christiansen_integrals",
      "name": "qml.qchem.vibrational.christiansen_integrals",
      "type": "function",
      "description": "PennyLane API: qchem.vibrational.christiansen_integrals. Found in christiansen_ham.html",
      "source_file": "christiansen_ham.html",
      "context": "ols, geometry)     >>> pes = qml.qchem.vibrational_pes(mol, optimize=False)     >>> integrals = qml.qchem.vibrational.christiansen_integrals(pes, n_states = 4)     >>> print(qml.qchem.christiansen_bos"
    },
    {
      "id": "qml.qchem.vibrational.christiansen_dipole",
      "name": "qml.qchem.vibrational.christiansen_dipole",
      "type": "function",
      "description": "PennyLane API: qchem.vibrational.christiansen_dipole. Found in christiansen_ham.html",
      "source_file": "christiansen_ham.html",
      "context": "s = qml.qchem.vibrational_pes(mol, optimize=False, dipole_level=3, cubic=True)     >>> dipole = qml.qchem.vibrational.christiansen_dipole(pes, n_states = 4)     >>> dipole[2]     (         (-0.0055125"
    },
    {
      "id": "qml.qchem.christiansen_bosonic",
      "name": "qml.qchem.christiansen_bosonic",
      "type": "function",
      "description": "PennyLane API: qchem.christiansen_bosonic. Found in christiansen_ham.html",
      "source_file": "christiansen_ham.html",
      "context": "  >>> integrals = qml.qchem.vibrational.christiansen_integrals(pes, n_states = 4)     >>> print(qml.qchem.christiansen_bosonic(integrals[0]))     0.010354801267111937 * b⁺(0) b(0)     + 0.001939404941"
    },
    {
      "id": "qml.qchem.vibrational_pes",
      "name": "qml.qchem.vibrational_pes",
      "type": "function",
      "description": "PennyLane API: qchem.vibrational_pes. Found in christiansen_ham.html",
      "source_file": "christiansen_ham.html",
      "context": "16], [0.0, 0.0, 1.40277116]])     >>> mol = qml.qchem.Molecule(symbols, geometry)     >>> pes = qml.qchem.vibrational_pes(mol, optimize=False)     >>> integrals = qml.qchem.vibrational.christiansen_in"
    },
    {
      "id": "qml.qchem.vibrational.christiansen_integrals_dipole",
      "name": "qml.qchem.vibrational.christiansen_integrals_dipole",
      "type": "function",
      "description": "PennyLane API: qchem.vibrational.christiansen_integrals_dipole. Found in christiansen_utils.html",
      "source_file": "christiansen_utils.html",
      "context": ".qchem.vibrational_pes(mol, optimize = False, dipole_level = 3, cubic=True)     >>> integrals = qml.qchem.vibrational.christiansen_integrals_dipole(pes, n_states = 2)     >>> print(integrals[0][2])   "
    },
    {
      "id": "qml.qchem.localize_normal_modes",
      "name": "qml.qchem.localize_normal_modes",
      "type": "function",
      "description": "PennyLane API: qchem.localize_normal_modes. Found in localize_modes.html",
      "source_file": "localize_modes.html",
      "context": "     [-5.49709883e-17,  7.49851221e-08, -2.77912798e-02]]])     >>> freqs_loc, vecs_loc, uloc = qml.qchem.localize_normal_modes(freqs, vectors)     >>> freqs_loc     array([1332.62013257, 2296.7345345"
    },
    {
      "id": "qml.qchem.taylor_dipole_coeffs",
      "name": "qml.qchem.taylor_dipole_coeffs",
      "type": "function",
      "description": "PennyLane API: qchem.taylor_dipole_coeffs. Found in taylor_ham.html",
      "source_file": "taylor_ham.html",
      "context": "ibrationalPES(freqs=freqs, dipole_data=[dipole_onemode])     >>> coeffs_x, coeffs_y, coeffs_z = qml.qchem.taylor_dipole_coeffs(pes_object, 4, 2)     >>> print(coeffs_z)     [array([[-1.54126823e-03,  "
    },
    {
      "id": "qml.qchem.taylor_hamiltonian",
      "name": "qml.qchem.taylor_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.taylor_hamiltonian. Found in taylor_ham.html",
      "source_file": "taylor_ham.html",
      "context": " = qml.qchem.VibrationalPES(freqs=freqs, pes_data=[pes_onemode], localized=False)     >>> ham = qml.qchem.taylor_hamiltonian(pes_object)     >>> print(ham)     0.026123120450329353 * I(0) + -0.0132533"
    },
    {
      "id": "qml.qchem.taylor_bosonic",
      "name": "qml.qchem.taylor_bosonic",
      "type": "function",
      "description": "PennyLane API: qchem.taylor_bosonic. Found in taylor_ham.html",
      "source_file": "taylor_ham.html",
      "context": "array([[-0.00088528, -0.00361425,  0.00068143]])     >>> uloc = np.array([[1.0]])     >>> ham = qml.qchem.taylor_bosonic(coeffs=[one_mode], freqs=freqs, uloc=uloc)     >>> print(ham)     -0.0012778303"
    },
    {
      "id": "qml.qchem.VibrationalPES",
      "name": "qml.qchem.VibrationalPES",
      "type": "function",
      "description": "PennyLane API: qchem.VibrationalPES. Found in taylor_ham.html",
      "source_file": "taylor_ham.html",
      "context": ">> pes_onemode = np.array([[0.08477, 0.01437, 0.00000, 0.00937, 0.03414]])     >>> pes_object = qml.qchem.VibrationalPES(freqs=freqs, pes_data=[pes_onemode])     >>> coeffs = qml.qchem.taylor_coeffs(p"
    },
    {
      "id": "qml.qchem.taylor_coeffs",
      "name": "qml.qchem.taylor_coeffs",
      "type": "function",
      "description": "PennyLane API: qchem.taylor_coeffs. Found in taylor_ham.html",
      "source_file": "taylor_ham.html",
      "context": ">>> pes_object = qml.qchem.VibrationalPES(freqs=freqs, pes_data=[pes_onemode])     >>> coeffs = qml.qchem.taylor_coeffs(pes_object, 4, 2)     >>> print(coeffs)     [array([[-4.73959071e-05, -3.0678577"
    },
    {
      "id": "qml.qchem.optimize_geometry",
      "name": "qml.qchem.optimize_geometry",
      "type": "function",
      "description": "PennyLane API: qchem.optimize_geometry. Found in vibrational_class.html",
      "source_file": "vibrational_class.html",
      "context": "        [0.0, 0.0, 1.0]])     >>> mol = qml.qchem.Molecule(symbols, geometry)     >>> eq_geom = qml.qchem.optimize_geometry(mol)     >>> eq_geom     array([[ 0.        ,  0.        , -0.40277116],    "
    },
    {
      "id": "qml.qchem.vscf_integrals",
      "name": "qml.qchem.vscf_integrals",
      "type": "function",
      "description": "PennyLane API: qchem.vscf_integrals. Found in vscf.html",
      "source_file": "vscf.html",
      "context": ".01280986],     ...                 [0.00199125, 0.0021936,  0.01280986, 0.07282307]]])     >>> qml.qchem.vscf_integrals(h_integrals=[h1], modals=[4,4,4])     ([array([[[ 9.36124041e-03, -4.20128342e-"
    },
    {
      "id": "qml.qcut.CutStrategy",
      "name": "qml.qcut.CutStrategy",
      "type": "function",
      "description": "PennyLane API: qcut.CutStrategy. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "ph_to_tape             ~qcut.expand_fragment_tape             ~qcut.qcut_processing_fn             ~qcut.CutStrategy          The following shows how these elementary steps are combined as part of the"
    },
    {
      "id": "qml.qcut.replace_wire_cut_nodes",
      "name": "qml.qcut.replace_wire_cut_nodes",
      "type": "function",
      "description": "PennyLane API: qcut.replace_wire_cut_nodes. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "      :toctree:              ~qcut.tape_to_graph             ~qcut.find_and_place_cuts             ~qcut.replace_wire_cut_nodes             ~qcut.fragment_graph             ~qcut.graph_to_tape        "
    },
    {
      "id": "qml.qcut.expand_fragment_tape",
      "name": "qml.qcut.expand_fragment_tape",
      "type": "function",
      "description": "PennyLane API: qcut.expand_fragment_tape. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "eplace_wire_cut_nodes             ~qcut.fragment_graph             ~qcut.graph_to_tape             ~qcut.expand_fragment_tape             ~qcut.qcut_processing_fn             ~qcut.CutStrategy        "
    },
    {
      "id": "qml.qcut.graph_to_tape",
      "name": "qml.qcut.graph_to_tape",
      "type": "function",
      "description": "PennyLane API: qcut.graph_to_tape. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "d_place_cuts             ~qcut.replace_wire_cut_nodes             ~qcut.fragment_graph             ~qcut.graph_to_tape             ~qcut.expand_fragment_tape             ~qcut.qcut_processing_fn      "
    },
    {
      "id": "qml.WireCut",
      "name": "qml.WireCut",
      "type": "class",
      "description": "PennyLane API: WireCut. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "    \"\"\"Main entry point for expanding operations until reaching a depth that     includes :class:`~.WireCut` operations.\"\"\"     # pylint: disable=unused-argument      def processing_fn(res):         r"
    },
    {
      "id": "qml.qcut.fragment_graph",
      "name": "qml.qcut.fragment_graph",
      "type": "function",
      "description": "PennyLane API: qcut.fragment_graph. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "o_graph             ~qcut.find_and_place_cuts             ~qcut.replace_wire_cut_nodes             ~qcut.fragment_graph             ~qcut.graph_to_tape             ~qcut.expand_fragment_tape          "
    },
    {
      "id": "qml.qcut.find_and_place_cuts",
      "name": "qml.qcut.find_and_place_cuts",
      "type": "function",
      "description": "PennyLane API: qcut.find_and_place_cuts. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "lity:          .. autosummary::             :toctree:              ~qcut.tape_to_graph             ~qcut.find_and_place_cuts             ~qcut.replace_wire_cut_nodes             ~qcut.fragment_graph  "
    },
    {
      "id": "qml.qcut.qcut_processing_fn",
      "name": "qml.qcut.qcut_processing_fn",
      "type": "function",
      "description": "PennyLane API: qcut.qcut_processing_fn. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": ".fragment_graph             ~qcut.graph_to_tape             ~qcut.expand_fragment_tape             ~qcut.qcut_processing_fn             ~qcut.CutStrategy          The following shows how these element"
    },
    {
      "id": "qml.qcut.tape_to_graph",
      "name": "qml.qcut.tape_to_graph",
      "type": "function",
      "description": "PennyLane API: qcut.tape_to_graph. Found in cutcircuit.html",
      "source_file": "cutcircuit.html",
      "context": "utting using the below functionality:          .. autosummary::             :toctree:              ~qcut.tape_to_graph             ~qcut.find_and_place_cuts             ~qcut.replace_wire_cut_nodes   "
    },
    {
      "id": "qml.qcut.qcut_processing_fn_sample",
      "name": "qml.qcut.qcut_processing_fn_sample",
      "type": "function",
      "description": "PennyLane API: qcut.qcut_processing_fn_sample. Found in cutcircuit_mc.html",
      "source_file": "cutcircuit_mc.html",
      "context": "gment_graph             ~qcut.graph_to_tape             ~qcut.expand_fragment_tapes_mc             ~qcut.qcut_processing_fn_sample             ~qcut.qcut_processing_fn_mc          The following shows "
    },
    {
      "id": "qml.qcut.expand_fragment_tapes_mc",
      "name": "qml.qcut.expand_fragment_tapes_mc",
      "type": "function",
      "description": "PennyLane API: qcut.expand_fragment_tapes_mc. Found in cutcircuit_mc.html",
      "source_file": "cutcircuit_mc.html",
      "context": "eplace_wire_cut_nodes             ~qcut.fragment_graph             ~qcut.graph_to_tape             ~qcut.expand_fragment_tapes_mc             ~qcut.qcut_processing_fn_sample             ~qcut.qcut_pro"
    },
    {
      "id": "qml.qcut.qcut_processing_fn_mc",
      "name": "qml.qcut.qcut_processing_fn_mc",
      "type": "function",
      "description": "PennyLane API: qcut.qcut_processing_fn_mc. Found in cutcircuit_mc.html",
      "source_file": "cutcircuit_mc.html",
      "context": "            ~qcut.expand_fragment_tapes_mc             ~qcut.qcut_processing_fn_sample             ~qcut.qcut_processing_fn_mc          The following shows how these elementary steps are combined as p"
    },
    {
      "id": "qml.cut_circuit_mc",
      "name": "qml.cut_circuit_mc",
      "type": "function",
      "description": "PennyLane API: cut_circuit_mc. Found in cutcircuit_mc.html",
      "source_file": "cutcircuit_mc.html",
      "context": "e for the specific language governing permissions and # limitations under the License. \"\"\" Function cut_circuit_mc for cutting a quantum circuit into smaller circuit fragments using a     Monte Carlo "
    },
    {
      "id": "qml.devices.LegacyDevice",
      "name": "qml.devices.LegacyDevice",
      "type": "function",
      "description": "PennyLane API: devices.LegacyDevice. Found in cutstrategy.html",
      "source_file": "cutstrategy.html",
      "context": "\"Argument `devices` must be a list or tuple containing elements of type \"                     \"`qml.devices.LegacyDevice` or `qml.devices.Device`\"                 )              device_wire_sizes = [l"
    },
    {
      "id": "qml.qcut.kahypar_cut",
      "name": "qml.qcut.kahypar_cut",
      "type": "function",
      "description": "PennyLane API: qcut.kahypar_cut. Found in kahypar.html",
      "source_file": "kahypar.html",
      "context": " optimal edges to place cuts:      >>> graph = qml.qcut.tape_to_graph(tape)     >>> cut_edges = qml.qcut.kahypar_cut(     ...     graph=graph,     ...     num_fragments=2,     ... )     >>> cut_edges "
    },
    {
      "id": "qml.qcut.contract_tensors",
      "name": "qml.qcut.contract_tensors",
      "type": "function",
      "description": "PennyLane API: qcut.contract_tensors. Found in processing.html",
      "source_file": "processing.html",
      "context": "), WrappedObj(prep[1][0]))})]         )      The network can then be contracted using:      >>> qml.qcut.contract_tensors(tensors, graph, prep, meas)     38     \"\"\"     # pylint: disable=import-outsid"
    },
    {
      "id": "qml.qcut.PrepareNode",
      "name": "qml.qcut.PrepareNode",
      "type": "function",
      "description": "PennyLane API: qcut.PrepareNode. Found in tapes.html",
      "source_file": "tapes.html",
      "context": "=1),             qml.CNOT(wires=[0, 1]),             qml.qcut.MeasureNode(wires=1),             qml.qcut.PrepareNode(wires=1),             qml.CNOT(wires=[1, 0]),         ]         measurements = [qml"
    },
    {
      "id": "qml.qcut.MeasureNode",
      "name": "qml.qcut.MeasureNode",
      "type": "function",
      "description": "PennyLane API: qcut.MeasureNode. Found in tapes.html",
      "source_file": "tapes.html",
      "context": ".4, wires=0),             qml.RY(0.5, wires=1),             qml.CNOT(wires=[0, 1]),             qml.qcut.MeasureNode(wires=1),             qml.qcut.PrepareNode(wires=1),             qml.CNOT(wires=[1,"
    },
    {
      "id": "qml.qcut.replace_wire_cut_node",
      "name": "qml.qcut.replace_wire_cut_node",
      "type": "function",
      "description": "PennyLane API: qcut.replace_wire_cut_node. Found in utils.html",
      "source_file": "utils.html",
      "context": "ecute the circuit on solely     2-qubit devices. To verify, let's print the fragments:      >>> qml.qcut.replace_wire_cut_nodes(cut_graph)     >>> frags, comm_graph = qml.qcut.fragment_graph(cut_graph"
    },
    {
      "id": "qml.qcut.place_wire_cuts",
      "name": "qml.qcut.place_wire_cuts",
      "type": "function",
      "description": "PennyLane API: qcut.place_wire_cuts. Found in utils.html",
      "source_file": "utils.html",
      "context": "OT(wires=[0, 'a'])), 0)]      Then feed it to this function for placement:      >>> cut_graph = qml.qcut.place_wire_cuts(graph=graph, cut_edges=cut_edges)     >>> cut_graph     <networkx.classes.multi"
    },
    {
      "id": "qml.qnn.TorchLayer",
      "name": "qml.qnn.TorchLayer",
      "type": "function",
      "description": "PennyLane API: qnn.TorchLayer. Found in torch.html",
      "source_file": "torch.html",
      "context": "Torch     layer with:      >>> weight_shapes = {\"weights_0\": 3, \"weight_1\": 1}     >>> qlayer = qml.qnn.TorchLayer(qnode, weight_shapes)      The internal weights of the QNode are automatically initia"
    },
    {
      "id": "qml.templates.BasicEntanglerLayers",
      "name": "qml.templates.BasicEntanglerLayers",
      "type": "function",
      "description": "PennyLane API: templates.BasicEntanglerLayers. Found in torch.html",
      "source_file": "torch.html",
      "context": "       qml.templates.StronglyEntanglingLayers(weights_0, wires=range(n_qubits))                 qml.templates.BasicEntanglerLayers(weights_1, wires=range(n_qubits))                 qml.Rot(*weights_2,"
    },
    {
      "id": "qml.queuing.process_queue",
      "name": "qml.queuing.process_queue",
      "type": "function",
      "description": "PennyLane API: queuing.process_queue. Found in queuing.html",
      "source_file": "queuing.html",
      "context": ")         pow_op = base ** 1.5         qml.expval(qml.Z(0) @ qml.X(1))  >>> ops, measurements = qml.queuing.process_queue(q) >>> ops [StatePrep(array([1., 0.]), wires=[0]), X(0)**1.5] >>> measurements"
    },
    {
      "id": "qml.QueuingManager.active_context",
      "name": "qml.QueuingManager.active_context",
      "type": "class",
      "description": "PennyLane API: QueuingManager.active_context. Found in queuing.html",
      "source_file": "queuing.html",
      "context": " are class methods and properties, so all instances will access the same information.  The :meth:`~.QueuingManager.active_context` is the queue where any new objects are placed. The :class:`~.QueuingM"
    },
    {
      "id": "qml.resource.algo_error",
      "name": "qml.resource.algo_error",
      "type": "function",
      "description": "PennyLane API: resource.algo_error. Found in error.html",
      "source_file": "error.html",
      "context": "      return qml.state()      We can compute the errors using ``algo_error``:      >>> errors = qml.resource.algo_error(circuit)(time=1.0)     >>> print(errors)     {'SpectralNormError': SpectralNormE"
    },
    {
      "id": "qml.workflow.construct_batch",
      "name": "qml.workflow.construct_batch",
      "type": "function",
      "description": "PennyLane API: workflow.construct_batch. Found in error.html",
      "source_file": "error.html",
      "context": "a list of such dictionaries when there are multiple tapes in the batch.     \"\"\"      batch, _ = qml.workflow.construct_batch(qnode, level=level)(*args, **kwargs)      # Compute errors for each tape se"
    },
    {
      "id": "qml.math.svd",
      "name": "qml.math.svd",
      "type": "function",
      "description": "PennyLane API: math.svd. Found in error.html",
      "source_file": "error.html",
      "context": "der)         m2 = qml.matrix(approximate_op, wire_order=wire_order)         return qml.math.max(qml.math.svd(m1 - m2, compute_uv=False))     def _compute_algo_error(tape) -> dict[str, AlgorithmicError"
    },
    {
      "id": "qml.resource.add_in_parallel",
      "name": "qml.resource.add_in_parallel",
      "type": "function",
      "description": "PennyLane API: resource.add_in_parallel. Found in resource.html",
      "source_file": "resource.html",
      "context": "depths of ``r1`` and ``r2``. To add resources as if they were executed     in parallel see :func:`~.resource.add_in_parallel`.      Args:         r1 (Resources): a :class:`~resource.Resources` to add "
    },
    {
      "id": "qml.resource.substitute",
      "name": "qml.resource.substitute",
      "type": "function",
      "description": "PennyLane API: resource.substitute. Found in resource.html",
      "source_file": "resource.html",
      "context": "pth = 7             )           Now we print the result of the substitution.          >>> res = qml.resource.substitute(initial_resources, gate_info, replacement)         >>> print(res)         num_wi"
    },
    {
      "id": "qml.resource.mul_in_series",
      "name": "qml.resource.mul_in_series",
      "type": "function",
      "description": "PennyLane API: resource.mul_in_series. Found in resource.html",
      "source_file": "resource.html",
      "context": "          shots = Shots(10)             )          Now we print the product.          >>> print(qml.resource.mul_in_series(resources, 2))         num_wires: 2         num_gates: 4         depth: 4    "
    },
    {
      "id": "qml.resource.add_in_series",
      "name": "qml.resource.add_in_series",
      "type": "function",
      "description": "PennyLane API: resource.add_in_series. Found in resource.html",
      "source_file": "resource.html",
      "context": "  shots = Shots((5, (2, 10)))             )          Now we print their sum.          >>> print(qml.resource.add_in_series(r1, r2))         num_wires: 3         num_gates: 4         depth: 3         s"
    },
    {
      "id": "qml.resource.mul_in_parallel",
      "name": "qml.resource.mul_in_parallel",
      "type": "function",
      "description": "PennyLane API: resource.mul_in_parallel. Found in resource.html",
      "source_file": "resource.html",
      "context": "ltiplied by     ``scalar``. To multiply as if the circuit was repeated in parallel see     :func:`~.resource.mul_in_parallel`.      Args:         resources (Resources): a :class:`~resource.Resources` "
    },
    {
      "id": "qml.transforms.split_non_commuting",
      "name": "qml.transforms.split_non_commuting",
      "type": "function",
      "description": "PennyLane API: transforms.split_non_commuting. Found in specs.html",
      "source_file": "specs.html",
      "context": ".Z(1), qml.Z(0) @ qml.Y(2)])             gradient_kwargs = {\"shifts\": pnp.pi / 4}              @qml.transforms.split_non_commuting             @qml.qnode(dev, diff_method=\"parameter-shift\", gradient_k"
    },
    {
      "id": "qml.marker",
      "name": "qml.marker",
      "type": "function",
      "description": "PennyLane API: marker. Found in specs.html",
      "source_file": "specs.html",
      "context": "_FILEPATH):             os.remove(_RESOURCE_TRACKING_FILEPATH)   def _preprocess_level_input(level, marker_to_level) -> list[int]:     \"\"\"Preprocesses the level input to always return a sorted list of"
    },
    {
      "id": "qml.marker.tape_transform",
      "name": "qml.marker.tape_transform",
      "type": "function",
      "description": "PennyLane API: marker.tape_transform. Found in specs.html",
      "source_file": "specs.html",
      "context": "level\"]: i + 1         for i, trans in enumerate(trans_prog)         if trans.tape_transform == qml.marker.tape_transform     }     level_to_marker = {v: k for k, v in marker_to_level.items()}      # "
    },
    {
      "id": "qml.ClassicalShadow",
      "name": "qml.ClassicalShadow",
      "type": "class",
      "description": "PennyLane API: ClassicalShadow. Found in classical_shadow.html",
      "source_file": "classical_shadow.html",
      "context": "etters  import numpy as np  import pennylane.ops as qops from pennylane import math    [docs] class ClassicalShadow:     r\"\"\"Class for classical shadow post-processing expectation values, approximate "
    },
    {
      "id": "qml.shadows.shadow_state",
      "name": "qml.shadows.shadow_state",
      "type": "function",
      "description": "PennyLane API: shadows.shadow_state. Found in transforms.html",
      "source_file": "transforms.html",
      "context": "       dev = qml.device(\"default.qubit\", wires=2)          @qml.set_shots(shots=10000)         @qml.shadows.shadow_state(wires=[0, 1], diffable=True)         @qml.qnode(dev)         def circuit(x):   "
    },
    {
      "id": "qml.spin.Lattice",
      "name": "qml.spin.Lattice",
      "type": "function",
      "description": "PennyLane API: spin.Lattice. Found in lattice.html",
      "source_file": "lattice.html",
      "context": "ions under the License. \"\"\" This file contains functions and classes to create a :class:`~pennylane.spin.Lattice` object. This object stores all the necessary information about a lattice. \"\"\" import i"
    },
    {
      "id": "qml.spin.generate_lattice",
      "name": "qml.spin.generate_lattice",
      "type": "function",
      "description": "PennyLane API: spin.generate_lattice. Found in lattice.html",
      "source_file": "lattice.html",
      "context": " 'square'     >>> n_cells = [2, 2]     >>> boundary_condition = [True, False]     >>> lattice = qml.spin.generate_lattice(shape, n_cells, boundary_condition)     >>> lattice.edges     [(2, 3, 0), (0, "
    },
    {
      "id": "qml.spin.kitaev",
      "name": "qml.spin.kitaev",
      "type": "function",
      "description": "PennyLane API: spin.kitaev. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": " **Example**      >>> n_cells = [2, 2]     >>> k = np.array([0.5, 0.6, 0.7])     >>> spin_ham = qml.spin.kitaev(n_cells, coupling=k)     >>> spin_ham     (       0.5 * (X(0) @ X(1))       + 0.5 * (X(2"
    },
    {
      "id": "qml.spin.heisenberg",
      "name": "qml.spin.heisenberg",
      "type": "function",
      "description": "PennyLane API: spin.heisenberg. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": "  **Example**      >>> n_cells = [2,2]     >>> j = np.array([0.5, 0.5, 0.5])     >>> spin_ham = qml.spin.heisenberg(\"square\", n_cells, coupling=j)     >>> spin_ham     (     0.5 * (X(0) @ X(1))     + "
    },
    {
      "id": "qml.spin.emery",
      "name": "qml.spin.emery",
      "type": "function",
      "description": "PennyLane API: spin.emery. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": "ple**      >>> n_cells = [2]     >>> h = 0.5     >>> u = 1.0     >>> v = 0.2     >>> spin_ham = qml.spin.emery(\"chain\", n_cells, hopping=h, coulomb=u, intersite_coupling=v)     >>> spin_ham     (     "
    },
    {
      "id": "qml.spin.transverse_ising",
      "name": "qml.spin.transverse_ising",
      "type": "function",
      "description": "PennyLane API: spin.transverse_ising. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": "l.      **Example**      >>> n_cells = [2,2]     >>> j = 0.5     >>> h = 0.1     >>> spin_ham = qml.spin.transverse_ising(\"square\", n_cells, coupling=j, h=h)     >>> spin_ham     (     -0.5 * (Z(0) @ "
    },
    {
      "id": "qml.spin.fermi_hubbard",
      "name": "qml.spin.fermi_hubbard",
      "type": "function",
      "description": "PennyLane API: spin.fermi_hubbard. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": "del.      **Example**      >>> n_cells = [2]     >>> t = 0.5     >>> u = 1.0     >>> spin_ham = qml.spin.fermi_hubbard(\"chain\", n_cells, hopping=t, coulomb=u)     >>> spin_ham     (         -0.25 * (Y"
    },
    {
      "id": "qml.spin.spin_hamiltonian",
      "name": "qml.spin.spin_hamiltonian",
      "type": "function",
      "description": "PennyLane API: spin.spin_hamiltonian. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": "                                  pennylane.spin.spin_hamiltonian — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.spin.haldane",
      "name": "qml.spin.haldane",
      "type": "function",
      "description": "PennyLane API: spin.haldane. Found in spin_hamiltonian.html",
      "source_file": "spin_hamiltonian.html",
      "context": "*      >>> n_cells = [2]     >>> h1 = 0.5     >>> h2 = 1.0     >>> phi = 0.1     >>> spin_ham = qml.spin.haldane(\"chain\", n_cells, hopping=h1, hopping_next=h2, phi=phi)     >>> spin_ham     (       -0"
    },
    {
      "id": "qml.tape.expand_tape_state_prep",
      "name": "qml.tape.expand_tape_state_prep",
      "type": "function",
      "description": "PennyLane API: tape.expand_tape_state_prep. Found in expand_tape.html",
      "source_file": "expand_tape.html",
      "context": "l.StatePrep([1, 0], wires=0)]     >>> tape = qml.tape.QuantumScript(ops, [])     >>> new_tape = qml.tape.expand_tape_state_prep(tape)     >>> new_tape.operations     [StatePrep(array([0, 1]), wires=[0"
    },
    {
      "id": "qml.tape.plxpr_to_tape",
      "name": "qml.tape.plxpr_to_tape",
      "type": "function",
      "description": "PennyLane API: tape.plxpr_to_tape. Found in plxpr_conversion.html",
      "source_file": "plxpr_conversion.html",
      "context": "(qml.Z(1))          qml.capture.enable()          plxpr = jax.make_jaxpr(f)(0.5)         tape = qml.tape.plxpr_to_tape(plxpr.jaxpr, plxpr.consts, 1.2)         print(qml.drawer.tape_text(tape, decimals"
    },
    {
      "id": "qml.resource.resource.resources_from_tape",
      "name": "qml.resource.resource.resources_from_tape",
      "type": "function",
      "description": "PennyLane API: resource.resource.resources_from_tape. Found in qscript.html",
      "source_file": "qscript.html",
      "context": "           depth=4)         \"\"\"         if self._specs is None:             resources, errors = qml.resource.resource.resources_from_tape(self, compute_errors=True)             self._specs = {\"resourc"
    },
    {
      "id": "qml.tape.expand_tape",
      "name": "qml.tape.expand_tape",
      "type": "function",
      "description": "PennyLane API: tape.expand_tape. Found in qscript.html",
      "source_file": "qscript.html",
      "context": "e).circuit             [H(0), expval(eigvals=[ 1. -1.], wires=[0])]          \"\"\"         return qml.tape.expand_tape(             self, depth=depth, stop_at=stop_at, expand_measurements=expand_measure"
    },
    {
      "id": "qml.CircuitGraph",
      "name": "qml.CircuitGraph",
      "type": "class",
      "description": "PennyLane API: CircuitGraph. Found in qscript.html",
      "source_file": "qscript.html",
      "context": "========================================================      @property     def graph(self) -> \"qml.CircuitGraph\":         \"\"\"Returns a directed acyclic graph representation of the recorded         qu"
    },
    {
      "id": "qml.ops.SymbolicOp",
      "name": "qml.ops.SymbolicOp",
      "type": "function",
      "description": "PennyLane API: ops.SymbolicOp. Found in qscript.html",
      "source_file": "qscript.html",
      "context": "bles):      overlapping_ops_observables = []      while any(isinstance(o, (qml.ops.CompositeOp, qml.ops.SymbolicOp)) for o in observables):          new_obs = []          for observable in observables"
    },
    {
      "id": "qml.transforms.is_mcm",
      "name": "qml.transforms.is_mcm",
      "type": "function",
      "description": "PennyLane API: transforms.is_mcm. Found in tape.html",
      "source_file": "tape.html",
      "context": "ation.\"\"\"      measurements = tape.measurements     n_meas = len(measurements)     n_mcms = sum(qml.transforms.is_mcm(op) for op in tape.operations)     non_comp_basis_sampling_obs = []     comp_basis"
    },
    {
      "id": "qml.pauli.utils.are_pauli_words_qwc",
      "name": "qml.pauli.utils.are_pauli_words_qwc",
      "type": "function",
      "description": "PennyLane API: pauli.utils.are_pauli_words_qwc. Found in tape.html",
      "source_file": "tape.html",
      "context": "g., qml.probs(wires=wires) case by checking obs attr             if obs.obs is not None and not qml.pauli.utils.are_pauli_words_qwc(                 [obs.obs, pauliz_for_cb_obs]             ):        "
    },
    {
      "id": "qml.AmplitudeEmbedding",
      "name": "qml.AmplitudeEmbedding",
      "type": "class",
      "description": "PennyLane API: AmplitudeEmbedding. Found in amplitude.html",
      "source_file": "amplitude.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the AmplitudeEmbedding template. \"\"\" from pennylane.decomposition import add_decomps from pennylane.ops "
    },
    {
      "id": "qml.AngleEmbedding.compute_decomposition",
      "name": "qml.AngleEmbedding.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: AngleEmbedding.compute_decomposition. Found in angle.html",
      "source_file": "angle.html",
      "context": "of the operator          **Example**          >>> features = torch.tensor([1., 2.])         >>> qml.AngleEmbedding.compute_decomposition(features, wires=[\"a\", \"b\"], rotation=qml.RX)         [RX(tensor"
    },
    {
      "id": "qml.BasisEmbedding",
      "name": "qml.BasisEmbedding",
      "type": "class",
      "description": "PennyLane API: BasisEmbedding. Found in basis.html",
      "source_file": "basis.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the BasisEmbedding template. \"\"\"  from pennylane.decomposition import add_decomps from pennylane.ops.qub"
    },
    {
      "id": "qml.DisplacementEmbedding.compute_decomposition",
      "name": "qml.DisplacementEmbedding.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: DisplacementEmbedding.compute_decomposition. Found in displacement.html",
      "source_file": "displacement.html",
      "context": "perator          **Example**          >>> pars = torch.tensor([[1., 0.], [2., 0.]])         >>> qml.DisplacementEmbedding.compute_decomposition(pars, wires=[0, 1])         [Displacement(tensor(1.), te"
    },
    {
      "id": "qml.QuadraticPhase",
      "name": "qml.QuadraticPhase",
      "type": "class",
      "description": "PennyLane API: QuadraticPhase. Found in displacement.html",
      "source_file": "displacement.html",
      "context": "             qml.DisplacementEmbedding(features=feature_vector, wires=range(3))                 qml.QuadraticPhase(0.1, wires=1)                 return qml.expval(qml.NumberOperator(wires=1))         "
    },
    {
      "id": "qml.DisplacementEmbedding",
      "name": "qml.DisplacementEmbedding",
      "type": "class",
      "description": "PennyLane API: DisplacementEmbedding. Found in displacement.html",
      "source_file": "displacement.html",
      "context": "he specific language governing permissions and # limitations under the License. r\"\"\" Contains the ``DisplacementEmbedding`` template. \"\"\" from pennylane import math from pennylane.operation import Ope"
    },
    {
      "id": "qml.IQPEmbedding",
      "name": "qml.IQPEmbedding",
      "type": "class",
      "description": "PennyLane API: IQPEmbedding. Found in iqp.html",
      "source_file": "iqp.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the IQPEmbedding template. \"\"\" # pylint: disable=too-many-arguments import copy from itertools import co"
    },
    {
      "id": "qml.IQPEmbedding.compute_decomposition",
      "name": "qml.IQPEmbedding.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: IQPEmbedding.compute_decomposition. Found in iqp.html",
      "source_file": "iqp.html",
      "context": "eatures = torch.tensor([1., 2., 3.])         >>> pattern = [(0, 1), (0, 2), (1, 2)]         >>> qml.IQPEmbedding.compute_decomposition(features, wires=[0, 1, 2], n_repeats=2, pattern=pattern)         "
    },
    {
      "id": "qml.QAOAEmbedding.shape",
      "name": "qml.QAOAEmbedding.shape",
      "type": "class",
      "description": "PennyLane API: QAOAEmbedding.shape. Found in qaoaembedding.html",
      "source_file": "qaoaembedding.html",
      "context": "**          The shape of the weights argument can be computed by the static method         :meth:`~.QAOAEmbedding.shape` and used when creating randomly         initialised weight tensors:          .."
    },
    {
      "id": "qml.QAOAEmbedding.compute_decomposition",
      "name": "qml.QAOAEmbedding.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QAOAEmbedding.compute_decomposition. Found in qaoaembedding.html",
      "source_file": "qaoaembedding.html",
      "context": "[1., 2.])         >>> weights = torch.tensor([[0.1, -0.3, 1.3], [0.9, -0.2, -2.1]])         >>> qml.QAOAEmbedding.compute_decomposition(features, weights, wires=[\"a\", \"b\"], local_field=qml.RY)        "
    },
    {
      "id": "qml.QAOAEmbedding",
      "name": "qml.QAOAEmbedding",
      "type": "class",
      "description": "PennyLane API: QAOAEmbedding. Found in qaoaembedding.html",
      "source_file": "qaoaembedding.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the QAOAEmbedding template. \"\"\" from collections import defaultdict  from pennylane import capture, math"
    },
    {
      "id": "qml.GradientDescentOptimizer",
      "name": "qml.GradientDescentOptimizer",
      "type": "class",
      "description": "PennyLane API: GradientDescentOptimizer. Found in qaoaembedding.html",
      "source_file": "qaoaembedding.html",
      "context": "e the PauliZ expectation of the first qubit:          .. code-block:: python              opt = qml.GradientDescentOptimizer()             for i in range(10):                 weights = opt.step(lambda"
    },
    {
      "id": "qml.SqueezingEmbedding.compute_decomposition",
      "name": "qml.SqueezingEmbedding.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SqueezingEmbedding.compute_decomposition. Found in squeezing.html",
      "source_file": "squeezing.html",
      "context": "perator          **Example**          >>> pars = torch.tensor([[1., 0.], [2., 0.]])         >>> qml.SqueezingEmbedding.compute_decomposition(pars, wires=[\"a\", \"b\"])         [Squeezing(tensor(1.), tens"
    },
    {
      "id": "qml.SqueezingEmbedding",
      "name": "qml.SqueezingEmbedding",
      "type": "class",
      "description": "PennyLane API: SqueezingEmbedding. Found in squeezing.html",
      "source_file": "squeezing.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the SqueezingEmbedding template. \"\"\" from pennylane import math  # pylint: disable=too-many-arguments fr"
    },
    {
      "id": "qml.layer",
      "name": "qml.layer",
      "type": "function",
      "description": "PennyLane API: layer. Found in layer.html",
      "source_file": "layer.html",
      "context": "                                  pennylane.templates.layer — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.BasicEntanglerLayers.shape",
      "name": "qml.BasicEntanglerLayers.shape",
      "type": "class",
      "description": "PennyLane API: BasicEntanglerLayers.shape. Found in basic_entangler.html",
      "source_file": "basic_entangler.html",
      "context": "**          The shape of the weights argument can be computed by the static method         :meth:`~.BasicEntanglerLayers.shape` and used when creating randomly         initialised weight tensors:     "
    },
    {
      "id": "qml.BasicEntanglerLayers.compute_decomposition",
      "name": "qml.BasicEntanglerLayers.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: BasicEntanglerLayers.compute_decomposition. Found in basic_entangler.html",
      "source_file": "basic_entangler.html",
      "context": "        **Example**          >>> weights = torch.tensor([[1.2, -0.4], [0.3, -0.2]])         >>> qml.BasicEntanglerLayers.compute_decomposition(weights, wires=[\"a\", \"b\"], rotation=qml.RX)         [RX(t"
    },
    {
      "id": "qml.CVNeuralNetLayers.compute_decomposition",
      "name": "qml.CVNeuralNetLayers.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: CVNeuralNetLayers.compute_decomposition. Found in cv_neural_net.html",
      "source_file": "cv_neural_net.html",
      "context": " >>> phi_a = torch.tensor([[-1.1, 0.2]])         >>> k = torch.tensor([[0.1, 0.2]])         >>> qml.CVNeuralNetLayers.compute_decomposition(theta_1, phi_1, varphi_1, r, phi_r, theta_2,         ...    "
    },
    {
      "id": "qml.GateFabric.compute_decomposition",
      "name": "qml.GateFabric.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: GateFabric.compute_decomposition. Found in gate_fabric.html",
      "source_file": "gate_fabric.html",
      "context": "he operator          **Example**          >>> weights = torch.tensor([[[0.3, 1.]]])         >>> qml.GateFabric.compute_decomposition(weights, wires=[\"a\", \"b\", \"c\", \"d\"], init_state=[0, 1, 0, 1], inclu"
    },
    {
      "id": "qml.GateFabric.shape",
      "name": "qml.GateFabric.shape",
      "type": "class",
      "description": "PennyLane API: GateFabric.shape. Found in gate_fabric.html",
      "source_file": "gate_fabric.html",
      "context": "    # Get the shape of the weights for this template             layers = 2             shape = qml.GateFabric.shape(n_layers=layers, n_wires=qubits)              # Initialize the weight tensors      "
    },
    {
      "id": "qml.GateFabric",
      "name": "qml.GateFabric",
      "type": "class",
      "description": "PennyLane API: GateFabric. Found in gate_fabric.html",
      "source_file": "gate_fabric.html",
      "context": "erning permissions and # limitations under the License. r\"\"\" Contains the quantum-number-preserving GateFabric template. \"\"\" # pylint: disable=too-many-arguments import numpy as np  from pennylane imp"
    },
    {
      "id": "qml.ParticleConservingU1",
      "name": "qml.ParticleConservingU1",
      "type": "class",
      "description": "PennyLane API: ParticleConservingU1. Found in particle_conserving_u1.html",
      "source_file": "particle_conserving_u1.html",
      "context": "age governing permissions and # limitations under the License. r\"\"\" Contains the hardware-efficient ParticleConservingU1 template. \"\"\" import numpy as np  from pennylane import capture, math from penn"
    },
    {
      "id": "qml.ParticleConservingU1.compute_decomposition",
      "name": "qml.ParticleConservingU1.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ParticleConservingU1.compute_decomposition. Found in particle_conserving_u1.html",
      "source_file": "particle_conserving_u1.html",
      "context": "rator          **Example**          >>> weights = torch.tensor([[[0.3, 1.]]])         >>> ops = qml.ParticleConservingU1.compute_decomposition(weights, wires=[\"a\", \"b\"], init_state=[0, 1])         >>>"
    },
    {
      "id": "qml.ParticleConservingU1.shape",
      "name": "qml.ParticleConservingU1.shape",
      "type": "class",
      "description": "PennyLane API: ParticleConservingU1.shape. Found in particle_conserving_u1.html",
      "source_file": "particle_conserving_u1.html",
      "context": "              # Compute the expectation value of 'h'             layers = 2             shape = qml.ParticleConservingU1.shape(layers, qubits)             params = np.random.random(shape)             "
    },
    {
      "id": "qml.ParticleConservingU2",
      "name": "qml.ParticleConservingU2",
      "type": "class",
      "description": "PennyLane API: ParticleConservingU2. Found in particle_conserving_u2.html",
      "source_file": "particle_conserving_u2.html",
      "context": "age governing permissions and # limitations under the License. r\"\"\" Contains the hardware-efficient ParticleConservingU2 template. \"\"\" from pennylane import capture, math from pennylane.control_flow i"
    },
    {
      "id": "qml.ParticleConservingU2.shape",
      "name": "qml.ParticleConservingU2.shape",
      "type": "class",
      "description": "PennyLane API: ParticleConservingU2.shape. Found in particle_conserving_u2.html",
      "source_file": "particle_conserving_u2.html",
      "context": "pectation value of 'h' for a given set of parameters             layers = 1             shape = qml.ParticleConservingU2.shape(layers, qubits)             params = np.random.random(shape)             "
    },
    {
      "id": "qml.ParticleConservingU2.compute_decomposition",
      "name": "qml.ParticleConservingU2.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ParticleConservingU2.compute_decomposition. Found in particle_conserving_u2.html",
      "source_file": "particle_conserving_u2.html",
      "context": "or          **Example**          >>> weights = torch.tensor([[0.3, 1., 0.2]])         >>> ops = qml.ParticleConservingU2.compute_decomposition(weights, wires=[\"a\", \"b\"], init_state=[0, 1])         >>>"
    },
    {
      "id": "qml.RandomLayers.shape",
      "name": "qml.RandomLayers.shape",
      "type": "class",
      "description": "PennyLane API: RandomLayers.shape. Found in random.html",
      "source_file": "random.html",
      "context": "   The expected shape for the weight tensor can be computed with the static method         :meth:`~.RandomLayers.shape` and used when creating randomly         initialised weight tensors:          .. "
    },
    {
      "id": "qml.RandomLayers.compute_decomposition",
      "name": "qml.RandomLayers.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: RandomLayers.compute_decomposition. Found in random.html",
      "source_file": "random.html",
      "context": "hts = torch.tensor([[0.1, -2.1, 1.4]])         >>> rotations=[qml.RY, qml.RX]         >>> ops = qml.RandomLayers.compute_decomposition(weights, wires=[\"a\", \"b\"], ratio_imprim=0.3,         ...         "
    },
    {
      "id": "qml.SimplifiedTwoDesign.compute_decomposition",
      "name": "qml.SimplifiedTwoDesign.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: SimplifiedTwoDesign.compute_decomposition. Found in simplified_two_design.html",
      "source_file": "simplified_two_design.html",
      "context": "   [pi, 0.]]         >>> weights = np.array([weights_layer1, weights_layer2])         >>> ops = qml.SimplifiedTwoDesign.compute_decomposition(init_weights, weights, wires=[\"a\", \"b\", \"c\"])         >>> "
    },
    {
      "id": "qml.ops.CZ",
      "name": "qml.ops.CZ",
      "type": "function",
      "description": "PennyLane API: ops.CZ. Found in strongly_entangling.html",
      "source_file": "strongly_entangling.html",
      "context": "    qml.StronglyEntanglingLayers(weights=parameters, wires=range(4), ranges=[2, 3], imprimitive=qml.ops.CZ)                 return qml.expval(qml.Z(0))              shape = qml.StronglyEntanglingLayer"
    },
    {
      "id": "qml.StronglyEntanglingLayers.compute_decomposition",
      "name": "qml.StronglyEntanglingLayers.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: StronglyEntanglingLayers.compute_decomposition. Found in strongly_entangling.html",
      "source_file": "strongly_entangling.html",
      "context": "rch.tensor([[[-0.2, 0.1, -0.4], [1.2, -2., -0.4]]])         >>> ranges = (1,)         >>> ops = qml.StronglyEntanglingLayers.compute_decomposition(weights, wires=[\"a\", \"b\"], ranges=ranges, imprimitive"
    },
    {
      "id": "qml.ArbitraryStatePreparation",
      "name": "qml.ArbitraryStatePreparation",
      "type": "class",
      "description": "PennyLane API: ArbitraryStatePreparation. Found in arbitrary_state_preparation.html",
      "source_file": "arbitrary_state_preparation.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the ArbitraryStatePreparation template. \"\"\"  import functools from collections import Counter  import pe"
    },
    {
      "id": "qml.ArbitraryStatePreparation.shape",
      "name": "qml.ArbitraryStatePreparation.shape",
      "type": "class",
      "description": "PennyLane API: ArbitraryStatePreparation.shape. Found in arbitrary_state_preparation.html",
      "source_file": "arbitrary_state_preparation.html",
      "context": " the weights parameter can be computed as follows:      .. code-block:: python          shape = qml.ArbitraryStatePreparation.shape(n_wires=4)      \"\"\"      grad_method = None      resource_keys = {\"n"
    },
    {
      "id": "qml.ArbitraryStatePreparation.compute_decomposition",
      "name": "qml.ArbitraryStatePreparation.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ArbitraryStatePreparation.compute_decomposition. Found in arbitrary_state_preparation.html",
      "source_file": "arbitrary_state_preparation.html",
      "context": "    **Example**          >>> weights = torch.tensor([1., 2., 3., 4., 5., 6.])         >>> ops = qml.ArbitraryStatePreparation.compute_decomposition(weights, wires=[\"a\", \"b\"])         >>> from pprint i"
    },
    {
      "id": "qml.THermitian",
      "name": "qml.THermitian",
      "type": "class",
      "description": "PennyLane API: THermitian. Found in basis_qutrit.html",
      "source_file": "basis_qutrit.html",
      "context": "    qml.QutritBasisStatePreparation(basis_state, wires=range(4))             return [qml.expval(qml.THermitian(obs, wires=i)) for i in range(4)]          basis_state = [0, 1, 1, 0]         obs = np.ar"
    },
    {
      "id": "qml.QutritBasisStatePreparation.compute_decomposition",
      "name": "qml.QutritBasisStatePreparation.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QutritBasisStatePreparation.compute_decomposition. Found in basis_qutrit.html",
      "source_file": "basis_qutrit.html",
      "context": "s:             list[.Operator]: decomposition of the operator          **Example**          >>> qml.QutritBasisStatePreparation.compute_decomposition(basis_state=[1, 2], wires=[\"a\", \"b\"])         [TSh"
    },
    {
      "id": "qml.QutritBasisStatePreparation",
      "name": "qml.QutritBasisStatePreparation",
      "type": "class",
      "description": "PennyLane API: QutritBasisStatePreparation. Found in basis_qutrit.html",
      "source_file": "basis_qutrit.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the QutritBasisStatePreparation template. \"\"\"  import numpy as np  import pennylane as qml from pennylan"
    },
    {
      "id": "qml.CosineWindow",
      "name": "qml.CosineWindow",
      "type": "class",
      "description": "PennyLane API: CosineWindow. Found in cosine_window.html",
      "source_file": "cosine_window.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the CosineWindow template. \"\"\" import numpy as np  import pennylane as qml from pennylane import capture"
    },
    {
      "id": "qml.MottonenStatePreparation.compute_decomposition",
      "name": "qml.MottonenStatePreparation.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: MottonenStatePreparation.compute_decomposition. Found in mottonen.html",
      "source_file": "mottonen.html",
      "context": "   **Example**          >>> state_vector = torch.tensor([0.5, 0.5, 0.5, 0.5])         >>> ops = qml.MottonenStatePreparation.compute_decomposition(state_vector, wires=[\"a\", \"b\"])         >>> from ppri"
    },
    {
      "id": "qml.MultiplexerStatePreparation",
      "name": "qml.MultiplexerStatePreparation",
      "type": "class",
      "description": "PennyLane API: MultiplexerStatePreparation. Found in multiplexer_state_prep.html",
      "source_file": "multiplexer_state_prep.html",
      "context": "r the specific language governing permissions and # limitations under the License. r\"\"\"Contains the MultiplexerStatePreparation template.\"\"\"  import numpy as np  import pennylane as qml from pennylane"
    },
    {
      "id": "qml.QROMStatePreparation",
      "name": "qml.QROMStatePreparation",
      "type": "class",
      "description": "PennyLane API: QROMStatePreparation. Found in qrom_state_prep.html",
      "source_file": "qrom_state_prep.html",
      "context": "r the specific language governing permissions and # limitations under the License. r\"\"\"Contains the QROMStatePreparation template.\"\"\"  import numpy as np  import pennylane as qml from pennylane.operat"
    },
    {
      "id": "qml.math.sign",
      "name": "qml.math.sign",
      "type": "function",
      "description": "PennyLane API: math.sign. Found in state_prep_mps.html",
      "source_file": "state_prep_mps.html",
      "context": ", R = qml.math.linalg.qr(qml.math.hstack([vectors, new_columns]))             unitary_matrix *= qml.math.sign(                 qml.math.diag(R)             )  # Enforce uniqueness for QR decomposition"
    },
    {
      "id": "qml.math.linalg.svd",
      "name": "qml.math.linalg.svd",
      "type": "function",
      "description": "PennyLane API: math.linalg.svd. Found in state_prep_mps.html",
      "source_file": "state_prep_mps.html",
      "context": "  input_matrix = mps[i].reshape(chi_left, d * chi_right)          u_matrix, s_diag, vd_matrix = qml.math.linalg.svd(input_matrix, full_matrices=False)          # Truncate SVD components if needed     "
    },
    {
      "id": "qml.right_canonicalize_mps",
      "name": "qml.right_canonicalize_mps",
      "type": "function",
      "description": "PennyLane API: right_canonicalize_mps. Found in state_prep_mps.html",
      "source_file": "state_prep_mps.html",
      "context": "atch: the last tensor's first dimension does not match the previous third dimension.\"    [docs] def right_canonicalize_mps(mps):     r\"\"\"Transform a matrix product state (MPS) into its right-canonical"
    },
    {
      "id": "qml.MPSPrep",
      "name": "qml.MPSPrep",
      "type": "class",
      "description": "PennyLane API: MPSPrep. Found in state_prep_mps.html",
      "source_file": "state_prep_mps.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the MPSPrep template. \"\"\" import numpy as np  import pennylane as qml from pennylane.decomposition impor"
    },
    {
      "id": "qml.math.linalg.qr",
      "name": "qml.math.linalg.qr",
      "type": "function",
      "description": "PennyLane API: math.linalg.qr. Found in state_prep_mps.html",
      "source_file": "state_prep_mps.html",
      "context": " = qml.math.array(np.random.RandomState(42).random((d, d - k)))             unitary_matrix, R = qml.math.linalg.qr(qml.math.hstack([vectors, new_columns]))             unitary_matrix *= qml.math.sign("
    },
    {
      "id": "qml.math.unique",
      "name": "qml.math.unique",
      "type": "function",
      "description": "PennyLane API: math.unique. Found in superposition.html",
      "source_file": "superposition.html",
      "context": "        raise ValueError(\"The input superposition must be normalized.\")          unique_basis = qml.math.unique(qml.math.array([tuple(b) for b in bases]), axis=0)          if len(unique_basis) != len("
    },
    {
      "id": "qml.Superposition",
      "name": "qml.Superposition",
      "type": "class",
      "description": "PennyLane API: Superposition. Found in superposition.html",
      "source_file": "superposition.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the Superposition template. \"\"\" from collections import Counter from functools import reduce  import pen"
    },
    {
      "id": "qml.AmplitudeAmplification",
      "name": "qml.AmplitudeAmplification",
      "type": "class",
      "description": "PennyLane API: AmplitudeAmplification. Found in amplitude_amplification.html",
      "source_file": "amplitude_amplification.html",
      "context": "j in range(1, iters // 2 + 1)]     return alphas[: iters // 2], betas[: iters // 2]    [docs] class AmplitudeAmplification(Operation):     r\"\"\"Applies amplitude amplification.      Given a state :math"
    },
    {
      "id": "qml.FlipSign",
      "name": "qml.FlipSign",
      "type": "class",
      "description": "PennyLane API: FlipSign. Found in amplitude_amplification.html",
      "source_file": "amplitude_amplification.html",
      "context": "es:                 qml.Hadamard(wires=wire)          U = generator(wires=range(3))         O = qml.FlipSign(2, wires=range(3))          dev = qml.device(\"default.qubit\")          @qml.qnode(dev)     "
    },
    {
      "id": "qml.AQFT.compute_decomposition",
      "name": "qml.AQFT.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: AQFT.compute_decomposition. Found in aqft.html",
      "source_file": "aqft.html",
      "context": "s:             list[Operator]: decomposition of the operator          **Example:**          >>> qml.AQFT.compute_decomposition((0, 1, 2), order=1)         [H(0), ControlledPhaseShift(1.57..., wires=Wi"
    },
    {
      "id": "qml.AQFT",
      "name": "qml.AQFT",
      "type": "class",
      "description": "PennyLane API: AQFT. Found in aqft.html",
      "source_file": "aqft.html",
      "context": "rning permissions and # limitations under the License. \"\"\" This submodule contains the template for AQFT. \"\"\"  import warnings  import numpy as np  from pennylane import capture, math from pennylane.c"
    },
    {
      "id": "qml.Adder",
      "name": "qml.Adder",
      "type": "class",
      "description": "PennyLane API: Adder. Found in adder.html",
      "source_file": "adder.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the Adder template. \"\"\" from pennylane.decomposition import (     add_decomps,     change_op_basis_resou"
    },
    {
      "id": "qml.Adder.compute_decomposition",
      "name": "qml.Adder.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Adder.compute_decomposition. Found in adder.html",
      "source_file": "adder.html",
      "context": "s:             list[.Operator]: Decomposition of the operator          **Example**          >>> qml.Adder.compute_decomposition(k=2, x_wires=[0,1,2], mod=8, work_wires=[3])         [(Adjoint(QFT(wires"
    },
    {
      "id": "qml.ModExp",
      "name": "qml.ModExp",
      "type": "class",
      "description": "PennyLane API: ModExp. Found in mod_exp.html",
      "source_file": "mod_exp.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the ModExp template. \"\"\" import numpy as np  from pennylane.decomposition import add_decomps, register_r"
    },
    {
      "id": "qml.ModExp.compute_decomposition",
      "name": "qml.ModExp.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ModExp.compute_decomposition. Found in mod_exp.html",
      "source_file": "mod_exp.html",
      "context": "s:             list[.Operator]: Decomposition of the operator          **Example**          >>> qml.ModExp.compute_decomposition(x_wires=[0,1], output_wires=[2,3,4], base=3, mod=8, work_wires=[5,6,7,8"
    },
    {
      "id": "qml.Multiplier.compute_decomposition",
      "name": "qml.Multiplier.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Multiplier.compute_decomposition. Found in multiplier.html",
      "source_file": "multiplier.html",
      "context": "         list[.Operator]: Decomposition of the operator          **Example**          >>> ops = qml.Multiplier.compute_decomposition(k=3, mod=8, x_wires=[0,1,2], work_wires=[3,4,5])         >>> from p"
    },
    {
      "id": "qml.Multiplier",
      "name": "qml.Multiplier",
      "type": "class",
      "description": "PennyLane API: Multiplier. Found in multiplier.html",
      "source_file": "multiplier.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the Multiplier template. \"\"\"  import numpy as np  from pennylane.decomposition import (     add_decomps,"
    },
    {
      "id": "qml.OutAdder",
      "name": "qml.OutAdder",
      "type": "class",
      "description": "PennyLane API: OutAdder. Found in out_adder.html",
      "source_file": "out_adder.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the OutAdder template. \"\"\" from collections import defaultdict  from pennylane.decomposition import (   "
    },
    {
      "id": "qml.OutAdder.compute_decomposition",
      "name": "qml.OutAdder.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: OutAdder.compute_decomposition. Found in out_adder.html",
      "source_file": "out_adder.html",
      "context": "         list[.Operator]: Decomposition of the operator          **Example**          >>> ops = qml.OutAdder.compute_decomposition(x_wires=[0,1], y_wires=[2,3], output_wires=[5,6], mod=4, work_wires=["
    },
    {
      "id": "qml.OutMultiplier",
      "name": "qml.OutMultiplier",
      "type": "class",
      "description": "PennyLane API: OutMultiplier. Found in out_multiplier.html",
      "source_file": "out_multiplier.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the OutMultiplier template. \"\"\" from pennylane.decomposition import (     add_decomps,     change_op_bas"
    },
    {
      "id": "qml.OutMultiplier.compute_decomposition",
      "name": "qml.OutMultiplier.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: OutMultiplier.compute_decomposition. Found in out_multiplier.html",
      "source_file": "out_multiplier.html",
      "context": "s:             list[.Operator]: Decomposition of the operator          **Example**          >>> qml.OutMultiplier.compute_decomposition(x_wires=[0,1], y_wires=[2,3], output_wires=[5,6], mod=4, work_wi"
    },
    {
      "id": "qml.OutPoly",
      "name": "qml.OutPoly",
      "type": "class",
      "description": "PennyLane API: OutPoly. Found in out_poly.html",
      "source_file": "out_poly.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the OutPoly template. \"\"\" from collections import Counter  from pennylane import math from pennylane.dec"
    },
    {
      "id": "qml.OutPoly.compute_decomposition",
      "name": "qml.OutPoly.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: OutPoly.compute_decomposition. Found in out_poly.html",
      "source_file": "out_poly.html",
      "context": "le:**          .. code-block:: python              from pprint import pprint              ops = qml.OutPoly.compute_decomposition(                 lambda x, y: x + y,                 input_registers=["
    },
    {
      "id": "qml.PhaseAdder.compute_decomposition",
      "name": "qml.PhaseAdder.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: PhaseAdder.compute_decomposition. Found in phase_adder.html",
      "source_file": "phase_adder.html",
      "context": "s:             list[.Operator]: Decomposition of the operator          **Example**          >>> qml.PhaseAdder.compute_decomposition(k = 2, x_wires = [0, 1, 2], mod = 8, work_wire = ())         [Phase"
    },
    {
      "id": "qml.TemporaryAND.compute_matrix",
      "name": "qml.TemporaryAND.compute_matrix",
      "type": "class",
      "description": "PennyLane API: TemporaryAND.compute_matrix. Found in temporary_and.html",
      "source_file": "temporary_and.html",
      "context": "order.          Returns:             array_like: matrix          **Example**          >>> print(qml.TemporaryAND.compute_matrix(control_values = (1,1)))         [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0"
    },
    {
      "id": "qml.ControlledSequence",
      "name": "qml.ControlledSequence",
      "type": "class",
      "description": "PennyLane API: ControlledSequence. Found in controlled_sequence.html",
      "source_file": "controlled_sequence.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the ControlledSequence template. \"\"\" from copy import copy  from pennylane.control_flow import for_loop "
    },
    {
      "id": "qml.FABLE",
      "name": "qml.FABLE",
      "type": "class",
      "description": "PennyLane API: FABLE. Found in fable.html",
      "source_file": "fable.html",
      "context": "s under the License. \"\"\" This module contains the template for the Fast Approximate BLock Encoding (FABLE) technique. \"\"\" # pylint: disable=no-value-for-parameter import warnings from collections impo"
    },
    {
      "id": "qml.poly_to_angles",
      "name": "qml.poly_to_angles",
      "type": "function",
      "description": "PennyLane API: poly_to_angles. Found in gqsp.html",
      "source_file": "gqsp.html",
      "context": "]): control qubit used to encode the polynomial transformation      .. note::         The  :func:`~.poly_to_angles` function can be used to calculate the angles for a given polynomial.      Example:  "
    },
    {
      "id": "qml.GQSP",
      "name": "qml.GQSP",
      "type": "class",
      "description": "PennyLane API: GQSP. Found in gqsp.html",
      "source_file": "gqsp.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the GQSP template. \"\"\"  import copy  from pennylane import capture, ops from pennylane.decomposition imp"
    },
    {
      "id": "qml.templates.GroverOperator",
      "name": "qml.templates.GroverOperator",
      "type": "function",
      "description": "PennyLane API: templates.GroverOperator. Found in grover.html",
      "source_file": "grover.html",
      "context": "ard(wire)              for _ in range(num_iterations):                 oracle()                 qml.templates.GroverOperator(wires=wires)             return qml.probs(wires)      >>> GroverSearch(num_"
    },
    {
      "id": "qml.apply.",
      "name": "qml.apply.",
      "type": "function",
      "description": "PennyLane API: apply.. Found in hilbert_schmidt.html",
      "source_file": "hilbert_schmidt.html",
      "context": "ops:             # The operation has been defined outside of this function, to queue it we call qml.apply.             if QueuingManager.recording():                 apply(op_u)             decomp_ops"
    },
    {
      "id": "qml.LocalHilbertSchmidt",
      "name": "qml.LocalHilbertSchmidt",
      "type": "class",
      "description": "PennyLane API: LocalHilbertSchmidt. Found in hilbert_schmidt.html",
      "source_file": "hilbert_schmidt.html",
      "context": "mpiling.     `arxiv/1807.00800 <https://arxiv.org/pdf/1807.00800.pdf>`_      .. seealso:: :class:`~.LocalHilbertSchmidt`      .. details::         :title: Usage Details          Consider that we want "
    },
    {
      "id": "qml.Interferometer",
      "name": "qml.Interferometer",
      "type": "class",
      "description": "PennyLane API: Interferometer. Found in interferometer.html",
      "source_file": "interferometer.html",
      "context": "he specific language governing permissions and # limitations under the License. r\"\"\" Contains the ``Interferometer`` template. \"\"\" from itertools import product  from pennylane import math from pennyl"
    },
    {
      "id": "qml.IQP",
      "name": "qml.IQP",
      "type": "class",
      "description": "PennyLane API: IQP. Found in iqp.html",
      "source_file": "iqp.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the IQP template. \"\"\" from collections import defaultdict from functools import reduce  import numpy as "
    },
    {
      "id": "qml.templates.Permute",
      "name": "qml.templates.Permute",
      "type": "function",
      "description": "PennyLane API: templates.Permute. Found in permute.html",
      "source_file": "permute.html",
      "context": "_perm():             # Send contents of wire 4 to wire 0, of wire 2 to wire 1, etc.             qml.templates.Permute([4, 2, 0, 1, 3], wires=dev.wires)             return qml.expval(qml.Z(0))      See"
    },
    {
      "id": "qml.PrepSelPrep",
      "name": "qml.PrepSelPrep",
      "type": "class",
      "description": "PennyLane API: PrepSelPrep. Found in prepselprep.html",
      "source_file": "prepselprep.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the PrepSelPrep template. \"\"\"  # pylint: disable=arguments-differ import copy  from pennylane import mat"
    },
    {
      "id": "qml.templates.AllSinglesDoubles",
      "name": "qml.templates.AllSinglesDoubles",
      "type": "function",
      "description": "PennyLane API: templates.AllSinglesDoubles. Found in all_singles_doubles.html",
      "source_file": "all_singles_doubles.html",
      "context": "  @qml.qnode(dev)             def circuit(weights, hf_state, singles, doubles):                 qml.templates.AllSinglesDoubles(weights, wires, hf_state, singles, doubles)                 return qml.e"
    },
    {
      "id": "qml.BasisRotation",
      "name": "qml.BasisRotation",
      "type": "class",
      "description": "PennyLane API: BasisRotation. Found in basis_rotation.html",
      "source_file": "basis_rotation.html",
      "context": "rminant to be 1     and queue a phase shift that is equivalent to this adjustment in the context of BasisRotation.      Args:         matrix (array): orthogonal matrix to adjust the determinant of.   "
    },
    {
      "id": "qml.FermionicDoubleExcitation",
      "name": "qml.FermionicDoubleExcitation",
      "type": "class",
      "description": "PennyLane API: FermionicDoubleExcitation. Found in fermionic_double_excitation.html",
      "source_file": "fermionic_double_excitation.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the FermionicDoubleExcitation template. \"\"\" # pylint: disable=too-many-arguments,protected-access import"
    },
    {
      "id": "qml.FermionicSingleExcitation",
      "name": "qml.FermionicSingleExcitation",
      "type": "class",
      "description": "PennyLane API: FermionicSingleExcitation. Found in fermionic_single_excitation.html",
      "source_file": "fermionic_single_excitation.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the FermionicSingleExcitation template. \"\"\"  import numpy as np  from pennylane import capture, math fro"
    },
    {
      "id": "qml.kUpCCGSD.shape",
      "name": "qml.kUpCCGSD.shape",
      "type": "function",
      "description": "PennyLane API: kUpCCGSD.shape. Found in kupccgsd.html",
      "source_file": "kupccgsd.html",
      "context": "    # Get the shape of the weights for this template             layers = 1             shape = qml.kUpCCGSD.shape(k=layers,                                 n_wires=wires, delta_sz=0)              # I"
    },
    {
      "id": "qml.kUpCCGSD",
      "name": "qml.kUpCCGSD",
      "type": "function",
      "description": "PennyLane API: kUpCCGSD. Found in kupccgsd.html",
      "source_file": "kupccgsd.html",
      "context": "        if p != r  # remove redundant terms     ]     return pair_gen_doubles_wires    [docs] class kUpCCGSD(Operation):     r\"\"\"Implements the k-Unitary Pair Coupled-Cluster Generalized Singles and D"
    },
    {
      "id": "qml.qchem.excitations_to_wires",
      "name": "qml.qchem.excitations_to_wires",
      "type": "function",
      "description": "PennyLane API: qchem.excitations_to_wires. Found in uccsd.html",
      "source_file": "uccsd.html",
      "context": "    # Map excitations to the wires the UCCSD circuit will act on             s_wires, d_wires = qml.qchem.excitations_to_wires(singles, doubles)              # Define the device             dev = qml."
    },
    {
      "id": "qml.UCCSD",
      "name": "qml.UCCSD",
      "type": "class",
      "description": "PennyLane API: UCCSD. Found in uccsd.html",
      "source_file": "uccsd.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the UCCSD template. \"\"\"  # pylint: disable-msg=too-many-arguments,protected-access,too-many-positional-a"
    },
    {
      "id": "qml.QFT.compute_decomposition",
      "name": "qml.QFT.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: QFT.compute_decomposition. Found in qft.html",
      "source_file": "qft.html",
      "context": "s:             list[Operator]: decomposition of the operator          **Example:**          >>> qml.QFT.compute_decomposition(wires=(0,1,2))         [H(0),          ControlledPhaseShift(1.570796326794"
    },
    {
      "id": "qml.templates.QuantumMonteCarlo",
      "name": "qml.templates.QuantumMonteCarlo",
      "type": "function",
      "description": "PennyLane API: templates.QuantumMonteCarlo. Found in qmc.html",
      "source_file": "qmc.html",
      "context": "it\", wires=(n + m + 1))              @qml.qnode(dev)             def circuit():                 qml.templates.QuantumMonteCarlo(                     probs,                     func,                   "
    },
    {
      "id": "qml.resource.SpectralNormError",
      "name": "qml.resource.SpectralNormError",
      "type": "function",
      "description": "PennyLane API: resource.SpectralNormError. Found in qpe.html",
      "source_file": "qpe.html",
      "context": "CustomOP(qml.resource.ErrorOperation):         ...    def error(self):         ...       return qml.resource.SpectralNormError(0.005)         >>> Op = CustomOP(wires=[0])         >>> QPE = QuantumPhas"
    },
    {
      "id": "qml.resource.ErrorOperation",
      "name": "qml.resource.ErrorOperation",
      "type": "function",
      "description": "PennyLane API: resource.ErrorOperation. Found in qpe.html",
      "source_file": "qpe.html",
      "context": "tral norm error of the input unitary operator.          **Example**          >>> class CustomOP(qml.resource.ErrorOperation):         ...    def error(self):         ...       return qml.resource.Spec"
    },
    {
      "id": "qml.HybridQRAM",
      "name": "qml.HybridQRAM",
      "type": "class",
      "description": "PennyLane API: HybridQRAM. Found in qram.html",
      "source_file": "qram.html",
      "context": "s and # limitations under the License. \"\"\"Contains three different implementations of QRAM: BBQRAM, HybridQRAM, and SelectOnlyQRAM.\"\"\" from collections import defaultdict from dataclasses import datac"
    },
    {
      "id": "qml.BBQRAM",
      "name": "qml.BBQRAM",
      "type": "class",
      "description": "PennyLane API: BBQRAM. Found in qram.html",
      "source_file": "qram.html",
      "context": "rmissions and # limitations under the License. \"\"\"Contains three different implementations of QRAM: BBQRAM, HybridQRAM, and SelectOnlyQRAM.\"\"\" from collections import defaultdict from dataclasses impo"
    },
    {
      "id": "qml.SelectOnlyQRAM",
      "name": "qml.SelectOnlyQRAM",
      "type": "class",
      "description": "PennyLane API: SelectOnlyQRAM. Found in qram.html",
      "source_file": "qram.html",
      "context": "ons under the License. \"\"\"Contains three different implementations of QRAM: BBQRAM, HybridQRAM, and SelectOnlyQRAM.\"\"\" from collections import defaultdict from dataclasses import dataclass from typing"
    },
    {
      "id": "qml.QSVT",
      "name": "qml.QSVT",
      "type": "class",
      "description": "PennyLane API: QSVT. Found in qsvt.html",
      "source_file": "qsvt.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the QSVT template and qsvt wrapper function. \"\"\"  import copy from collections import defaultdict from c"
    },
    {
      "id": "qml.transform_angles",
      "name": "qml.transform_angles",
      "type": "function",
      "description": "PennyLane API: transform_angles. Found in qsvt.html",
      "source_file": "qsvt.html",
      "context": " + 1], updated_matrix[1][0:idx]])      return angles_theta, angles_phi, angles_lambda    [docs] def transform_angles(angles, routine1, routine2):     r\"\"\"     Converts angles for quantum signal proces"
    },
    {
      "id": "qml.qsvt",
      "name": "qml.qsvt",
      "type": "function",
      "description": "PennyLane API: qsvt. Found in qsvt.html",
      "source_file": "qsvt.html",
      "context": "                                  pennylane.templates.subroutines.qsvt — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.Qubitization",
      "name": "qml.Qubitization",
      "type": "class",
      "description": "PennyLane API: Qubitization. Found in qubitization.html",
      "source_file": "qubitization.html",
      "context": "rning permissions and # limitations under the License. \"\"\" This submodule contains the template for Qubitization. \"\"\"  import copy  from pennylane.decomposition import add_decomps, register_resources,"
    },
    {
      "id": "qml.Qubitization.compute_decomposition",
      "name": "qml.Qubitization.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Qubitization.compute_decomposition. Found in qubitization.html",
      "source_file": "qubitization.html",
      "context": "       import pennylane as qml             from pennylane.wires import Wires          >>> print(qml.Qubitization.compute_decomposition(hamiltonian=0.1 * qml.Z(0), control=Wires(1)))         [Reflectio"
    },
    {
      "id": "qml.Reflection",
      "name": "qml.Reflection",
      "type": "class",
      "description": "PennyLane API: Reflection. Found in reflection.html",
      "source_file": "reflection.html",
      "context": " permissions and # limitations under the License.  \"\"\" This submodule contains the template for the Reflection operation. \"\"\" import copy  import numpy as np  from pennylane import ops, pytrees from p"
    },
    {
      "id": "qml.Select",
      "name": "qml.Select",
      "type": "class",
      "description": "PennyLane API: Select. Found in select.html",
      "source_file": "select.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the Select template. \"\"\"  import copy from collections import Counter, defaultdict from itertools import"
    },
    {
      "id": "qml.Select.compute_decomposition",
      "name": "qml.Select.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: Select.compute_decomposition. Found in select.html",
      "source_file": "select.html",
      "context": "ample**          >>> ops = [qml.X(2), qml.X(3), qml.Y(2), qml.SWAP([2,3])]         >>> decomp = qml.Select.compute_decomposition(ops, control=[0,1])         >>> from pprint import pprint         >>> p"
    },
    {
      "id": "qml.CommutingEvolution",
      "name": "qml.CommutingEvolution",
      "type": "class",
      "description": "PennyLane API: CommutingEvolution. Found in commuting_evolution.html",
      "source_file": "commuting_evolution.html",
      "context": " the specific language governing permissions and # limitations under the License. r\"\"\" Contains the CommutingEvolution template. \"\"\" # pylint: disable-msg=too-many-arguments import copy  from pennylan"
    },
    {
      "id": "qml.QDrift",
      "name": "qml.QDrift",
      "type": "class",
      "description": "PennyLane API: QDrift. Found in qdrift.html",
      "source_file": "qdrift.html",
      "context": "ecific language governing permissions and # limitations under the License. \"\"\"Contains template for QDrift subroutine.\"\"\" import copy  from pennylane import math from pennylane.exceptions import Quant"
    },
    {
      "id": "qml.QDrift.error",
      "name": "qml.QDrift.error",
      "type": "class",
      "description": "PennyLane API: QDrift.error. Found in qdrift.html",
      "source_file": "qdrift.html",
      "context": "bound the error:          >>> H = qml.dot([0.25, 0.75], [qml.X(0), qml.Z(0)])         >>> print(qml.QDrift.error(H, time=1.2, n=10))         0.3661197552925645      \"\"\"      @classmethod     def _prim"
    },
    {
      "id": "qml.TrotterizedQfunc",
      "name": "qml.TrotterizedQfunc",
      "type": "class",
      "description": "PennyLane API: TrotterizedQfunc. Found in trotter.html",
      "source_file": "trotter.html",
      "context": "time / n, order, ops)   add_decomps(TrotterProduct, _trotter_product_decomposition)    [docs] class TrotterizedQfunc(Operation):     r\"\"\"An operation representing the Suzuki-Trotter product approximat"
    },
    {
      "id": "qml.templates.TwoLocalSwapNetwork",
      "name": "qml.templates.TwoLocalSwapNetwork",
      "type": "function",
      "description": "PennyLane API: templates.TwoLocalSwapNetwork. Found in ccl2.html",
      "source_file": "ccl2.html",
      "context": "am=None: qml.CNOT(index)     >>> @qml.qnode(dev)     ... def swap_network_circuit():     ...    qml.templates.TwoLocalSwapNetwork(dev.wires, acquaintances, fermionic=True, shift=False)     ...    retu"
    },
    {
      "id": "qml.TwoLocalSwapNetwork.compute_decomposition",
      "name": "qml.TwoLocalSwapNetwork.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: TwoLocalSwapNetwork.compute_decomposition. Found in ccl2.html",
      "source_file": "ccl2.html",
      "context": "res=5)         >>> acquaintances = lambda index, wires, param=None: qml.CNOT(index)         >>> qml.TwoLocalSwapNetwork.compute_decomposition(wires=dev.wires,         ...        acquaintances=acquaint"
    },
    {
      "id": "qml.TwoLocalSwapNetwork.shape",
      "name": "qml.TwoLocalSwapNetwork.shape",
      "type": "class",
      "description": "PennyLane API: TwoLocalSwapNetwork.shape. Found in ccl2.html",
      "source_file": "ccl2.html",
      "context": ", wires=5)         >>> rng = np.random.default_rng(12345)         >>> weights = rng.random(size=qml.TwoLocalSwapNetwork.shape(len(dev.wires)))         >>> print(weights) # doctest: +SKIP         [0.22"
    },
    {
      "id": "qml.MERA",
      "name": "qml.MERA",
      "type": "class",
      "description": "PennyLane API: MERA. Found in mera.html",
      "source_file": "mera.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the MERA template. \"\"\" # pylint: disable=too-many-arguments  import warnings from collections.abc import"
    },
    {
      "id": "qml.MERA.get_n_blocks",
      "name": "qml.MERA.get_n_blocks",
      "type": "class",
      "description": "PennyLane API: MERA.get_n_blocks. Found in mera.html",
      "source_file": "mera.html",
      "context": "should match the number of blocks.         The expected number of blocks can be obtained from ``qml.MERA.get_n_blocks(wires, n_block_wires)``.          This example demonstrates the use of ``MERA`` fo"
    },
    {
      "id": "qml.MPS.get_n_blocks",
      "name": "qml.MPS.get_n_blocks",
      "type": "class",
      "description": "PennyLane API: MPS.get_n_blocks. Found in mps.html",
      "source_file": "mps.html",
      "context": "ting the ``block``      .. note::          The expected number of blocks can be obtained from ``qml.MPS.get_n_blocks(wires, n_block_wires, offset=0)``, and         the length of ``template_weights`` a"
    },
    {
      "id": "qml.MPS",
      "name": "qml.MPS",
      "type": "class",
      "description": "PennyLane API: MPS. Found in mps.html",
      "source_file": "mps.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the MPS template. \"\"\" # pylint: disable=too-many-arguments import warnings  from pennylane import math f"
    },
    {
      "id": "qml.TTN.get_n_blocks",
      "name": "qml.TTN.get_n_blocks",
      "type": "class",
      "description": "PennyLane API: TTN.get_n_blocks. Found in ttn.html",
      "source_file": "ttn.html",
      "context": "should match the number of blocks.         The expected number of blocks can be obtained from ``qml.TTN.get_n_blocks(wires, n_block_wires)``.          This example demonstrates the use of ``TTN`` for "
    },
    {
      "id": "qml.TTN",
      "name": "qml.TTN",
      "type": "class",
      "description": "PennyLane API: TTN. Found in ttn.html",
      "source_file": "ttn.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the TTN template. \"\"\" # pylint: disable=too-many-arguments  import warnings  import numpy as np  from pe"
    },
    {
      "id": "qml.batch_input",
      "name": "qml.batch_input",
      "type": "function",
      "description": "PennyLane API: batch_input. Found in batch_input.html",
      "source_file": "batch_input.html",
      "context": "                                  pennylane.transforms.batch_input — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.numpy.builtins",
      "name": "qml.numpy.builtins",
      "type": "function",
      "description": "PennyLane API: numpy.builtins. Found in batch_params.html",
      "source_file": "batch_params.html",
      "context": "ed tuple structures, stack the arrays at the leaves     \"\"\"     # for some reason pylint thinks qml.numpy.builtins is a dict     if not isinstance(res[0], (tuple, qml.numpy.builtins.SequenceBox)):    "
    },
    {
      "id": "qml.numpy.builtins.SequenceBox",
      "name": "qml.numpy.builtins.SequenceBox",
      "type": "function",
      "description": "PennyLane API: numpy.builtins.SequenceBox. Found in batch_params.html",
      "source_file": "batch_params.html",
      "context": "or some reason pylint thinks qml.numpy.builtins is a dict     if not isinstance(res[0], (tuple, qml.numpy.builtins.SequenceBox)):         return qml.math.stack(res)      stacked_results = []     for i"
    },
    {
      "id": "qml.ops",
      "name": "qml.ops",
      "type": "function",
      "description": "PennyLane API: ops. Found in batch_params.html",
      "source_file": "batch_params.html",
      "context": "r qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spi"
    },
    {
      "id": "qml.batch_params",
      "name": "qml.batch_params",
      "type": "function",
      "description": "PennyLane API: batch_params. Found in batch_params.html",
      "source_file": "batch_params.html",
      "context": "                                  pennylane.transforms.batch_params — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.math.unstack",
      "name": "qml.math.unstack",
      "type": "function",
      "description": "PennyLane API: math.unstack. Found in batch_partial.html",
      "source_file": "batch_partial.html",
      "context": "provided\") from None          for key, val in preprocess.items():             unstacked_args = (qml.math.unstack(arg) for arg in args)             val = qml.math.stack([val(*a) for a in zip(*unstacked"
    },
    {
      "id": "qml.batch_partial",
      "name": "qml.batch_partial",
      "type": "function",
      "description": "PennyLane API: batch_partial. Found in batch_partial.html",
      "source_file": "batch_partial.html",
      "context": "                                  pennylane.transforms.batch_partial — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.numpy.linspace",
      "name": "qml.numpy.linspace",
      "type": "function",
      "description": "PennyLane API: numpy.linspace. Found in batch_partial.html",
      "source_file": "batch_partial.html",
      "context": " and the output of the function also has a batch dimension:      >>> batch_size = 4     >>> x = qml.numpy.linspace(0.1, 0.5, batch_size)     >>> batched_partial_circuit(x)     tensor([0.975..., 0.953."
    },
    {
      "id": "qml.typing.Result",
      "name": "qml.typing.Result",
      "type": "function",
      "description": "PennyLane API: typing.Result. Found in broadcast_expand.html",
      "source_file": "broadcast_expand.html",
      "context": "ape.trainable_params         )         for ops in new_ops     )      def processing_fn(results: qml.typing.ResultBatch) -> qml.typing.Result:         # closure variables: tape.shots, tape.batch_size, "
    },
    {
      "id": "qml.typing.ResultBatch",
      "name": "qml.typing.ResultBatch",
      "type": "function",
      "description": "PennyLane API: typing.ResultBatch. Found in broadcast_expand.html",
      "source_file": "broadcast_expand.html",
      "context": "ape.trainable_params         )         for ops in new_ops     )      def processing_fn(results: qml.typing.ResultBatch) -> qml.typing.Result:         # closure variables: tape.shots, tape.batch_size, "
    },
    {
      "id": "qml.transforms.combine_global_phases",
      "name": "qml.transforms.combine_global_phases",
      "type": "function",
      "description": "PennyLane API: transforms.combine_global_phases. Found in combine_global_phases.html",
      "source_file": "combine_global_phases.html",
      "context": "                                  pennylane.transforms.combine_global_phases — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.transforms.commutation_dag",
      "name": "qml.transforms.commutation_dag",
      "type": "function",
      "description": "PennyLane API: transforms.commutation_dag. Found in commutation_dag.html",
      "source_file": "commutation_dag.html",
      "context": "                                  pennylane.transforms.commutation_dag — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.compile",
      "name": "qml.compile",
      "type": "function",
      "description": "PennyLane API: compile. Found in compile.html",
      "source_file": "compile.html",
      "context": "                                  pennylane.transforms.compile — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.transforms.commute_controlled",
      "name": "qml.transforms.commute_controlled",
      "type": "function",
      "description": "PennyLane API: transforms.commute_controlled. Found in compile.html",
      "source_file": "compile.html",
      "context": ":      - pushing all commuting single-qubit gates as far right as possible       (:func:`~pennylane.transforms.commute_controlled`)     - cancellation of adjacent inverse gates       (:func:`~pennylan"
    },
    {
      "id": "qml.devices.preprocess.decompose",
      "name": "qml.devices.preprocess.decompose",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.decompose. Found in compile.html",
      "source_file": "compile.html",
      "context": "bj.name in basis_set and (not getattr(obj, \"only_visual\", False))          [expanded_tape], _ = qml.devices.preprocess.decompose(             tape,             stopping_condition=stop_at,             "
    },
    {
      "id": "qml.CompilePipeline",
      "name": "qml.CompilePipeline",
      "type": "class",
      "description": "PennyLane API: CompilePipeline. Found in compile_pipeline.html",
      "source_file": "compile_pipeline.html",
      "context": " language governing permissions and # limitations under the License. \"\"\" This module contains the ``CompilePipeline`` class. \"\"\"  from __future__ import annotations  from collections.abc import Sequen"
    },
    {
      "id": "qml.transforms.remove_barrier",
      "name": "qml.transforms.remove_barrier",
      "type": "function",
      "description": "PennyLane API: transforms.remove_barrier. Found in compile_pipeline.html",
      "source_file": "compile_pipeline.html",
      "context": "ists, including     ``insert``, ``append``, ``extend`` and ``pop``:      >>> pipeline.insert(0, qml.transforms.remove_barrier)     >>> pipeline     CompilePipeline(remove_barrier, merge_rotations, can"
    },
    {
      "id": "qml.typing.PostprocessingFn",
      "name": "qml.typing.PostprocessingFn",
      "type": "function",
      "description": "PennyLane API: typing.PostprocessingFn. Found in transform_dispatcher.html",
      "source_file": "transform_dispatcher.html",
      "context": "   ``my_tape_transform(tape: qml.tape.QuantumScript, ...) -> tuple[qml.tape.QuantumScriptBatch, qml.typing.PostprocessingFn]``          pass_name (str | None): the name of the associated MLIR pass to "
    },
    {
      "id": "qml.tape.QuantumScriptBatch",
      "name": "qml.tape.QuantumScriptBatch",
      "type": "function",
      "description": "PennyLane API: tape.QuantumScriptBatch. Found in transform_dispatcher.html",
      "source_file": "transform_dispatcher.html",
      "context": "ing is optional):               ``my_tape_transform(tape: qml.tape.QuantumScript, ...) -> tuple[qml.tape.QuantumScriptBatch, qml.typing.PostprocessingFn]``          pass_name (str | None): the name of"
    },
    {
      "id": "qml.ops.__all__",
      "name": "qml.ops.__all__",
      "type": "function",
      "description": "PennyLane API: ops.__all__. Found in decompose.html",
      "source_file": "decompose.html",
      "context": "stem is enabled). If ``None``, the gate set is considered to be             all operations in ``qml.ops.__all__``.  See :doc:`quantum operators </introduction/operations>`             for this list.  "
    },
    {
      "id": "qml.decomposition.disable_graph",
      "name": "qml.decomposition.disable_graph",
      "type": "function",
      "description": "PennyLane API: decomposition.disable_graph. Found in decompose.html",
      "source_file": "decompose.html",
      "context": "t)()[\"resources\"].gate_types         {'RZ': 12, 'RX': 7, 'GlobalPhase': 6, 'CZ': 3}         >>> qml.decomposition.disable_graph()      \"\"\"      if not enabled_graph() and (fixed_decomps or alt_decomps"
    },
    {
      "id": "qml.decomposition.enabled_graph",
      "name": "qml.decomposition.enabled_graph",
      "type": "function",
      "description": "PennyLane API: decomposition.enabled_graph. Found in decompose.html",
      "source_file": "decompose.html",
      "context": "ll be raised. To suppress this warning, simply add the operator to the gate set.         When ``qml.decomposition.enabled_graph()``, PennyLane errors out with a ``DecompositionError``.      .. seealso"
    },
    {
      "id": "qml.math.divide",
      "name": "qml.math.divide",
      "type": "function",
      "description": "PennyLane API: math.divide. Found in clifford_t_transform.html",
      "source_file": "clifford_t_transform.html",
      "context": "l.math.allclose(theta, 0.0, atol=1e-6):         return [qml.GlobalPhase(0.0)]      rem_, mod_ = qml.math.divide(theta, math.pi), qml.math.mod(theta, math.pi)     if qml.math.allclose(mod_, 0.0, atol=1"
    },
    {
      "id": "qml.PhaseShift.",
      "name": "qml.PhaseShift.",
      "type": "class",
      "description": "PennyLane API: PhaseShift.. Found in clifford_t_transform.html",
      "source_file": "clifford_t_transform.html",
      "context": "        f\"Operation {op} is not a supported Pauli rotation: qml.RX, qml.RY, qml.RZ, qml.Rot and qml.PhaseShift.\"         )      d_ops.extend(ops_)     return d_ops   def _one_qubit_decompose(op):     "
    },
    {
      "id": "qml.math.floor_divide",
      "name": "qml.math.floor_divide",
      "type": "function",
      "description": "PennyLane API: math.floor_divide. Found in clifford_t_transform.html",
      "source_file": "clifford_t_transform.html",
      "context": " vop_ = qml.S(wires) if val_ == 2 else qml.T(wires)                         sign = qml.math.mod(qml.math.floor_divide(div_, 2), 2)                         ops_ = [                             vop_ if "
    },
    {
      "id": "qml.transforms.clifford_t_decomposition",
      "name": "qml.transforms.clifford_t_decomposition",
      "type": "function",
      "description": "PennyLane API: transforms.clifford_t_decomposition. Found in clifford_t_transform.html",
      "source_file": "clifford_t_transform.html",
      "context": ")             return qml.expval(qml.Z(0))          x, y = 1.1, 2.2         decomposed_circuit = qml.transforms.clifford_t_decomposition(circuit)         result = circuit(x, y)         approx = decompo"
    },
    {
      "id": "qml.transforms.gridsynth",
      "name": "qml.transforms.gridsynth",
      "type": "function",
      "description": "PennyLane API: transforms.gridsynth. Found in gridsynth.html",
      "source_file": "gridsynth.html",
      "context": "         qml.PhaseShift(x * 0.2, 0)             return qml.state()          gridsynth_circuit = qml.transforms.gridsynth(circuit, epsilon=1e-4)         qjitted_circuit = qml.qjit(gridsynth_circuit)   "
    },
    {
      "id": "qml.defer_measurements.",
      "name": "qml.defer_measurements.",
      "type": "function",
      "description": "PennyLane API: defer_measurements.. Found in defer_measurements.html",
      "source_file": "defer_measurements.html",
      "context": "{mp.__class__.__name__} as a measurement without specifying wires \"                 \"when using qml.defer_measurements. Deferred measurements can occur \"                 \"automatically when using mid-"
    },
    {
      "id": "qml.operation.CVObservable",
      "name": "qml.operation.CVObservable",
      "type": "function",
      "description": "PennyLane API: operation.CVObservable. Found in defer_measurements.html",
      "source_file": "defer_measurements.html",
      "context": "\"Helper function to check that the tape is valid.\"\"\"     cv_types = (qml.operation.CVOperation, qml.operation.CVObservable)     ops_cv = any(isinstance(op, cv_types) and op.name != \"Identity\" for op i"
    },
    {
      "id": "qml.devices.LegacyDeviceFacade",
      "name": "qml.devices.LegacyDeviceFacade",
      "type": "function",
      "description": "PennyLane API: devices.LegacyDeviceFacade. Found in dynamic_one_shot.html",
      "source_file": "dynamic_one_shot.html",
      "context": "lities(dev):     \"\"\"Gets the capabilities dictionary of a device.\"\"\"     assert isinstance(dev, qml.devices.LegacyDeviceFacade)     return dev.target_device.capabilities()   def _supports_one_shot(dev"
    },
    {
      "id": "qml.defer_measurement",
      "name": "qml.defer_measurement",
      "type": "function",
      "description": "PennyLane API: defer_measurement. Found in dynamic_one_shot.html",
      "source_file": "dynamic_one_shot.html",
      "context": " applies a probabilistic mid-circuit measurement to the circuit.     This is in contrast with ``qml.defer_measurement``, which instead introduces an extra     wire for each mid-circuit measurement. Th"
    },
    {
      "id": "qml.transforms.transform",
      "name": "qml.transforms.transform",
      "type": "function",
      "description": "PennyLane API: transforms.transform. Found in parity_matrix.html",
      "source_file": "parity_matrix.html",
      "context": "ate representation.      \"\"\"      def postprocessing_fn(tapes):         # This is required in a qml.transforms.transform (see docs therein)         circ = tapes[0]         wires = circ.wires          "
    },
    {
      "id": "qml.transforms.parity_synth",
      "name": "qml.transforms.parity_synth",
      "type": "function",
      "description": "PennyLane API: transforms.parity_synth. Found in parity_synth.html",
      "source_file": "parity_synth.html",
      "context": "ircuit into a reduced MLIR module:      .. code-block:: python          qjit_circuit = qml.qjit(qml.transforms.parity_synth(circuit))         specs = qml.specs(qjit_circuit, level=\"device\")(0.52, 0.12"
    },
    {
      "id": "qml.transforms.rowcol",
      "name": "qml.transforms.rowcol",
      "type": "function",
      "description": "PennyLane API: transforms.rowcol. Found in rowcol.html",
      "source_file": "rowcol.html",
      "context": "●─│──┤     4: ──────────╰X─╰X──────────╰X─┤      We now run the algorithm:      >>> new_qfunc = qml.transforms.rowcol(qfunc)     >>> print(qml.draw(new_qfunc, wire_order=range(5))()) # doctest: +SKIP "
    },
    {
      "id": "qml.transforms.intermediate_reps.preorder_traverse",
      "name": "qml.transforms.intermediate_reps.preorder_traverse",
      "type": "function",
      "description": "PennyLane API: transforms.intermediate_reps.preorder_traverse. Found in rowcol.html",
      "source_file": "rowcol.html",
      "context": "ree provided via the ``source`` argument, is *not* included in the output.      >>> traversal = qml.transforms.intermediate_reps.preorder_traverse(G, 0)     >>> print(traversal) # doctest: +SKIP     ["
    },
    {
      "id": "qml.transforms.intermediate_reps.postorder_traverse",
      "name": "qml.transforms.intermediate_reps.postorder_traverse",
      "type": "function",
      "description": "PennyLane API: transforms.intermediate_reps.postorder_traverse. Found in rowcol.html",
      "source_file": "rowcol.html",
      "context": "ree provided via the ``source`` argument, is *not* included in the output.      >>> traversal = qml.transforms.intermediate_reps.postorder_traverse(G, 0)     >>> print(traversal)     [(8, 3), (3, 1), "
    },
    {
      "id": "qml.transforms.merge_amplitude_embedding",
      "name": "qml.transforms.merge_amplitude_embedding",
      "type": "function",
      "description": "PennyLane API: transforms.merge_amplitude_embedding. Found in merge_amplitude_embedding.html",
      "source_file": "merge_amplitude_embedding.html",
      "context": "  You can apply the transform directly on :class:`QNode`:      .. code-block:: python          @qml.transforms.merge_amplitude_embedding         @qml.qnode(device=dev)         def circuit():          "
    },
    {
      "id": "qml.commutation_dag",
      "name": "qml.commutation_dag",
      "type": "function",
      "description": "PennyLane API: commutation_dag. Found in pattern_matching.html",
      "source_file": "pattern_matching.html",
      "context": "ntumScript, QuantumScriptBatch from pennylane.transforms import transform from pennylane.transforms.commutation_dag import commutation_dag from pennylane.typing import PostprocessingFn from pennylane."
    },
    {
      "id": "qml.pattern_matching",
      "name": "qml.pattern_matching",
      "type": "function",
      "description": "PennyLane API: pattern_matching. Found in pattern_matching.html",
      "source_file": "pattern_matching.html",
      "context": "                                  pennylane.transforms.optimization.pattern_matching — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.transforms.match_controlled_iX_gate",
      "name": "qml.transforms.match_controlled_iX_gate",
      "type": "function",
      "description": "PennyLane API: transforms.match_controlled_iX_gate. Found in relative_phases.html",
      "source_file": "relative_phases.html",
      "context": "lowing quantum function:      .. code-block:: python          import pennylane as qml          @qml.transforms.match_controlled_iX_gate(num_controls=2)         @qml.qnode(qml.device(\"default.qubit\")) "
    },
    {
      "id": "qml.transforms.match_relative_phase_toffoli",
      "name": "qml.transforms.match_relative_phase_toffoli",
      "type": "function",
      "description": "PennyLane API: transforms.match_relative_phase_toffoli. Found in relative_phases.html",
      "source_file": "relative_phases.html",
      "context": "form>`.      **Example**      .. code-block:: python          import pennylane as qml          @qml.transforms.match_relative_phase_toffoli         @qml.qnode(qml.device(\"default.qubit\"))         def "
    },
    {
      "id": "qml.transforms.single_qubit_fusion",
      "name": "qml.transforms.single_qubit_fusion",
      "type": "function",
      "description": "PennyLane API: transforms.single_qubit_fusion. Found in single_qubit_fusion.html",
      "source_file": "single_qubit_fusion.html",
      "context": "  You can apply the transform directly on :class:`QNode`:      .. code-block:: python          @qml.transforms.single_qubit_fusion         @qml.qnode(device=dev)         def qfunc(r1, r2):            "
    },
    {
      "id": "qml.templates.MottonenStatePreparation",
      "name": "qml.templates.MottonenStatePreparation",
      "type": "function",
      "description": "PennyLane API: templates.MottonenStatePreparation. Found in qmc.html",
      "source_file": "qmc.html",
      "context": "    dev = qml.device(\"default.qubit\", wires=(n + m + 1))              def fn():                 qml.templates.MottonenStatePreparation(np.sqrt(probs), wires=a_wires)                 r_unitary(qml.RY, "
    },
    {
      "id": "qml.quantum_monte_carlo",
      "name": "qml.quantum_monte_carlo",
      "type": "function",
      "description": "PennyLane API: quantum_monte_carlo. Found in qmc.html",
      "source_file": "qmc.html",
      "context": "r the specific language governing permissions and # limitations under the License. \"\"\" Contains the quantum_monte_carlo transform. \"\"\" from copy import copy  import pennylane as qml from pennylane imp"
    },
    {
      "id": "qml.measurements.VarianceMP",
      "name": "qml.measurements.VarianceMP",
      "type": "function",
      "description": "PennyLane API: measurements.VarianceMP. Found in sign_expand.html",
      "source_file": "sign_expand.html",
      "context": "1         or not isinstance(             tape.measurements[0], (qml.measurements.ExpectationMP, qml.measurements.VarianceMP)         )     ):         raise ValueError(             \"Passed tape must en"
    },
    {
      "id": "qml.measurements.ExpectationMP",
      "name": "qml.measurements.ExpectationMP",
      "type": "function",
      "description": "PennyLane API: measurements.ExpectationMP. Found in sign_expand.html",
      "source_file": "sign_expand.html",
      "context": "   operations = tape.operations + added_operations          if isinstance(tape.measurements[0], qml.measurements.ExpectationMP):             measurements = [qml.expval(-1 * qml.Z(controls[0]))]       "
    },
    {
      "id": "qml.transforms.sign_expand",
      "name": "qml.transforms.sign_expand",
      "type": "function",
      "description": "PennyLane API: transforms.sign_expand. Found in sign_expand.html",
      "source_file": "sign_expand.html",
      "context": "                                  pennylane.transforms.sign_expand.sign_expand — PennyLane 0.45.0-dev3 documentation                       About     Research         "
    },
    {
      "id": "qml.transforms.split_to_single_terms",
      "name": "qml.transforms.split_to_single_terms",
      "type": "function",
      "description": "PennyLane API: transforms.split_to_single_terms. Found in split_to_single_terms.html",
      "source_file": "split_to_single_terms.html",
      "context": "                                  pennylane.transforms.split_to_single_terms — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.devices.preprocess.decompose.tape_transform",
      "name": "qml.devices.preprocess.decompose.tape_transform",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.decompose.tape_transform. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": "return op.decomposition()      for container in program:         if container.tape_transform == qml.devices.preprocess.decompose.tape_transform:             container.kwargs[\"decomposer\"] = decomposer"
    },
    {
      "id": "qml.ops.qubit.attributes.has_unitary_generator",
      "name": "qml.ops.qubit.attributes.has_unitary_generator",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.has_unitary_generator. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": "obj, MeasurementProcess)         or len(obj.data) == 0         or (obj.has_generator and obj in qml.ops.qubit.attributes.has_unitary_generator)     )   expand_nonunitary_gen = create_expand_fn(     de"
    },
    {
      "id": "qml.transforms.set_decomposition",
      "name": "qml.transforms.set_decomposition",
      "type": "function",
      "description": "PennyLane API: transforms.set_decomposition. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": " is drawn at the device level where the     custom decomposition will be applied.      >>> with qml.transforms.set_decomposition({qml.CNOT : custom_cnot}, dev):     ...     print(qml.draw(circuit, lev"
    },
    {
      "id": "qml.transforms.create_expand_fn",
      "name": "qml.transforms.create_expand_fn",
      "type": "function",
      "description": "PennyLane API: transforms.create_expand_fn. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": ") for d in obj.data))      Then the expansion function can be obtained via      >>> expand_fn = qml.transforms.create_expand_fn(depth=5, stop_at=stop_at)      We can test the newly generated function "
    },
    {
      "id": "qml.devices.Device.preprocess",
      "name": "qml.devices.Device.preprocess",
      "type": "function",
      "description": "PennyLane API: devices.Device.preprocess. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": " override_method = (             \"preprocess_transforms\"             if type(dev).preprocess == qml.devices.Device.preprocess             else \"preprocess\"         )          original_method = getattr"
    },
    {
      "id": "qml.transforms.create_decomp_expand_fn",
      "name": "qml.transforms.create_decomp_expand_fn",
      "type": "function",
      "description": "PennyLane API: transforms.create_decomp_expand_fn. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": " function of the device:      >>> custom_decomps = {qml.CNOT : custom_cnot}     >>> expand_fn = qml.transforms.create_decomp_expand_fn(custom_decomps, dev) # doctest: +SKIP     >>> dev.custom_expand(e"
    },
    {
      "id": "qml.operation.TermsUndefinedError",
      "name": "qml.operation.TermsUndefinedError",
      "type": "function",
      "description": "PennyLane API: operation.TermsUndefinedError. Found in tape_expand.html",
      "source_file": "tape_expand.html",
      "context": "           or (obj.has_generator and len(obj.generator().terms()[0]) == 1)         )     except qml.operation.TermsUndefinedError:         return True   expand_multipar = create_expand_fn(     depth=N"
    },
    {
      "id": "qml.transforms.transpile",
      "name": "qml.transforms.transpile",
      "type": "function",
      "description": "PennyLane API: transforms.transpile. Found in transpile.html",
      "source_file": "transpile.html",
      "context": "                                  pennylane.transforms.transpile — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.transforms.unitary_to_rot",
      "name": "qml.transforms.unitary_to_rot",
      "type": "function",
      "description": "PennyLane API: transforms.unitary_to_rot. Found in unitary_to_rot.html",
      "source_file": "unitary_to_rot.html",
      "context": "                                  pennylane.transforms.unitary_to_rot — PennyLane 0.45.0-dev3 documentation                       About     Research                  Fea"
    },
    {
      "id": "qml.transforms.to_zx",
      "name": "qml.transforms.to_zx",
      "type": "function",
      "description": "PennyLane API: transforms.to_zx. Found in converter.html",
      "source_file": "converter.html",
      "context": "lock:: python          import pyzx         dev = qml.device('default.qubit', wires=2)          @qml.transforms.to_zx         @qml.qnode(device=dev)         def circuit(p):             qml.RZ(p[0], wir"
    },
    {
      "id": "qml.Hadmard",
      "name": "qml.Hadmard",
      "type": "class",
      "description": "PennyLane API: Hadmard. Found in converter.html",
      "source_file": "converter.html",
      "context": ")          The circuit contains 63 gates; 28 :func:`qml.T` gates, 28 :func:`qml.CNOT`, 6 :func:`qml.Hadmard` and         1 :func:`qml.X`. We applied the ``qml.transforms.to_zx`` decorator in order to "
    },
    {
      "id": "qml.transforms.from_zx",
      "name": "qml.transforms.from_zx",
      "type": "function",
      "description": "PennyLane API: transforms.from_zx. Found in converter.html",
      "source_file": "converter.html",
      "context": "circuit back into PennyLane operations:          .. code-block:: python              tape_opt = qml.transforms.from_zx(g)              wires = qml.wires.Wires([4, 3, 0, 2, 1])             wires_map = "
    },
    {
      "id": "qml.clifford_t_decomposition",
      "name": "qml.clifford_t_decomposition",
      "type": "function",
      "description": "PennyLane API: clifford_t_decomposition. Found in optimize_t_count.html",
      "source_file": "optimize_t_count.html",
      "context": "raise TypeError(             \"The input circuit must be a Clifford + T circuit. Consider using `qml.clifford_t_decomposition` first.\"         ) from e      qscript = from_zx(pyzx_circ.to_graph())     "
    },
    {
      "id": "qml.workflow.resolution._resolve_diff_method",
      "name": "qml.workflow.resolution._resolve_diff_method",
      "type": "function",
      "description": "PennyLane API: workflow.resolution._resolve_diff_method. Found in construct_batch.html",
      "source_file": "construct_batch.html",
      "context": "on_config(qnode, resolve=False)()         # pylint: disable = protected-access         config = qml.workflow.resolution._resolve_diff_method(config, qnode.device)         gradient_fn = config.gradient"
    },
    {
      "id": "qml.devices.MCMConfig",
      "name": "qml.devices.MCMConfig",
      "type": "function",
      "description": "PennyLane API: devices.MCMConfig. Found in construct_batch.html",
      "source_file": "construct_batch.html",
      "context": "gradient_fn.expand_transform),             **qnode.gradient_kwargs,         )      mcm_config = qml.devices.MCMConfig(         postselect_mode=qnode.execute_kwargs[\"postselect_mode\"],         mcm_meth"
    },
    {
      "id": "qml.workflow.construct_execution_config",
      "name": "qml.workflow.construct_execution_config",
      "type": "function",
      "description": "PennyLane API: workflow.construct_execution_config. Found in construct_batch.html",
      "source_file": "construct_batch.html",
      "context": "ric_tensor)      \"\"\"     _validate_level(level)     if gradient_fn == \"unset\":         config = qml.workflow.construct_execution_config(qnode, resolve=False)()         # pylint: disable = protected-ac"
    },
    {
      "id": "qml.logging.TRACE",
      "name": "qml.logging.TRACE",
      "type": "function",
      "description": "PennyLane API: logging.TRACE. Found in execution.html",
      "source_file": "execution.html",
      "context": "(device),             (                 diff_method                 if not (logger.isEnabledFor(qml.logging.TRACE) and inspect.isfunction(diff_method))                 else \"\\n\" + inspect.getsource(di"
    },
    {
      "id": "qml.devices.Device.compute_derivatives",
      "name": "qml.devices.Device.compute_derivatives",
      "type": "function",
      "description": "PennyLane API: devices.Device.compute_derivatives. Found in jacobian_products.html",
      "source_file": "jacobian_products.html",
      "context": "     \"\"\"Calculate jacobian products via a device provided jacobian.  This class relies on     ``qml.devices.Device.compute_derivatives``.      Args:          device (pennylane.devices.Device): the dev"
    },
    {
      "id": "qml.transforms.convert_to_numpy_parameters",
      "name": "qml.transforms.convert_to_numpy_parameters",
      "type": "function",
      "description": "PennyLane API: transforms.convert_to_numpy_parameters. Found in jacobian_products.html",
      "source_file": "jacobian_products.html",
      "context": "   Dispatches between the two different device interfaces.         \"\"\"         numpy_tapes, _ = qml.transforms.convert_to_numpy_parameters(tapes)         return self._device.execute_and_compute_deriva"
    },
    {
      "id": "qml.gradients.compute_vjp_multi",
      "name": "qml.gradients.compute_vjp_multi",
      "type": "function",
      "description": "PennyLane API: gradients.compute_vjp_multi. Found in jacobian_products.html",
      "source_file": "jacobian_products.html",
      "context": "pute the vjps of multiple tapes, directly for a Jacobian and co-tangents dys.\"\"\"     f = {True: qml.gradients.compute_vjp_multi, False: qml.gradients.compute_vjp_single}      vjps = []     for jac, dy"
    },
    {
      "id": "qml.transforms.core.Transform",
      "name": "qml.transforms.core.Transform",
      "type": "function",
      "description": "PennyLane API: transforms.core.Transform. Found in jacobian_products.html",
      "source_file": "jacobian_products.html",
      "context": ")      def __init__(         self,         inner_execute: Callable,         gradient_transform: qml.transforms.core.Transform,         gradient_kwargs: dict | None = None,         cache_full_jacobian:"
    },
    {
      "id": "qml.gradients.compute_vjp_single",
      "name": "qml.gradients.compute_vjp_single",
      "type": "function",
      "description": "PennyLane API: gradients.compute_vjp_single. Found in jacobian_products.html",
      "source_file": "jacobian_products.html",
      "context": "y for a Jacobian and co-tangents dys.\"\"\"     f = {True: qml.gradients.compute_vjp_multi, False: qml.gradients.compute_vjp_single}      vjps = []     for jac, dy, t in zip(jacs, dys, tapes, strict=True"
    },
    {
      "id": "qml.Rot.ndim_params",
      "name": "qml.Rot.ndim_params",
      "type": "class",
      "description": "PennyLane API: Rot.ndim_params. Found in qnode.html",
      "source_file": "qnode.html",
      "context": "ossible to broadcast multiple arguments of a single operator,         for example:          >>> qml.Rot.ndim_params # Rot takes three scalar arguments         (0, 0, 0)         >>> x = np.array([0.4, "
    },
    {
      "id": "qml.concurrency.executors.get_supported_backends.",
      "name": "qml.concurrency.executors.get_supported_backends.",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.get_supported_backends.. Found in qnode.html",
      "source_file": "qnode.html",
      "context": "ecution             environment. All supported options can be queried using             :func:`~qml.concurrency.executors.get_supported_backends.             The default value is :class:`qml.concurren"
    },
    {
      "id": "qml.math.SUPPORTED_INTERFACE_USER_INPUT",
      "name": "qml.math.SUPPORTED_INTERFACE_USER_INPUT",
      "type": "function",
      "description": "PennyLane API: math.SUPPORTED_INTERFACE_USER_INPUT. Found in qnode.html",
      "source_file": "qnode.html",
      "context": "s affects the types of objects that can be passed to/returned from the QNode. See             ``qml.math.SUPPORTED_INTERFACE_USER_INPUT`` for a list of all accepted strings.              * ``\"autograd"
    },
    {
      "id": "qml.gradients.SUPPORTED_GRADIENT_KWARGS",
      "name": "qml.gradients.SUPPORTED_GRADIENT_KWARGS",
      "type": "function",
      "description": "PennyLane API: gradients.SUPPORTED_GRADIENT_KWARGS. Found in qnode.html",
      "source_file": "qnode.html",
      "context": "e.__init__`.                 The list of supported gradient keyword arguments can be found at ``qml.gradients.SUPPORTED_GRADIENT_KWARGS``.          Returns:             qnode (QNode): new QNode with u"
    },
    {
      "id": "qml.concurrency.executors.native.MP_PoolExec",
      "name": "qml.concurrency.executors.native.MP_PoolExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.native.MP_PoolExec. Found in qnode.html",
      "source_file": "qnode.html",
      "context": "nc:`~qml.concurrency.executors.get_supported_backends.             The default value is :class:`qml.concurrency.executors.native.MP_PoolExec`.      **Example**      QNodes can be created by decorating"
    },
    {
      "id": "qml.labs.transforms",
      "name": "qml.labs.transforms",
      "type": "function",
      "description": "PennyLane API: labs.transforms. Found in pennylane.labs.dla.batched_pauli_decompose.html",
      "source_file": "pennylane.labs.dla.batched_pauli_decompose.html",
      "context": "ier qml.gradients qml.io qml.kernels qml.labs Modules qml.labs.dla qml.labs.resource_estimation qml.labs.transforms qml.labs.trotter_error     qml.liealg qml.logging qml.math qml.noise qml.numpy qml.o"
    },
    {
      "id": "qml.labs.trotter_error",
      "name": "qml.labs.trotter_error",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error. Found in pennylane.labs.dla.batched_pauli_decompose.html",
      "source_file": "pennylane.labs.dla.batched_pauli_decompose.html",
      "context": "l.io qml.kernels qml.labs Modules qml.labs.dla qml.labs.resource_estimation qml.labs.transforms qml.labs.trotter_error     qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli"
    },
    {
      "id": "qml.labs.dla",
      "name": "qml.labs.dla",
      "type": "function",
      "description": "PennyLane API: labs.dla. Found in pennylane.labs.dla.batched_pauli_decompose.html",
      "source_file": "pennylane.labs.dla.batched_pauli_decompose.html",
      "context": "                                         qml.labs.dla.batched_pauli_decompose — PennyLane 0.45.0-dev3 documentation                          About     Re"
    },
    {
      "id": "qml.labs.dla.batched_pauli_decompose",
      "name": "qml.labs.dla.batched_pauli_decompose",
      "type": "function",
      "description": "PennyLane API: labs.dla.batched_pauli_decompose. Found in pennylane.labs.dla.batched_pauli_decompose.html",
      "source_file": "pennylane.labs.dla.batched_pauli_decompose.html",
      "context": "                                         qml.labs.dla.batched_pauli_decompose — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation",
      "name": "qml.labs.resource_estimation",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation. Found in pennylane.labs.dla.batched_pauli_decompose.html",
      "source_file": "pennylane.labs.dla.batched_pauli_decompose.html",
      "context": ".estimator qml.fermi qml.fourier qml.gradients qml.io qml.kernels qml.labs Modules qml.labs.dla qml.labs.resource_estimation qml.labs.transforms qml.labs.trotter_error     qml.liealg qml.logging qml.m"
    },
    {
      "id": "qml.labs.dla.check_orthonormal",
      "name": "qml.labs.dla.check_orthonormal",
      "type": "function",
      "description": "PennyLane API: labs.dla.check_orthonormal. Found in pennylane.labs.dla.check_orthonormal.html",
      "source_file": "pennylane.labs.dla.check_orthonormal.html",
      "context": "                                         qml.labs.dla.check_orthonormal — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.dla.orthonormalize",
      "name": "qml.labs.dla.orthonormalize",
      "type": "function",
      "description": "PennyLane API: labs.dla.orthonormalize. Found in pennylane.labs.dla.orthonormalize.html",
      "source_file": "pennylane.labs.dla.orthonormalize.html",
      "context": "                                         qml.labs.dla.orthonormalize — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.dla.pauli_coefficients",
      "name": "qml.labs.dla.pauli_coefficients",
      "type": "function",
      "description": "PennyLane API: labs.dla.pauli_coefficients. Found in pennylane.labs.dla.pauli_coefficients.html",
      "source_file": "pennylane.labs.dla.pauli_coefficients.html",
      "context": "                                         qml.labs.dla.pauli_coefficients — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.dla.recursive_cartan_decomp",
      "name": "qml.labs.dla.recursive_cartan_decomp",
      "type": "function",
      "description": "PennyLane API: labs.dla.recursive_cartan_decomp. Found in pennylane.labs.dla.recursive_cartan_decomp.html",
      "source_file": "pennylane.labs.dla.recursive_cartan_decomp.html",
      "context": "                                         qml.labs.dla.recursive_cartan_decomp — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.dla.run_opt",
      "name": "qml.labs.dla.run_opt",
      "type": "function",
      "description": "PennyLane API: labs.dla.run_opt. Found in pennylane.labs.dla.run_opt.html",
      "source_file": "pennylane.labs.dla.run_opt.html",
      "context": "                                         qml.labs.dla.run_opt — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.dla.validate_kak",
      "name": "qml.labs.dla.validate_kak",
      "type": "function",
      "description": "PennyLane API: labs.dla.validate_kak. Found in pennylane.labs.dla.validate_kak.html",
      "source_file": "pennylane.labs.dla.validate_kak.html",
      "context": "                                         qml.labs.dla.validate_kak — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.dla.variational_kak_adj",
      "name": "qml.labs.dla.variational_kak_adj",
      "type": "function",
      "description": "PennyLane API: labs.dla.variational_kak_adj. Found in pennylane.labs.dla.variational_kak_adj.html",
      "source_file": "pennylane.labs.dla.variational_kak_adj.html",
      "context": "                                         qml.labs.dla.variational_kak_adj — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.AllocWires",
      "name": "qml.labs.resource_estimation.AllocWires",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.AllocWires. Found in pennylane.labs.resource_estimation.AllocWires.html",
      "source_file": "pennylane.labs.resource_estimation.AllocWires.html",
      "context": "                                         qml.labs.resource_estimation.AllocWires — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.CompactHamiltonian",
      "name": "qml.labs.resource_estimation.CompactHamiltonian",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.CompactHamiltonian. Found in pennylane.labs.resource_estimation.CompactHamiltonian.html",
      "source_file": "pennylane.labs.resource_estimation.CompactHamiltonian.html",
      "context": "                                         qml.labs.resource_estimation.CompactHamiltonian — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.CompressedResourceOp",
      "name": "qml.labs.resource_estimation.CompressedResourceOp",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.CompressedResourceOp. Found in pennylane.labs.resource_estimation.CompressedResourceOp.html",
      "source_file": "pennylane.labs.resource_estimation.CompressedResourceOp.html",
      "context": "                                         qml.labs.resource_estimation.CompressedResourceOp — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.FreeWires",
      "name": "qml.labs.resource_estimation.FreeWires",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.FreeWires. Found in pennylane.labs.resource_estimation.FreeWires.html",
      "source_file": "pennylane.labs.resource_estimation.FreeWires.html",
      "context": "                                         qml.labs.resource_estimation.FreeWires — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.GateCount",
      "name": "qml.labs.resource_estimation.GateCount",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.GateCount. Found in pennylane.labs.resource_estimation.GateCount.html",
      "source_file": "pennylane.labs.resource_estimation.GateCount.html",
      "context": "                                         qml.labs.resource_estimation.GateCount — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.QubitManager",
      "name": "qml.labs.resource_estimation.QubitManager",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.QubitManager. Found in pennylane.labs.resource_estimation.QubitManager.html",
      "source_file": "pennylane.labs.resource_estimation.QubitManager.html",
      "context": "                                         qml.labs.resource_estimation.QubitManager — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.ResourceAQFT",
      "name": "qml.labs.resource_estimation.ResourceAQFT",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceAQFT. Found in pennylane.labs.resource_estimation.ResourceAQFT.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceAQFT.html",
      "context": "                                         qml.labs.resource_estimation.ResourceAQFT — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceAdjoint",
      "name": "qml.labs.resource_estimation.ResourceAdjoint",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceAdjoint. Found in pennylane.labs.resource_estimation.ResourceAdjoint.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceAdjoint.html",
      "context": "                                         qml.labs.resource_estimation.ResourceAdjoint — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceAliasSampling",
      "name": "qml.labs.resource_estimation.ResourceAliasSampling",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceAliasSampling. Found in pennylane.labs.resource_estimation.ResourceAliasSampling.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceAliasSampling.html",
      "context": "                                         qml.labs.resource_estimation.ResourceAliasSampling — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceBasisRotation",
      "name": "qml.labs.resource_estimation.ResourceBasisRotation",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceBasisRotation. Found in pennylane.labs.resource_estimation.ResourceBasisRotation.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceBasisRotation.html",
      "context": "                                         qml.labs.resource_estimation.ResourceBasisRotation — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCCZ",
      "name": "qml.labs.resource_estimation.ResourceCCZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCCZ. Found in pennylane.labs.resource_estimation.ResourceCCZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCCZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCCZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCH",
      "name": "qml.labs.resource_estimation.ResourceCH",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCH. Found in pennylane.labs.resource_estimation.ResourceCH.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCH.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCH — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCNOT",
      "name": "qml.labs.resource_estimation.ResourceCNOT",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCNOT. Found in pennylane.labs.resource_estimation.ResourceCNOT.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCNOT.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCNOT — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCRX",
      "name": "qml.labs.resource_estimation.ResourceCRX",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCRX. Found in pennylane.labs.resource_estimation.ResourceCRX.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCRX.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCRX — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCRY",
      "name": "qml.labs.resource_estimation.ResourceCRY",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCRY. Found in pennylane.labs.resource_estimation.ResourceCRY.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCRY.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCRY — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCRZ",
      "name": "qml.labs.resource_estimation.ResourceCRZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCRZ. Found in pennylane.labs.resource_estimation.ResourceCRZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCRZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCRZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCRot",
      "name": "qml.labs.resource_estimation.ResourceCRot",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCRot. Found in pennylane.labs.resource_estimation.ResourceCRot.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCRot.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCRot — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCSWAP",
      "name": "qml.labs.resource_estimation.ResourceCSWAP",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCSWAP. Found in pennylane.labs.resource_estimation.ResourceCSWAP.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCSWAP.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCSWAP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCY",
      "name": "qml.labs.resource_estimation.ResourceCY",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCY. Found in pennylane.labs.resource_estimation.ResourceCY.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCY.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCY — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceCZ",
      "name": "qml.labs.resource_estimation.ResourceCZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceCZ. Found in pennylane.labs.resource_estimation.ResourceCZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceCZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceCZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceChangeBasisOp",
      "name": "qml.labs.resource_estimation.ResourceChangeBasisOp",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceChangeBasisOp. Found in pennylane.labs.resource_estimation.ResourceChangeBasisOp.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceChangeBasisOp.html",
      "context": "                                         qml.labs.resource_estimation.ResourceChangeBasisOp — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceConfig",
      "name": "qml.labs.resource_estimation.ResourceConfig",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceConfig. Found in pennylane.labs.resource_estimation.ResourceConfig.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceConfig.html",
      "context": "                                         qml.labs.resource_estimation.ResourceConfig — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.ResourceControlled",
      "name": "qml.labs.resource_estimation.ResourceControlled",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceControlled. Found in pennylane.labs.resource_estimation.ResourceControlled.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceControlled.html",
      "context": "                                         qml.labs.resource_estimation.ResourceControlled — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceControlledPhaseShift",
      "name": "qml.labs.resource_estimation.ResourceControlledPhaseShift",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceControlledPhaseShift. Found in pennylane.labs.resource_estimation.ResourceControlledPhaseShift.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceControlledPhaseShift.html",
      "context": "                                         qml.labs.resource_estimation.ResourceControlledPhaseShift — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceControlledSequence",
      "name": "qml.labs.resource_estimation.ResourceControlledSequence",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceControlledSequence. Found in pennylane.labs.resource_estimation.ResourceControlledSequence.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceControlledSequence.html",
      "context": "                                         qml.labs.resource_estimation.ResourceControlledSequence — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceGlobalPhase",
      "name": "qml.labs.resource_estimation.ResourceGlobalPhase",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceGlobalPhase. Found in pennylane.labs.resource_estimation.ResourceGlobalPhase.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceGlobalPhase.html",
      "context": "                                         qml.labs.resource_estimation.ResourceGlobalPhase — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceHadamard",
      "name": "qml.labs.resource_estimation.ResourceHadamard",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceHadamard. Found in pennylane.labs.resource_estimation.ResourceHadamard.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceHadamard.html",
      "context": "                                         qml.labs.resource_estimation.ResourceHadamard — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIdentity",
      "name": "qml.labs.resource_estimation.ResourceIdentity",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIdentity. Found in pennylane.labs.resource_estimation.ResourceIdentity.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIdentity.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIdentity — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIntegerComparator",
      "name": "qml.labs.resource_estimation.ResourceIntegerComparator",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIntegerComparator. Found in pennylane.labs.resource_estimation.ResourceIntegerComparator.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIntegerComparator.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIntegerComparator — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIsingXX",
      "name": "qml.labs.resource_estimation.ResourceIsingXX",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIsingXX. Found in pennylane.labs.resource_estimation.ResourceIsingXX.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIsingXX.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIsingXX — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIsingXY",
      "name": "qml.labs.resource_estimation.ResourceIsingXY",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIsingXY. Found in pennylane.labs.resource_estimation.ResourceIsingXY.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIsingXY.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIsingXY — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIsingYY",
      "name": "qml.labs.resource_estimation.ResourceIsingYY",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIsingYY. Found in pennylane.labs.resource_estimation.ResourceIsingYY.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIsingYY.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIsingYY — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIsingZZ",
      "name": "qml.labs.resource_estimation.ResourceIsingZZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIsingZZ. Found in pennylane.labs.resource_estimation.ResourceIsingZZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIsingZZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIsingZZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceIterativeQPE",
      "name": "qml.labs.resource_estimation.ResourceIterativeQPE",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceIterativeQPE. Found in pennylane.labs.resource_estimation.ResourceIterativeQPE.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceIterativeQPE.html",
      "context": "                                         qml.labs.resource_estimation.ResourceIterativeQPE — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceMPSPrep",
      "name": "qml.labs.resource_estimation.ResourceMPSPrep",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceMPSPrep. Found in pennylane.labs.resource_estimation.ResourceMPSPrep.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceMPSPrep.html",
      "context": "                                         qml.labs.resource_estimation.ResourceMPSPrep — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceMultiControlledX",
      "name": "qml.labs.resource_estimation.ResourceMultiControlledX",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceMultiControlledX. Found in pennylane.labs.resource_estimation.ResourceMultiControlledX.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceMultiControlledX.html",
      "context": "                                         qml.labs.resource_estimation.ResourceMultiControlledX — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceMultiRZ",
      "name": "qml.labs.resource_estimation.ResourceMultiRZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceMultiRZ. Found in pennylane.labs.resource_estimation.ResourceMultiRZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceMultiRZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceMultiRZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceOperator",
      "name": "qml.labs.resource_estimation.ResourceOperator",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceOperator. Found in pennylane.labs.resource_estimation.ResourceOperator.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceOperator.html",
      "context": "                                         qml.labs.resource_estimation.ResourceOperator — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceOutMultiplier",
      "name": "qml.labs.resource_estimation.ResourceOutMultiplier",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceOutMultiplier. Found in pennylane.labs.resource_estimation.ResourceOutMultiplier.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceOutMultiplier.html",
      "context": "                                         qml.labs.resource_estimation.ResourceOutMultiplier — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceOutOfPlaceSquare",
      "name": "qml.labs.resource_estimation.ResourceOutOfPlaceSquare",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceOutOfPlaceSquare. Found in pennylane.labs.resource_estimation.ResourceOutOfPlaceSquare.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceOutOfPlaceSquare.html",
      "context": "                                         qml.labs.resource_estimation.ResourceOutOfPlaceSquare — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourcePSWAP",
      "name": "qml.labs.resource_estimation.ResourcePSWAP",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourcePSWAP. Found in pennylane.labs.resource_estimation.ResourcePSWAP.html",
      "source_file": "pennylane.labs.resource_estimation.ResourcePSWAP.html",
      "context": "                                         qml.labs.resource_estimation.ResourcePSWAP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourcePauliRot",
      "name": "qml.labs.resource_estimation.ResourcePauliRot",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourcePauliRot. Found in pennylane.labs.resource_estimation.ResourcePauliRot.html",
      "source_file": "pennylane.labs.resource_estimation.ResourcePauliRot.html",
      "context": "                                         qml.labs.resource_estimation.ResourcePauliRot — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourcePhaseGradient",
      "name": "qml.labs.resource_estimation.ResourcePhaseGradient",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourcePhaseGradient. Found in pennylane.labs.resource_estimation.ResourcePhaseGradient.html",
      "source_file": "pennylane.labs.resource_estimation.ResourcePhaseGradient.html",
      "context": "                                         qml.labs.resource_estimation.ResourcePhaseGradient — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourcePhaseShift",
      "name": "qml.labs.resource_estimation.ResourcePhaseShift",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourcePhaseShift. Found in pennylane.labs.resource_estimation.ResourcePhaseShift.html",
      "source_file": "pennylane.labs.resource_estimation.ResourcePhaseShift.html",
      "context": "                                         qml.labs.resource_estimation.ResourcePhaseShift — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourcePow",
      "name": "qml.labs.resource_estimation.ResourcePow",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourcePow. Found in pennylane.labs.resource_estimation.ResourcePow.html",
      "source_file": "pennylane.labs.resource_estimation.ResourcePow.html",
      "context": "                                         qml.labs.resource_estimation.ResourcePow — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourcePrepTHC",
      "name": "qml.labs.resource_estimation.ResourcePrepTHC",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourcePrepTHC. Found in pennylane.labs.resource_estimation.ResourcePrepTHC.html",
      "source_file": "pennylane.labs.resource_estimation.ResourcePrepTHC.html",
      "context": "                                         qml.labs.resource_estimation.ResourcePrepTHC — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceProd",
      "name": "qml.labs.resource_estimation.ResourceProd",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceProd. Found in pennylane.labs.resource_estimation.ResourceProd.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceProd.html",
      "context": "                                         qml.labs.resource_estimation.ResourceProd — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceQFT",
      "name": "qml.labs.resource_estimation.ResourceQFT",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceQFT. Found in pennylane.labs.resource_estimation.ResourceQFT.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceQFT.html",
      "context": "                                         qml.labs.resource_estimation.ResourceQFT — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceQPE",
      "name": "qml.labs.resource_estimation.ResourceQPE",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceQPE. Found in pennylane.labs.resource_estimation.ResourceQPE.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceQPE.html",
      "context": "                                         qml.labs.resource_estimation.ResourceQPE — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceQROM",
      "name": "qml.labs.resource_estimation.ResourceQROM",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceQROM. Found in pennylane.labs.resource_estimation.ResourceQROM.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceQROM.html",
      "context": "                                         qml.labs.resource_estimation.ResourceQROM — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceQROMStatePreparation",
      "name": "qml.labs.resource_estimation.ResourceQROMStatePreparation",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceQROMStatePreparation. Found in pennylane.labs.resource_estimation.ResourceQROMStatePreparation.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceQROMStatePreparation.html",
      "context": "                                         qml.labs.resource_estimation.ResourceQROMStatePreparation — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceQubitUnitary",
      "name": "qml.labs.resource_estimation.ResourceQubitUnitary",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceQubitUnitary. Found in pennylane.labs.resource_estimation.ResourceQubitUnitary.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceQubitUnitary.html",
      "context": "                                         qml.labs.resource_estimation.ResourceQubitUnitary — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceQubitizeTHC",
      "name": "qml.labs.resource_estimation.ResourceQubitizeTHC",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceQubitizeTHC. Found in pennylane.labs.resource_estimation.ResourceQubitizeTHC.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceQubitizeTHC.html",
      "context": "                                         qml.labs.resource_estimation.ResourceQubitizeTHC — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceRX",
      "name": "qml.labs.resource_estimation.ResourceRX",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceRX. Found in pennylane.labs.resource_estimation.ResourceRX.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceRX.html",
      "context": "                                         qml.labs.resource_estimation.ResourceRX — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceRY",
      "name": "qml.labs.resource_estimation.ResourceRY",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceRY. Found in pennylane.labs.resource_estimation.ResourceRY.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceRY.html",
      "context": "                                         qml.labs.resource_estimation.ResourceRY — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceRZ",
      "name": "qml.labs.resource_estimation.ResourceRZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceRZ. Found in pennylane.labs.resource_estimation.ResourceRZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceRZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceRZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceRegisterComparator",
      "name": "qml.labs.resource_estimation.ResourceRegisterComparator",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceRegisterComparator. Found in pennylane.labs.resource_estimation.ResourceRegisterComparator.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceRegisterComparator.html",
      "context": "                                         qml.labs.resource_estimation.ResourceRegisterComparator — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceRot",
      "name": "qml.labs.resource_estimation.ResourceRot",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceRot. Found in pennylane.labs.resource_estimation.ResourceRot.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceRot.html",
      "context": "                                         qml.labs.resource_estimation.ResourceRot — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceS",
      "name": "qml.labs.resource_estimation.ResourceS",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceS. Found in pennylane.labs.resource_estimation.ResourceS.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceS.html",
      "context": "                                         qml.labs.resource_estimation.ResourceS — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSWAP",
      "name": "qml.labs.resource_estimation.ResourceSWAP",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSWAP. Found in pennylane.labs.resource_estimation.ResourceSWAP.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSWAP.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSWAP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSelect",
      "name": "qml.labs.resource_estimation.ResourceSelect",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSelect. Found in pennylane.labs.resource_estimation.ResourceSelect.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSelect.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSelect — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSelectPauliRot",
      "name": "qml.labs.resource_estimation.ResourceSelectPauliRot",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSelectPauliRot. Found in pennylane.labs.resource_estimation.ResourceSelectPauliRot.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSelectPauliRot.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSelectPauliRot — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSelectTHC",
      "name": "qml.labs.resource_estimation.ResourceSelectTHC",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSelectTHC. Found in pennylane.labs.resource_estimation.ResourceSelectTHC.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSelectTHC.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSelectTHC — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSemiAdder",
      "name": "qml.labs.resource_estimation.ResourceSemiAdder",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSemiAdder. Found in pennylane.labs.resource_estimation.ResourceSemiAdder.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSemiAdder.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSemiAdder — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSingleExcitation",
      "name": "qml.labs.resource_estimation.ResourceSingleExcitation",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSingleExcitation. Found in pennylane.labs.resource_estimation.ResourceSingleExcitation.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSingleExcitation.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSingleExcitation — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceSingleQubitComparator",
      "name": "qml.labs.resource_estimation.ResourceSingleQubitComparator",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceSingleQubitComparator. Found in pennylane.labs.resource_estimation.ResourceSingleQubitComparator.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceSingleQubitComparator.html",
      "context": "                                         qml.labs.resource_estimation.ResourceSingleQubitComparator — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceT",
      "name": "qml.labs.resource_estimation.ResourceT",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceT. Found in pennylane.labs.resource_estimation.ResourceT.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceT.html",
      "context": "                                         qml.labs.resource_estimation.ResourceT — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTempAND",
      "name": "qml.labs.resource_estimation.ResourceTempAND",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTempAND. Found in pennylane.labs.resource_estimation.ResourceTempAND.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTempAND.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTempAND — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceToffoli",
      "name": "qml.labs.resource_estimation.ResourceToffoli",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceToffoli. Found in pennylane.labs.resource_estimation.ResourceToffoli.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceToffoli.html",
      "context": "                                         qml.labs.resource_estimation.ResourceToffoli — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTrotterCDF",
      "name": "qml.labs.resource_estimation.ResourceTrotterCDF",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTrotterCDF. Found in pennylane.labs.resource_estimation.ResourceTrotterCDF.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTrotterCDF.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTrotterCDF — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTrotterProduct",
      "name": "qml.labs.resource_estimation.ResourceTrotterProduct",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTrotterProduct. Found in pennylane.labs.resource_estimation.ResourceTrotterProduct.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTrotterProduct.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTrotterProduct — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTrotterTHC",
      "name": "qml.labs.resource_estimation.ResourceTrotterTHC",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTrotterTHC. Found in pennylane.labs.resource_estimation.ResourceTrotterTHC.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTrotterTHC.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTrotterTHC — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTrotterVibrational",
      "name": "qml.labs.resource_estimation.ResourceTrotterVibrational",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTrotterVibrational. Found in pennylane.labs.resource_estimation.ResourceTrotterVibrational.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTrotterVibrational.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTrotterVibrational — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTrotterVibronic",
      "name": "qml.labs.resource_estimation.ResourceTrotterVibronic",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTrotterVibronic. Found in pennylane.labs.resource_estimation.ResourceTrotterVibronic.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTrotterVibronic.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTrotterVibronic — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceTwoQubitComparator",
      "name": "qml.labs.resource_estimation.ResourceTwoQubitComparator",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceTwoQubitComparator. Found in pennylane.labs.resource_estimation.ResourceTwoQubitComparator.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceTwoQubitComparator.html",
      "context": "                                         qml.labs.resource_estimation.ResourceTwoQubitComparator — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceUniformStatePrep",
      "name": "qml.labs.resource_estimation.ResourceUniformStatePrep",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceUniformStatePrep. Found in pennylane.labs.resource_estimation.ResourceUniformStatePrep.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceUniformStatePrep.html",
      "context": "                                         qml.labs.resource_estimation.ResourceUniformStatePrep — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceX",
      "name": "qml.labs.resource_estimation.ResourceX",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceX. Found in pennylane.labs.resource_estimation.ResourceX.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceX.html",
      "context": "                                         qml.labs.resource_estimation.ResourceX — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceY",
      "name": "qml.labs.resource_estimation.ResourceY",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceY. Found in pennylane.labs.resource_estimation.ResourceY.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceY.html",
      "context": "                                         qml.labs.resource_estimation.ResourceY — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.ResourceZ",
      "name": "qml.labs.resource_estimation.ResourceZ",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.ResourceZ. Found in pennylane.labs.resource_estimation.ResourceZ.html",
      "source_file": "pennylane.labs.resource_estimation.ResourceZ.html",
      "context": "                                         qml.labs.resource_estimation.ResourceZ — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.resource_estimation.Resources",
      "name": "qml.labs.resource_estimation.Resources",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.Resources. Found in pennylane.labs.resource_estimation.Resources.html",
      "source_file": "pennylane.labs.resource_estimation.Resources.html",
      "context": "                                         qml.labs.resource_estimation.Resources — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.estimate",
      "name": "qml.labs.resource_estimation.estimate",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.estimate. Found in pennylane.labs.resource_estimation.estimate.html",
      "source_file": "pennylane.labs.resource_estimation.estimate.html",
      "context": "                                         qml.labs.resource_estimation.estimate — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.resource_estimation.resource_rep",
      "name": "qml.labs.resource_estimation.resource_rep",
      "type": "function",
      "description": "PennyLane API: labs.resource_estimation.resource_rep. Found in pennylane.labs.resource_estimation.resource_rep.html",
      "source_file": "pennylane.labs.resource_estimation.resource_rep.html",
      "context": "                                         qml.labs.resource_estimation.resource_rep — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.transforms.select_pauli_rot_phase_gradient",
      "name": "qml.labs.transforms.select_pauli_rot_phase_gradient",
      "type": "function",
      "description": "PennyLane API: labs.transforms.select_pauli_rot_phase_gradient. Found in pennylane.labs.transforms.select_pauli_rot_phase_gradient.html",
      "source_file": "pennylane.labs.transforms.select_pauli_rot_phase_gradient.html",
      "context": "                                         qml.labs.transforms.select_pauli_rot_phase_gradient — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transform.",
      "name": "qml.transform.",
      "type": "function",
      "description": "PennyLane API: transform.. Found in pennylane.labs.transforms.select_pauli_rot_phase_gradient.html",
      "source_file": "pennylane.labs.transforms.select_pauli_rot_phase_gradient.html",
      "context": "nd QROM. Needs to be at least \\(b-1\\) wires.   Returns: The transformed circuit as described in qml.transform.  Return type: qnode (QNode) or quantum function (Callable) or tuple[List[QuantumTape], fu"
    },
    {
      "id": "qml.labs.trotter_error.AbstractState",
      "name": "qml.labs.trotter_error.AbstractState",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.AbstractState. Found in pennylane.labs.trotter_error.AbstractState.html",
      "source_file": "pennylane.labs.trotter_error.AbstractState.html",
      "context": "                                         qml.labs.trotter_error.AbstractState — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.Fragment",
      "name": "qml.labs.trotter_error.Fragment",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.Fragment. Found in pennylane.labs.trotter_error.Fragment.html",
      "source_file": "pennylane.labs.trotter_error.Fragment.html",
      "context": "                                         qml.labs.trotter_error.Fragment — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.GenericFragment",
      "name": "qml.labs.trotter_error.GenericFragment",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.GenericFragment. Found in pennylane.labs.trotter_error.GenericFragment.html",
      "source_file": "pennylane.labs.trotter_error.GenericFragment.html",
      "context": "                                         qml.labs.trotter_error.GenericFragment — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.HOState",
      "name": "qml.labs.trotter_error.HOState",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.HOState. Found in pennylane.labs.trotter_error.HOState.html",
      "source_file": "pennylane.labs.trotter_error.HOState.html",
      "context": "                                         qml.labs.trotter_error.HOState — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.ProductFormula",
      "name": "qml.labs.trotter_error.ProductFormula",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.ProductFormula. Found in pennylane.labs.trotter_error.ProductFormula.html",
      "source_file": "pennylane.labs.trotter_error.ProductFormula.html",
      "context": "                                         qml.labs.trotter_error.ProductFormula — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.RealspaceCoeffs",
      "name": "qml.labs.trotter_error.RealspaceCoeffs",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.RealspaceCoeffs. Found in pennylane.labs.trotter_error.RealspaceCoeffs.html",
      "source_file": "pennylane.labs.trotter_error.RealspaceCoeffs.html",
      "context": "                                         qml.labs.trotter_error.RealspaceCoeffs — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.RealspaceMatrix",
      "name": "qml.labs.trotter_error.RealspaceMatrix",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.RealspaceMatrix. Found in pennylane.labs.trotter_error.RealspaceMatrix.html",
      "source_file": "pennylane.labs.trotter_error.RealspaceMatrix.html",
      "context": "                                         qml.labs.trotter_error.RealspaceMatrix — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.RealspaceOperator",
      "name": "qml.labs.trotter_error.RealspaceOperator",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.RealspaceOperator. Found in pennylane.labs.trotter_error.RealspaceOperator.html",
      "source_file": "pennylane.labs.trotter_error.RealspaceOperator.html",
      "context": "                                         qml.labs.trotter_error.RealspaceOperator — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.RealspaceSum",
      "name": "qml.labs.trotter_error.RealspaceSum",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.RealspaceSum. Found in pennylane.labs.trotter_error.RealspaceSum.html",
      "source_file": "pennylane.labs.trotter_error.RealspaceSum.html",
      "context": "                                         qml.labs.trotter_error.RealspaceSum — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.VibronicHO",
      "name": "qml.labs.trotter_error.VibronicHO",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.VibronicHO. Found in pennylane.labs.trotter_error.VibronicHO.html",
      "source_file": "pennylane.labs.trotter_error.VibronicHO.html",
      "context": "                                         qml.labs.trotter_error.VibronicHO — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.bch_expansion",
      "name": "qml.labs.trotter_error.bch_expansion",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.bch_expansion. Found in pennylane.labs.trotter_error.bch_expansion.html",
      "source_file": "pennylane.labs.trotter_error.bch_expansion.html",
      "context": "                                         qml.labs.trotter_error.bch_expansion — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.effective_hamiltonian",
      "name": "qml.labs.trotter_error.effective_hamiltonian",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.effective_hamiltonian. Found in pennylane.labs.trotter_error.effective_hamiltonian.html",
      "source_file": "pennylane.labs.trotter_error.effective_hamiltonian.html",
      "context": "                                         qml.labs.trotter_error.effective_hamiltonian — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.generic_fragments",
      "name": "qml.labs.trotter_error.generic_fragments",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.generic_fragments. Found in pennylane.labs.trotter_error.generic_fragments.html",
      "source_file": "pennylane.labs.trotter_error.generic_fragments.html",
      "context": "                                         qml.labs.trotter_error.generic_fragments — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.perturbation_error",
      "name": "qml.labs.trotter_error.perturbation_error",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.perturbation_error. Found in pennylane.labs.trotter_error.perturbation_error.html",
      "source_file": "pennylane.labs.trotter_error.perturbation_error.html",
      "context": "                                         qml.labs.trotter_error.perturbation_error — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.labs.trotter_error.sparse_fragments",
      "name": "qml.labs.trotter_error.sparse_fragments",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.sparse_fragments. Found in pennylane.labs.trotter_error.sparse_fragments.html",
      "source_file": "pennylane.labs.trotter_error.sparse_fragments.html",
      "context": "                                         qml.labs.trotter_error.sparse_fragments — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.vibrational_fragments",
      "name": "qml.labs.trotter_error.vibrational_fragments",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.vibrational_fragments. Found in pennylane.labs.trotter_error.vibrational_fragments.html",
      "source_file": "pennylane.labs.trotter_error.vibrational_fragments.html",
      "context": "                                         qml.labs.trotter_error.vibrational_fragments — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.labs.trotter_error.vibronic_fragments",
      "name": "qml.labs.trotter_error.vibronic_fragments",
      "type": "function",
      "description": "PennyLane API: labs.trotter_error.vibronic_fragments. Found in pennylane.labs.trotter_error.vibronic_fragments.html",
      "source_file": "pennylane.labs.trotter_error.vibronic_fragments.html",
      "context": "                                         qml.labs.trotter_error.vibronic_fragments — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ECR",
      "name": "qml.ECR",
      "type": "class",
      "description": "PennyLane API: ECR. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "l.DisplacementEmbedding qml.DoubleExcitation qml.DoubleExcitationMinus qml.DoubleExcitationPlus qml.ECR qml.Elbow qml.FABLE qml.FermiA qml.FermiC qml.FermiSentence qml.FermiWord qml.FermionicDoubleExc"
    },
    {
      "id": "qml.TwoLocalSwapNetwork",
      "name": "qml.TwoLocalSwapNetwork",
      "type": "class",
      "description": "PennyLane API: TwoLocalSwapNetwork. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "r qml.ThermalState qml.Toffoli qml.Tracker qml.TritFlip qml.TrotterProduct qml.TrotterizedQfunc qml.TwoLocalSwapNetwork qml.TwoModeSqueezing qml.U1 qml.U2 qml.U3 qml.UCCSD qml.WireCut qml.X qml.Y qml."
    },
    {
      "id": "qml.U1",
      "name": "qml.U1",
      "type": "class",
      "description": "PennyLane API: U1. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "italRotation qml.OutAdder qml.OutMultiplier qml.OutPoly qml.PCPhase qml.PSWAP qml.ParticleConservingU1 qml.ParticleConservingU2 qml.PauliError qml.PauliRot qml.PauliX qml.PauliY qml.PauliZ qml.Permute"
    },
    {
      "id": "qml.GeneralizedAmplitudeDamping",
      "name": "qml.GeneralizedAmplitudeDamping",
      "type": "class",
      "description": "PennyLane API: GeneralizedAmplitudeDamping. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ojector qml.FockStateVector qml.FromBloq qml.GQSP qml.GateFabric qml.GaussianState qml.GellMann qml.GeneralizedAmplitudeDamping qml.GlobalPhase qml.GradientDescentOptimizer qml.GroverOperator qml.H qm"
    },
    {
      "id": "qml.NesterovMomentumOptimizer",
      "name": "qml.NesterovMomentumOptimizer",
      "type": "class",
      "description": "PennyLane API: NesterovMomentumOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "tatePreparation qml.MultiControlledX qml.MultiRZ qml.MultiplexerStatePreparation qml.Multiplier qml.NesterovMomentumOptimizer qml.NoiseModel qml.NumberOperator qml.OrbitalRotation qml.OutAdder qml.Out"
    },
    {
      "id": "qml.ControlledPhase",
      "name": "qml.ControlledPhase",
      "type": "class",
      "description": "PennyLane API: ControlledPhase. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "pply an approximate quantum Fourier transform (AQFT). The AQFT method helps to reduce the number of ControlledPhaseShift operations required for QFT by only using a maximum of order number of Controll"
    },
    {
      "id": "qml.PSWAP",
      "name": "qml.PSWAP",
      "type": "class",
      "description": "PennyLane API: PSWAP. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "l qml.NumberOperator qml.OrbitalRotation qml.OutAdder qml.OutMultiplier qml.OutPoly qml.PCPhase qml.PSWAP qml.ParticleConservingU1 qml.ParticleConservingU2 qml.PauliError qml.PauliRot qml.PauliX qml.P"
    },
    {
      "id": "qml.Configuration",
      "name": "qml.Configuration",
      "type": "class",
      "description": "PennyLane API: Configuration. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "l.CircuitGraph qml.ClassicalShadow qml.CoherentState qml.CommutingEvolution qml.CompilePipeline qml.Configuration qml.ControlledAddition qml.ControlledPhase qml.ControlledPhaseShift qml.ControlledQubi"
    },
    {
      "id": "qml.Rotation",
      "name": "qml.Rotation",
      "type": "class",
      "description": "PennyLane API: Rotation. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "on qml.ArbitraryUnitary qml.BBQRAM qml.Barrier qml.BasicEntanglerLayers qml.BasisEmbedding qml.BasisRotation qml.BasisState qml.Beamsplitter qml.BitFlip qml.BlockEncode qml.BooleanFn qml.BoseSentence "
    },
    {
      "id": "qml.AdamOptimizer",
      "name": "qml.AdamOptimizer",
      "type": "class",
      "description": "PennyLane API: AdamOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "uilding a plugin Adding new operators  API  qml Functions Classes qml.AQFT qml.AdagradOptimizer qml.AdamOptimizer qml.AdaptiveOptimizer qml.Adder qml.AllSinglesDoubles qml.AmplitudeAmplification qml.A"
    },
    {
      "id": "qml.CPhaseShift10",
      "name": "qml.CPhaseShift10",
      "type": "class",
      "description": "PennyLane API: CPhaseShift10. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "oseSentence qml.BoseWord qml.CCZ qml.CH qml.CNOT qml.CPhase qml.CPhaseShift00 qml.CPhaseShift01 qml.CPhaseShift10 qml.CRX qml.CRY qml.CRZ qml.CRot qml.CSWAP qml.CVNeuralNetLayers qml.CY qml.CZ qml.Cat"
    },
    {
      "id": "qml.ArbitraryUnitary",
      "name": "qml.ArbitraryUnitary",
      "type": "class",
      "description": "PennyLane API: ArbitraryUnitary. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "qml.AmplitudeEmbedding qml.AngleEmbedding qml.ApproxTimeEvolution qml.ArbitraryStatePreparation qml.ArbitraryUnitary qml.BBQRAM qml.Barrier qml.BasicEntanglerLayers qml.BasisEmbedding qml.BasisRotatio"
    },
    {
      "id": "qml.QuantumMonteCarlo",
      "name": "qml.QuantumMonteCarlo",
      "type": "class",
      "description": "PennyLane API: QuantumMonteCarlo. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": ".QROM qml.QROMStatePreparation qml.QSVT qml.QuadOperator qml.QuadP qml.QuadX qml.QuadraticPhase qml.QuantumMonteCarlo qml.QuantumPhaseEstimation qml.QubitCarry qml.QubitChannel qml.QubitDensityMatrix "
    },
    {
      "id": "qml.CVNeuralNetLayers",
      "name": "qml.CVNeuralNetLayers",
      "type": "class",
      "description": "PennyLane API: CVNeuralNetLayers. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ml.CPhaseShift00 qml.CPhaseShift01 qml.CPhaseShift10 qml.CRX qml.CRY qml.CRZ qml.CRot qml.CSWAP qml.CVNeuralNetLayers qml.CY qml.CZ qml.CatState qml.CircuitGraph qml.ClassicalShadow qml.CoherentState "
    },
    {
      "id": "qml.ThermalState",
      "name": "qml.ThermalState",
      "type": "class",
      "description": "PennyLane API: ThermalState. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "RY qml.TRZ qml.TSWAP qml.TShift qml.TTN qml.TemporaryAND qml.TensorN qml.ThermalRelaxationError qml.ThermalState qml.Toffoli qml.Tracker qml.TritFlip qml.TrotterProduct qml.TrotterizedQfunc qml.TwoLoc"
    },
    {
      "id": "qml.CPhaseShift01",
      "name": "qml.CPhaseShift01",
      "type": "class",
      "description": "PennyLane API: CPhaseShift01. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ml.BooleanFn qml.BoseSentence qml.BoseWord qml.CCZ qml.CH qml.CNOT qml.CPhase qml.CPhaseShift00 qml.CPhaseShift01 qml.CPhaseShift10 qml.CRX qml.CRY qml.CRZ qml.CRot qml.CSWAP qml.CVNeuralNetLayers qml"
    },
    {
      "id": "qml.RMSPropOptimizer",
      "name": "qml.RMSPropOptimizer",
      "type": "class",
      "description": "PennyLane API: RMSPropOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "l.QutritBasisStatePreparation qml.QutritChannel qml.QutritDepolarizingChannel qml.QutritUnitary qml.RMSPropOptimizer qml.RX qml.RY qml.RZ qml.RandomLayers qml.Reflection qml.ResetError qml.RiemannianG"
    },
    {
      "id": "qml.IsingZZ",
      "name": "qml.IsingZZ",
      "type": "class",
      "description": "PennyLane API: IsingZZ. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "egerComparator qml.Interferometer qml.InterferometerUnitary qml.IsingXX qml.IsingXY qml.IsingYY qml.IsingZZ qml.Kerr qml.LocalHilbertSchmidt qml.MERA qml.MPS qml.MPSPrep qml.ModExp qml.MomentumOptimiz"
    },
    {
      "id": "qml.TwoModeSqueezing",
      "name": "qml.TwoModeSqueezing",
      "type": "class",
      "description": "PennyLane API: TwoModeSqueezing. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "offoli qml.Tracker qml.TritFlip qml.TrotterProduct qml.TrotterizedQfunc qml.TwoLocalSwapNetwork qml.TwoModeSqueezing qml.U1 qml.U2 qml.U3 qml.UCCSD qml.WireCut qml.X qml.Y qml.Z qml.grad qml.jacobian "
    },
    {
      "id": "qml.DoubleExcitationPlus",
      "name": "qml.DoubleExcitationPlus",
      "type": "class",
      "description": "PennyLane API: DoubleExcitationPlus. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "State qml.Displacement qml.DisplacementEmbedding qml.DoubleExcitation qml.DoubleExcitationMinus qml.DoubleExcitationPlus qml.ECR qml.Elbow qml.FABLE qml.FermiA qml.FermiC qml.FermiSentence qml.FermiWo"
    },
    {
      "id": "qml.InterferometerUnitary",
      "name": "qml.InterferometerUnitary",
      "type": "class",
      "description": "PennyLane API: InterferometerUnitary. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": " qml.I qml.IQP qml.IQPEmbedding qml.ISWAP qml.Identity qml.IntegerComparator qml.Interferometer qml.InterferometerUnitary qml.IsingXX qml.IsingXY qml.IsingYY qml.IsingZZ qml.Kerr qml.LocalHilbertSchmi"
    },
    {
      "id": "qml.SingleExcitationMinus",
      "name": "qml.SingleExcitationMinus",
      "type": "class",
      "description": "PennyLane API: SingleExcitationMinus. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ctPauliRot qml.SemiAdder qml.ShotAdaptiveOptimizer qml.SimplifiedTwoDesign qml.SingleExcitation qml.SingleExcitationMinus qml.SingleExcitationPlus qml.Snapshot qml.SparseHamiltonian qml.SpecialUnitary"
    },
    {
      "id": "qml.ApproxTimeEvolution",
      "name": "qml.ApproxTimeEvolution",
      "type": "class",
      "description": "PennyLane API: ApproxTimeEvolution. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ubles qml.AmplitudeAmplification qml.AmplitudeDamping qml.AmplitudeEmbedding qml.AngleEmbedding qml.ApproxTimeEvolution qml.ArbitraryStatePreparation qml.ArbitraryUnitary qml.BBQRAM qml.Barrier qml.Ba"
    },
    {
      "id": "qml.FockDensityMatrix",
      "name": "qml.FockDensityMatrix",
      "type": "class",
      "description": "PennyLane API: FockDensityMatrix. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "Word qml.FermionicDoubleExcitation qml.FermionicSWAP qml.FermionicSingleExcitation qml.FlipSign qml.FockDensityMatrix qml.FockState qml.FockStateProjector qml.FockStateVector qml.FromBloq qml.GQSP qml"
    },
    {
      "id": "qml.GaussianState",
      "name": "qml.GaussianState",
      "type": "class",
      "description": "PennyLane API: GaussianState. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "x qml.FockState qml.FockStateProjector qml.FockStateVector qml.FromBloq qml.GQSP qml.GateFabric qml.GaussianState qml.GellMann qml.GeneralizedAmplitudeDamping qml.GlobalPhase qml.GradientDescentOptimi"
    },
    {
      "id": "qml.CrossKerr",
      "name": "qml.CrossKerr",
      "type": "class",
      "description": "PennyLane API: CrossKerr. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": " qml.ControlledQubitUnitary qml.ControlledQutritUnitary qml.ControlledSequence qml.CosineWindow qml.CrossKerr qml.CubicPhase qml.DepolarizingChannel qml.DiagonalQubitUnitary qml.DisplacedSqueezedState"
    },
    {
      "id": "qml.CPhase",
      "name": "qml.CPhase",
      "type": "class",
      "description": "PennyLane API: CPhase. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "qml.BitFlip qml.BlockEncode qml.BooleanFn qml.BoseSentence qml.BoseWord qml.CCZ qml.CH qml.CNOT qml.CPhase qml.CPhaseShift00 qml.CPhaseShift01 qml.CPhaseShift10 qml.CRX qml.CRY qml.CRZ qml.CRot qml.CS"
    },
    {
      "id": "qml.CatState",
      "name": "qml.CatState",
      "type": "class",
      "description": "PennyLane API: CatState. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ml.CPhaseShift10 qml.CRX qml.CRY qml.CRZ qml.CRot qml.CSWAP qml.CVNeuralNetLayers qml.CY qml.CZ qml.CatState qml.CircuitGraph qml.ClassicalShadow qml.CoherentState qml.CommutingEvolution qml.CompilePi"
    },
    {
      "id": "qml.RotosolveOptimizer",
      "name": "qml.RotosolveOptimizer",
      "type": "class",
      "description": "PennyLane API: RotosolveOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ion qml.ResetError qml.RiemannianGradientOptimizer qml.Rot qml.Rotation qml.RotoselectOptimizer qml.RotosolveOptimizer qml.S qml.SISWAP qml.SPSAOptimizer qml.SQISW qml.SWAP qml.SX qml.Select qml.Selec"
    },
    {
      "id": "qml.QutritChannel",
      "name": "qml.QutritChannel",
      "type": "class",
      "description": "PennyLane API: QutritChannel. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": ".QueuingManager qml.QutritAmplitudeDamping qml.QutritBasisState qml.QutritBasisStatePreparation qml.QutritChannel qml.QutritDepolarizingChannel qml.QutritUnitary qml.RMSPropOptimizer qml.RX qml.RY qml"
    },
    {
      "id": "qml.DoubleExcitationMinus",
      "name": "qml.DoubleExcitationMinus",
      "type": "class",
      "description": "PennyLane API: DoubleExcitationMinus. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "tary qml.DisplacedSqueezedState qml.Displacement qml.DisplacementEmbedding qml.DoubleExcitation qml.DoubleExcitationMinus qml.DoubleExcitationPlus qml.ECR qml.Elbow qml.FABLE qml.FermiA qml.FermiC qml"
    },
    {
      "id": "qml.IsingYY",
      "name": "qml.IsingYY",
      "type": "class",
      "description": "PennyLane API: IsingYY. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "tity qml.IntegerComparator qml.Interferometer qml.InterferometerUnitary qml.IsingXX qml.IsingXY qml.IsingYY qml.IsingZZ qml.Kerr qml.LocalHilbertSchmidt qml.MERA qml.MPS qml.MPSPrep qml.ModExp qml.Mom"
    },
    {
      "id": "qml.ResetError",
      "name": "qml.ResetError",
      "type": "class",
      "description": "PennyLane API: ResetError. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "nel qml.QutritUnitary qml.RMSPropOptimizer qml.RX qml.RY qml.RZ qml.RandomLayers qml.Reflection qml.ResetError qml.RiemannianGradientOptimizer qml.Rot qml.Rotation qml.RotoselectOptimizer qml.Rotosolv"
    },
    {
      "id": "qml.DisplacedSqueezedState",
      "name": "qml.DisplacedSqueezedState",
      "type": "class",
      "description": "PennyLane API: DisplacedSqueezedState. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": " qml.CosineWindow qml.CrossKerr qml.CubicPhase qml.DepolarizingChannel qml.DiagonalQubitUnitary qml.DisplacedSqueezedState qml.Displacement qml.DisplacementEmbedding qml.DoubleExcitation qml.DoubleExc"
    },
    {
      "id": "qml.CPhaseShift00",
      "name": "qml.CPhaseShift00",
      "type": "class",
      "description": "PennyLane API: CPhaseShift00. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": " qml.BlockEncode qml.BooleanFn qml.BoseSentence qml.BoseWord qml.CCZ qml.CH qml.CNOT qml.CPhase qml.CPhaseShift00 qml.CPhaseShift01 qml.CPhaseShift10 qml.CRX qml.CRY qml.CRZ qml.CRot qml.CSWAP qml.CVN"
    },
    {
      "id": "qml.MomentumOptimizer",
      "name": "qml.MomentumOptimizer",
      "type": "class",
      "description": "PennyLane API: MomentumOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ml.IsingYY qml.IsingZZ qml.Kerr qml.LocalHilbertSchmidt qml.MERA qml.MPS qml.MPSPrep qml.ModExp qml.MomentumOptimizer qml.MomentumQNGOptimizer qml.MomentumQNGOptimizerQJIT qml.MottonenStatePreparation"
    },
    {
      "id": "qml.AdagradOptimizer",
      "name": "qml.AdagradOptimizer",
      "type": "class",
      "description": "PennyLane API: AdagradOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "  Development guide Building a plugin Adding new operators  API  qml Functions Classes qml.AQFT qml.AdagradOptimizer qml.AdamOptimizer qml.AdaptiveOptimizer qml.Adder qml.AllSinglesDoubles qml.Amplitu"
    },
    {
      "id": "qml.AdaptiveOptimizer",
      "name": "qml.AdaptiveOptimizer",
      "type": "class",
      "description": "PennyLane API: AdaptiveOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "dding new operators  API  qml Functions Classes qml.AQFT qml.AdagradOptimizer qml.AdamOptimizer qml.AdaptiveOptimizer qml.Adder qml.AllSinglesDoubles qml.AmplitudeAmplification qml.AmplitudeDamping qm"
    },
    {
      "id": "qml.AllSinglesDoubles",
      "name": "qml.AllSinglesDoubles",
      "type": "class",
      "description": "PennyLane API: AllSinglesDoubles. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "nctions Classes qml.AQFT qml.AdagradOptimizer qml.AdamOptimizer qml.AdaptiveOptimizer qml.Adder qml.AllSinglesDoubles qml.AmplitudeAmplification qml.AmplitudeDamping qml.AmplitudeEmbedding qml.AngleEm"
    },
    {
      "id": "qml.CoherentState",
      "name": "qml.CoherentState",
      "type": "class",
      "description": "PennyLane API: CoherentState. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "qml.CSWAP qml.CVNeuralNetLayers qml.CY qml.CZ qml.CatState qml.CircuitGraph qml.ClassicalShadow qml.CoherentState qml.CommutingEvolution qml.CompilePipeline qml.Configuration qml.ControlledAddition qm"
    },
    {
      "id": "qml.SingleExcitationPlus",
      "name": "qml.SingleExcitationPlus",
      "type": "class",
      "description": "PennyLane API: SingleExcitationPlus. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ml.ShotAdaptiveOptimizer qml.SimplifiedTwoDesign qml.SingleExcitation qml.SingleExcitationMinus qml.SingleExcitationPlus qml.Snapshot qml.SparseHamiltonian qml.SpecialUnitary qml.SqueezedState qml.Squ"
    },
    {
      "id": "qml.RotoselectOptimizer",
      "name": "qml.RotoselectOptimizer",
      "type": "class",
      "description": "PennyLane API: RotoselectOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "RandomLayers qml.Reflection qml.ResetError qml.RiemannianGradientOptimizer qml.Rot qml.Rotation qml.RotoselectOptimizer qml.RotosolveOptimizer qml.S qml.SISWAP qml.SPSAOptimizer qml.SQISW qml.SWAP qml"
    },
    {
      "id": "qml.SqueezedState",
      "name": "qml.SqueezedState",
      "type": "class",
      "description": "PennyLane API: SqueezedState. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "neWindow qml.CrossKerr qml.CubicPhase qml.DepolarizingChannel qml.DiagonalQubitUnitary qml.DisplacedSqueezedState qml.Displacement qml.DisplacementEmbedding qml.DoubleExcitation qml.DoubleExcitationMi"
    },
    {
      "id": "qml.TSWAP",
      "name": "qml.TSWAP",
      "type": "class",
      "description": "PennyLane API: TSWAP. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "ml.Superposition qml.T qml.TAdd qml.TClock qml.THadamard qml.THermitian qml.TRX qml.TRY qml.TRZ qml.TSWAP qml.TShift qml.TTN qml.TemporaryAND qml.TensorN qml.ThermalRelaxationError qml.ThermalState qm"
    },
    {
      "id": "qml.QNSPSAOptimizer",
      "name": "qml.QNSPSAOptimizer",
      "type": "class",
      "description": "PennyLane API: QNSPSAOptimizer. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "elPrep qml.Projector qml.QAOAEmbedding qml.QDrift qml.QFT qml.QNGOptimizer qml.QNGOptimizerQJIT qml.QNSPSAOptimizer qml.QNode qml.QROM qml.QROMStatePreparation qml.QSVT qml.QuadOperator qml.QuadP qml."
    },
    {
      "id": "qml.ControlledAddition",
      "name": "qml.ControlledAddition",
      "type": "class",
      "description": "PennyLane API: ControlledAddition. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": ".ClassicalShadow qml.CoherentState qml.CommutingEvolution qml.CompilePipeline qml.Configuration qml.ControlledAddition qml.ControlledPhase qml.ControlledPhaseShift qml.ControlledQubitUnitary qml.Contr"
    },
    {
      "id": "qml.CubicPhase",
      "name": "qml.CubicPhase",
      "type": "class",
      "description": "PennyLane API: CubicPhase. Found in pennylane.AQFT.html",
      "source_file": "pennylane.AQFT.html",
      "context": "dQubitUnitary qml.ControlledQutritUnitary qml.ControlledSequence qml.CosineWindow qml.CrossKerr qml.CubicPhase qml.DepolarizingChannel qml.DiagonalQubitUnitary qml.DisplacedSqueezedState qml.Displacem"
    },
    {
      "id": "qml.transforms.core.BoundTransform",
      "name": "qml.transforms.core.BoundTransform",
      "type": "function",
      "description": "PennyLane API: transforms.core.BoundTransform. Found in pennylane.CompilePipeline.html",
      "source_file": "pennylane.CompilePipeline.html",
      "context": "ransforms Transforms library Custom transforms Transforms developer classes qml.CompilePipeline qml.transforms.core.BoundTransform qml.transforms.core.Transform   Transforming circuits Passing argumen"
    },
    {
      "id": "qml.qjit.",
      "name": "qml.qjit.",
      "type": "function",
      "description": "PennyLane API: qjit.. Found in pennylane.MomentumQNGOptimizerQJIT.html",
      "source_file": "pennylane.MomentumQNGOptimizerQJIT.html",
      "context": "5, -1.57079633], dtype=float64)   Make sure you are using the lightning.qubit device along with qml.qjit.    Methods            init(params) Return the initial state of the optimizer.  step(qnode, par"
    },
    {
      "id": "qml.gradients.hadamard_grad.",
      "name": "qml.gradients.hadamard_grad.",
      "type": "function",
      "description": "PennyLane API: gradients.hadamard_grad.. Found in pennylane.QNode.html",
      "source_file": "pennylane.QNode.html",
      "context": " test rule for all supported quantum operation arguments. More info is in the documentation for qml.gradients.hadamard_grad. Reversed, direct, and reversed-direct modes can be selected via a \"mode\" in"
    },
    {
      "id": "qml.gradients.SUPPORTED_GRADIENT_KWARGS.",
      "name": "qml.gradients.SUPPORTED_GRADIENT_KWARGS.",
      "type": "function",
      "description": "PennyLane API: gradients.SUPPORTED_GRADIENT_KWARGS.. Found in pennylane.QNode.html",
      "source_file": "pennylane.QNode.html",
      "context": "atch that of QNode.__init__(). The list of supported gradient keyword arguments can be found at qml.gradients.SUPPORTED_GRADIENT_KWARGS.  Returns: new QNode with updated settings  Return type: qnode ("
    },
    {
      "id": "qml.Hamiltonian.",
      "name": "qml.Hamiltonian.",
      "type": "class",
      "description": "PennyLane API: Hamiltonian.. Found in pennylane.RiemannianGradientOptimizer.html",
      "source_file": "pennylane.RiemannianGradientOptimizer.html",
      "context": " a user-defined circuit that does not take any arguments and returns the expectation value of a qml.Hamiltonian. stepsize (float) – the user-defined hyperparameter \\(\\epsilon\\) (default value: 0.01). "
    },
    {
      "id": "qml.RX.",
      "name": "qml.RX.",
      "type": "class",
      "description": "PennyLane API: RX.. Found in pennylane.Tracker.html",
      "source_file": "pennylane.Tracker.html",
      "context": "kes three total evaluations: one forward pass and one batch of length two for the derivative of qml.RX.     Usage Details        Note With backpropagation, this function should take qnode.device inste"
    },
    {
      "id": "qml.fold_global",
      "name": "qml.fold_global",
      "type": "function",
      "description": "PennyLane API: fold_global. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "hot qml.eigvals qml.equal qml.evolve qml.execute qml.exp qml.exponential_extrapolate qml.expval qml.fold_global qml.for_loop qml.from_openfermion qml.from_pyquil qml.from_qasm qml.from_qasm3 qml.from_"
    },
    {
      "id": "qml.poly_extrapolate",
      "name": "qml.poly_extrapolate",
      "type": "function",
      "description": "PennyLane API: poly_extrapolate. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "matching qml.pattern_matching_optimization qml.pauli_decompose qml.pauli_measure qml.paulix_ops qml.poly_extrapolate qml.poly_to_angles qml.pow qml.probs qml.prod qml.purity qml.qjit qml.qnode qml.qsv"
    },
    {
      "id": "qml.comm",
      "name": "qml.comm",
      "type": "function",
      "description": "PennyLane API: comm. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": " qml.change_op_basis qml.christiansen_mapping qml.classical_shadow qml.clifford_t_decomposition qml.comm qml.commutation_dag qml.commutator qml.compile qml.cond qml.counts qml.ctrl qml.cut_circuit qml"
    },
    {
      "id": "qml.apply_controlled_Q",
      "name": "qml.apply_controlled_Q",
      "type": "function",
      "description": "PennyLane API: apply_controlled_Q. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "bout qml.add_decomps qml.add_noise qml.adjoint qml.adjoint_metric_tensor qml.allocate qml.apply qml.apply_controlled_Q qml.assert_equal qml.batch_input qml.batch_params qml.batch_partial qml.binary_ma"
    },
    {
      "id": "qml.refresh_devices",
      "name": "qml.refresh_devices",
      "type": "function",
      "description": "PennyLane API: refresh_devices. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "ngles qml.pow qml.probs qml.prod qml.purity qml.qjit qml.qnode qml.qsvt qml.quantum_monte_carlo qml.refresh_devices qml.register_condition qml.register_resources qml.registers qml.resource_rep qml.ric"
    },
    {
      "id": "qml.import_operator",
      "name": "qml.import_operator",
      "type": "function",
      "description": "PennyLane API: import_operator. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "om_qiskit_noise qml.from_qiskit_op qml.from_quil qml.from_quil_file qml.generator qml.gridsynth qml.import_operator qml.insert qml.is_commuting qml.is_hermitian qml.is_unitary qml.iterative_qpe qml.jo"
    },
    {
      "id": "qml.order_states",
      "name": "qml.order_states",
      "type": "function",
      "description": "PennyLane API: order_states. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "wires qml.marker qml.matrix qml.measure qml.metric_tensor qml.mitigate_with_zne qml.mutual_info qml.order_states qml.parity_transform qml.pattern_matching qml.pattern_matching_optimization qml.pauli_d"
    },
    {
      "id": "qml.gridsynth",
      "name": "qml.gridsynth",
      "type": "function",
      "description": "PennyLane API: gridsynth. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "_qiskit qml.from_qiskit_noise qml.from_qiskit_op qml.from_quil qml.from_quil_file qml.generator qml.gridsynth qml.import_operator qml.insert qml.is_commuting qml.is_hermitian qml.is_unitary qml.iterat"
    },
    {
      "id": "qml.exponential_extrapolate",
      "name": "qml.exponential_extrapolate",
      "type": "function",
      "description": "PennyLane API: exponential_extrapolate. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "qml.draw qml.draw_mpl qml.dynamic_one_shot qml.eigvals qml.equal qml.evolve qml.execute qml.exp qml.exponential_extrapolate qml.expval qml.fold_global qml.for_loop qml.from_openfermion qml.from_pyquil"
    },
    {
      "id": "qml.pattern_matching_optimization",
      "name": "qml.pattern_matching_optimization",
      "type": "function",
      "description": "PennyLane API: pattern_matching_optimization. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "ml.mitigate_with_zne qml.mutual_info qml.order_states qml.parity_transform qml.pattern_matching qml.pattern_matching_optimization qml.pauli_decompose qml.pauli_measure qml.paulix_ops qml.poly_extrapol"
    },
    {
      "id": "qml.insert",
      "name": "qml.insert",
      "type": "function",
      "description": "PennyLane API: insert. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "from_qiskit_op qml.from_quil qml.from_quil_file qml.generator qml.gridsynth qml.import_operator qml.insert qml.is_commuting qml.is_hermitian qml.is_unitary qml.iterative_qpe qml.jordan_wigner qml.jvp "
    },
    {
      "id": "qml.paulix_ops",
      "name": "qml.paulix_ops",
      "type": "function",
      "description": "PennyLane API: paulix_ops. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "rm qml.pattern_matching qml.pattern_matching_optimization qml.pauli_decompose qml.pauli_measure qml.paulix_ops qml.poly_extrapolate qml.poly_to_angles qml.pow qml.probs qml.prod qml.purity qml.qjit qm"
    },
    {
      "id": "qml.version",
      "name": "qml.version",
      "type": "function",
      "description": "PennyLane API: version. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "ion qml.to_openqasm qml.transform qml.transform_angles qml.trotterize qml.unary_mapping qml.var qml.version qml.vjp qml.vn_entropy qml.while_loop   Classes Variables   qml.bose qml.compiler qml.data q"
    },
    {
      "id": "qml.mitigate_with_zne",
      "name": "qml.mitigate_with_zne",
      "type": "function",
      "description": "PennyLane API: mitigate_with_zne. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": ".lie_closure qml.list_decomps qml.map_wires qml.marker qml.matrix qml.measure qml.metric_tensor qml.mitigate_with_zne qml.mutual_info qml.order_states qml.parity_transform qml.pattern_matching qml.pat"
    },
    {
      "id": "qml.richardson_extrapolate",
      "name": "qml.richardson_extrapolate",
      "type": "function",
      "description": "PennyLane API: richardson_extrapolate. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "ml.refresh_devices qml.register_condition qml.register_resources qml.registers qml.resource_rep qml.richardson_extrapolate qml.right_canonicalize_mps qml.s_prod qml.sample qml.set_shots qml.shadow_exp"
    },
    {
      "id": "qml.symmetry_generators",
      "name": "qml.symmetry_generators",
      "type": "function",
      "description": "PennyLane API: symmetry_generators. Found in pennylane.about.html",
      "source_file": "pennylane.about.html",
      "context": "ml.shadow_expval qml.simplify qml.snapshots qml.specs qml.state qml.structure_constants qml.sum qml.symmetry_generators qml.taper qml.taper_operation qml.to_bloq qml.to_openfermion qml.to_openqasm qml"
    },
    {
      "id": "qml.register_resources.",
      "name": "qml.register_resources.",
      "type": "function",
      "description": "PennyLane API: register_resources.. Found in pennylane.add_decomps.html",
      "source_file": "pennylane.add_decomps.html",
      "context": " given op_type. A decomposition is a quantum function registered with a resource estimate using qml.register_resources.     See also register_resources() and list_decomps  Example This example demonst"
    },
    {
      "id": "qml.boolean_fn.And",
      "name": "qml.boolean_fn.And",
      "type": "function",
      "description": "PennyLane API: boolean_fn.And. Found in pennylane.boolean_fn.And.html",
      "source_file": "pennylane.boolean_fn.And.html",
      "context": "                                         qml.boolean_fn.And — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.boolean_fn.Not",
      "name": "qml.boolean_fn.Not",
      "type": "function",
      "description": "PennyLane API: boolean_fn.Not. Found in pennylane.boolean_fn.Not.html",
      "source_file": "pennylane.boolean_fn.Not.html",
      "context": "                                         qml.boolean_fn.Not — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.boolean_fn.Or",
      "name": "qml.boolean_fn.Or",
      "type": "function",
      "description": "PennyLane API: boolean_fn.Or. Found in pennylane.boolean_fn.Or.html",
      "source_file": "pennylane.boolean_fn.Or.html",
      "context": "                                         qml.boolean_fn.Or — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.boolean_fn.Xor",
      "name": "qml.boolean_fn.Xor",
      "type": "function",
      "description": "PennyLane API: boolean_fn.Xor. Found in pennylane.boolean_fn.Xor.html",
      "source_file": "pennylane.boolean_fn.Xor.html",
      "context": "                                         qml.boolean_fn.Xor — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.bose.binary_mapping",
      "name": "qml.bose.binary_mapping",
      "type": "function",
      "description": "PennyLane API: bose.binary_mapping. Found in pennylane.bose.binary_mapping.html",
      "source_file": "pennylane.bose.binary_mapping.html",
      "context": "                                         qml.bose.binary_mapping — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.bose.christiansen_mapping",
      "name": "qml.bose.christiansen_mapping",
      "type": "function",
      "description": "PennyLane API: bose.christiansen_mapping. Found in pennylane.bose.binary_mapping.html",
      "source_file": "pennylane.bose.binary_mapping.html",
      "context": "Word and BoseSentence Mapping to qubit operators qml.bose.binary_mapping qml.bose.unary_mapping qml.bose.christiansen_mapping     qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.e"
    },
    {
      "id": "qml.bose.unary_mapping",
      "name": "qml.bose.unary_mapping",
      "type": "function",
      "description": "PennyLane API: bose.unary_mapping. Found in pennylane.bose.binary_mapping.html",
      "source_file": "pennylane.bose.binary_mapping.html",
      "context": " qml.bose Overview BoseWord and BoseSentence Mapping to qubit operators qml.bose.binary_mapping qml.bose.unary_mapping qml.bose.christiansen_mapping     qml.compiler qml.data qml.decomposition qml.deb"
    },
    {
      "id": "qml.capture.primitives.cond_prim",
      "name": "qml.capture.primitives.cond_prim",
      "type": "function",
      "description": "PennyLane API: capture.primitives.cond_prim. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "erator qml.capture.primitives.AbstractMeasurement qml.capture.primitives.adjoint_transform_prim qml.capture.primitives.cond_prim qml.capture.primitives.ctrl_transform_prim qml.capture.primitives.for_l"
    },
    {
      "id": "qml.capture.disable_autograph",
      "name": "qml.capture.disable_autograph",
      "type": "function",
      "description": "PennyLane API: capture.disable_autograph. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "acted_axes qml.capture.expand_plxpr_transforms qml.capture.eval_jaxpr qml.capture.run_autograph qml.capture.disable_autograph qml.capture.PlxprInterpreter qml.capture.FlatFn FlatFn   qml.capture.make_"
    },
    {
      "id": "qml.capture.PlxprInterpreter",
      "name": "qml.capture.PlxprInterpreter",
      "type": "function",
      "description": "PennyLane API: capture.PlxprInterpreter. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "plxpr_transforms qml.capture.eval_jaxpr qml.capture.run_autograph qml.capture.disable_autograph qml.capture.PlxprInterpreter qml.capture.FlatFn FlatFn   qml.capture.make_plxpr qml.capture.register_cus"
    },
    {
      "id": "qml.capture.primitives.while_loop_prim",
      "name": "qml.capture.primitives.while_loop_prim",
      "type": "function",
      "description": "PennyLane API: capture.primitives.while_loop_prim. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "ives.ctrl_transform_prim qml.capture.primitives.for_loop_prim qml.capture.primitives.qnode_prim qml.capture.primitives.while_loop_prim qml.tape.plxpr_to_tape   qml.concurrency qml.devices qml.exceptio"
    },
    {
      "id": "qml.capture.run_autograph",
      "name": "qml.capture.run_autograph",
      "type": "function",
      "description": "PennyLane API: capture.run_autograph. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "ml.capture.determine_abstracted_axes qml.capture.expand_plxpr_transforms qml.capture.eval_jaxpr qml.capture.run_autograph qml.capture.disable_autograph qml.capture.PlxprInterpreter qml.capture.FlatFn "
    },
    {
      "id": "qml.capture.primitives.qnode_prim",
      "name": "qml.capture.primitives.qnode_prim",
      "type": "function",
      "description": "PennyLane API: capture.primitives.qnode_prim. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "tives.cond_prim qml.capture.primitives.ctrl_transform_prim qml.capture.primitives.for_loop_prim qml.capture.primitives.qnode_prim qml.capture.primitives.while_loop_prim qml.tape.plxpr_to_tape   qml.co"
    },
    {
      "id": "qml.capture.primitives.AbstractMeasurement",
      "name": "qml.capture.primitives.AbstractMeasurement",
      "type": "function",
      "description": "PennyLane API: capture.primitives.AbstractMeasurement. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "ure.make_plxpr qml.capture.register_custom_staging_rule qml.capture.primitives.AbstractOperator qml.capture.primitives.AbstractMeasurement qml.capture.primitives.adjoint_transform_prim qml.capture.pri"
    },
    {
      "id": "qml.capture.primitives.AbstractOperator",
      "name": "qml.capture.primitives.AbstractOperator",
      "type": "function",
      "description": "PennyLane API: capture.primitives.AbstractOperator. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "ter qml.capture.FlatFn FlatFn   qml.capture.make_plxpr qml.capture.register_custom_staging_rule qml.capture.primitives.AbstractOperator qml.capture.primitives.AbstractMeasurement qml.capture.primitive"
    },
    {
      "id": "qml.capture.primitives.ctrl_transform_prim",
      "name": "qml.capture.primitives.ctrl_transform_prim",
      "type": "function",
      "description": "PennyLane API: capture.primitives.ctrl_transform_prim. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "tractMeasurement qml.capture.primitives.adjoint_transform_prim qml.capture.primitives.cond_prim qml.capture.primitives.ctrl_transform_prim qml.capture.primitives.for_loop_prim qml.capture.primitives.q"
    },
    {
      "id": "qml.capture.primitives.adjoint_transform_prim",
      "name": "qml.capture.primitives.adjoint_transform_prim",
      "type": "function",
      "description": "PennyLane API: capture.primitives.adjoint_transform_prim. Found in pennylane.capture.FlatFn.html",
      "source_file": "pennylane.capture.FlatFn.html",
      "context": "staging_rule qml.capture.primitives.AbstractOperator qml.capture.primitives.AbstractMeasurement qml.capture.primitives.adjoint_transform_prim qml.capture.primitives.cond_prim qml.capture.primitives.ct"
    },
    {
      "id": "qml.compile.",
      "name": "qml.compile.",
      "type": "function",
      "description": "PennyLane API: compile.. Found in pennylane.compile.html",
      "source_file": "pennylane.compile.html",
      "context": "─────RX(0.30)─╰Y──Y─┤   You can change up the set of transforms by passing a custom pipeline to qml.compile. The pipeline is a list of transform functions. Furthermore, you can specify a number of pas"
    },
    {
      "id": "qml.concurrency.executors.base.ExecBackendConfig",
      "name": "qml.concurrency.executors.base.ExecBackendConfig",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.base.ExecBackendConfig. Found in pennylane.concurrency.executors.base.ExecBackendConfig.html",
      "source_file": "pennylane.concurrency.executors.base.ExecBackendConfig.html",
      "context": "                                         qml.concurrency.executors.base.ExecBackendConfig — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.base.ExtExec",
      "name": "qml.concurrency.executors.base.ExtExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.base.ExtExec. Found in pennylane.concurrency.executors.base.ExtExec.html",
      "source_file": "pennylane.concurrency.executors.base.ExtExec.html",
      "context": "                                         qml.concurrency.executors.base.ExtExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.base.IntExec",
      "name": "qml.concurrency.executors.base.IntExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.base.IntExec. Found in pennylane.concurrency.executors.base.IntExec.html",
      "source_file": "pennylane.concurrency.executors.base.IntExec.html",
      "context": "                                         qml.concurrency.executors.base.IntExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.base.RemoteExec",
      "name": "qml.concurrency.executors.base.RemoteExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.base.RemoteExec. Found in pennylane.concurrency.executors.base.RemoteExec.html",
      "source_file": "pennylane.concurrency.executors.base.RemoteExec.html",
      "context": "                                         qml.concurrency.executors.base.RemoteExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.external.dask.DaskExec",
      "name": "qml.concurrency.executors.external.dask.DaskExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.external.dask.DaskExec. Found in pennylane.concurrency.executors.external.dask.DaskExec.html",
      "source_file": "pennylane.concurrency.executors.external.dask.DaskExec.html",
      "context": "                                         qml.concurrency.executors.external.dask.DaskExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.external.mpi.MPICommExec",
      "name": "qml.concurrency.executors.external.mpi.MPICommExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.external.mpi.MPICommExec. Found in pennylane.concurrency.executors.external.mpi.MPICommExec.html",
      "source_file": "pennylane.concurrency.executors.external.mpi.MPICommExec.html",
      "context": "                                         qml.concurrency.executors.external.mpi.MPICommExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.external.mpi.MPIPoolExec",
      "name": "qml.concurrency.executors.external.mpi.MPIPoolExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.external.mpi.MPIPoolExec. Found in pennylane.concurrency.executors.external.mpi.MPIPoolExec.html",
      "source_file": "pennylane.concurrency.executors.external.mpi.MPIPoolExec.html",
      "context": "                                         qml.concurrency.executors.external.mpi.MPIPoolExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.native.api.PyNativeExec",
      "name": "qml.concurrency.executors.native.api.PyNativeExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.native.api.PyNativeExec. Found in pennylane.concurrency.executors.native.api.PyNativeExec.html",
      "source_file": "pennylane.concurrency.executors.native.api.PyNativeExec.html",
      "context": "                                         qml.concurrency.executors.native.api.PyNativeExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.native.conc_futures.ProcPoolExec",
      "name": "qml.concurrency.executors.native.conc_futures.ProcPoolExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.native.conc_futures.ProcPoolExec. Found in pennylane.concurrency.executors.native.conc_futures.ProcPoolExec.html",
      "source_file": "pennylane.concurrency.executors.native.conc_futures.ProcPoolExec.html",
      "context": "                                         qml.concurrency.executors.native.conc_futures.ProcPoolExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.native.conc_futures.ThreadPoolExec",
      "name": "qml.concurrency.executors.native.conc_futures.ThreadPoolExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.native.conc_futures.ThreadPoolExec. Found in pennylane.concurrency.executors.native.conc_futures.ThreadPoolExec.html",
      "source_file": "pennylane.concurrency.executors.native.conc_futures.ThreadPoolExec.html",
      "context": "                                         qml.concurrency.executors.native.conc_futures.ThreadPoolExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  "
    },
    {
      "id": "qml.concurrency.executors.native.multiproc.MPPoolExec",
      "name": "qml.concurrency.executors.native.multiproc.MPPoolExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.native.multiproc.MPPoolExec. Found in pennylane.concurrency.executors.native.multiproc.MPPoolExec.html",
      "source_file": "pennylane.concurrency.executors.native.multiproc.MPPoolExec.html",
      "context": "                                         qml.concurrency.executors.native.multiproc.MPPoolExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.concurrency.executors.native.serial.SerialExec",
      "name": "qml.concurrency.executors.native.serial.SerialExec",
      "type": "function",
      "description": "PennyLane API: concurrency.executors.native.serial.SerialExec. Found in pennylane.concurrency.executors.native.serial.SerialExec.html",
      "source_file": "pennylane.concurrency.executors.native.serial.SerialExec.html",
      "context": "                                         qml.concurrency.executors.native.serial.SerialExec — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.data.DatasetOperator",
      "name": "qml.data.DatasetOperator",
      "type": "function",
      "description": "PennyLane API: data.DatasetOperator. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "etArray qml.data.DatasetScalar qml.data.DatasetString qml.data.DatasetList qml.data.DatasetDict qml.data.DatasetOperator qml.data.DatasetNone qml.data.DatasetMolecule qml.data.DatasetSparseArray qml.d"
    },
    {
      "id": "qml.data.DatasetString",
      "name": "qml.data.DatasetString",
      "type": "function",
      "description": "PennyLane API: data.DatasetString. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "s qml.data.AttributeInfo qml.data.DatasetAttribute qml.data.DatasetArray qml.data.DatasetScalar qml.data.DatasetString qml.data.DatasetList qml.data.DatasetDict qml.data.DatasetOperator qml.data.Datas"
    },
    {
      "id": "qml.data.DatasetMolecule",
      "name": "qml.data.DatasetMolecule",
      "type": "function",
      "description": "PennyLane API: data.DatasetMolecule. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "tString qml.data.DatasetList qml.data.DatasetDict qml.data.DatasetOperator qml.data.DatasetNone qml.data.DatasetMolecule qml.data.DatasetSparseArray qml.data.DatasetJSON qml.data.DatasetTuple   Datase"
    },
    {
      "id": "qml.data.DatasetScalar",
      "name": "qml.data.DatasetScalar",
      "type": "function",
      "description": "PennyLane API: data.DatasetScalar. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "s qml.data.list_datasets qml.data.AttributeInfo qml.data.DatasetAttribute qml.data.DatasetArray qml.data.DatasetScalar qml.data.DatasetString qml.data.DatasetList qml.data.DatasetDict qml.data.Dataset"
    },
    {
      "id": "qml.data.DatasetNone",
      "name": "qml.data.DatasetNone",
      "type": "function",
      "description": "PennyLane API: data.DatasetNone. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "calar qml.data.DatasetString qml.data.DatasetList qml.data.DatasetDict qml.data.DatasetOperator qml.data.DatasetNone qml.data.DatasetMolecule qml.data.DatasetSparseArray qml.data.DatasetJSON qml.data."
    },
    {
      "id": "qml.data.DatasetNotWriteableError",
      "name": "qml.data.DatasetNotWriteableError",
      "type": "function",
      "description": "PennyLane API: data.DatasetNotWriteableError. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": " qml qml.bose qml.compiler qml.data Overview qml.data.attribute qml.data.field qml.data.Dataset qml.data.DatasetNotWriteableError qml.data.load qml.data.load_interactive qml.data.list_attributes qml.d"
    },
    {
      "id": "qml.data.DatasetJSON",
      "name": "qml.data.DatasetJSON",
      "type": "function",
      "description": "PennyLane API: data.DatasetJSON. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": ".data.DatasetOperator qml.data.DatasetNone qml.data.DatasetMolecule qml.data.DatasetSparseArray qml.data.DatasetJSON qml.data.DatasetTuple   Datasets Creating a Dataset Reading and Writing Datasets At"
    },
    {
      "id": "qml.data.AttributeInfo",
      "name": "qml.data.AttributeInfo",
      "type": "function",
      "description": "PennyLane API: data.AttributeInfo. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "                                         qml.data.AttributeInfo — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.data.DatasetAttribute",
      "name": "qml.data.DatasetAttribute",
      "type": "function",
      "description": "PennyLane API: data.DatasetAttribute. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "qml.data.list_attributes qml.data.list_data_names qml.data.list_datasets qml.data.AttributeInfo qml.data.DatasetAttribute qml.data.DatasetArray qml.data.DatasetScalar qml.data.DatasetString qml.data.D"
    },
    {
      "id": "qml.data.list_data_names",
      "name": "qml.data.list_data_names",
      "type": "function",
      "description": "PennyLane API: data.list_data_names. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": ".data.DatasetNotWriteableError qml.data.load qml.data.load_interactive qml.data.list_attributes qml.data.list_data_names qml.data.list_datasets qml.data.AttributeInfo qml.data.DatasetAttribute qml.dat"
    },
    {
      "id": "qml.data.DatasetArray",
      "name": "qml.data.DatasetArray",
      "type": "function",
      "description": "PennyLane API: data.DatasetArray. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "ml.data.list_data_names qml.data.list_datasets qml.data.AttributeInfo qml.data.DatasetAttribute qml.data.DatasetArray qml.data.DatasetScalar qml.data.DatasetString qml.data.DatasetList qml.data.Datase"
    },
    {
      "id": "qml.data.DatasetDict",
      "name": "qml.data.DatasetDict",
      "type": "function",
      "description": "PennyLane API: data.DatasetDict. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "ribute qml.data.DatasetArray qml.data.DatasetScalar qml.data.DatasetString qml.data.DatasetList qml.data.DatasetDict qml.data.DatasetOperator qml.data.DatasetNone qml.data.DatasetMolecule qml.data.Dat"
    },
    {
      "id": "qml.data.DatasetSparseArray",
      "name": "qml.data.DatasetSparseArray",
      "type": "function",
      "description": "PennyLane API: data.DatasetSparseArray. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "ist qml.data.DatasetDict qml.data.DatasetOperator qml.data.DatasetNone qml.data.DatasetMolecule qml.data.DatasetSparseArray qml.data.DatasetJSON qml.data.DatasetTuple   Datasets Creating a Dataset Rea"
    },
    {
      "id": "qml.data.DatasetList",
      "name": "qml.data.DatasetList",
      "type": "function",
      "description": "PennyLane API: data.DatasetList. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": "o qml.data.DatasetAttribute qml.data.DatasetArray qml.data.DatasetScalar qml.data.DatasetString qml.data.DatasetList qml.data.DatasetDict qml.data.DatasetOperator qml.data.DatasetNone qml.data.Dataset"
    },
    {
      "id": "qml.data.DatasetTuple",
      "name": "qml.data.DatasetTuple",
      "type": "function",
      "description": "PennyLane API: data.DatasetTuple. Found in pennylane.data.AttributeInfo.html",
      "source_file": "pennylane.data.AttributeInfo.html",
      "context": " qml.data.DatasetNone qml.data.DatasetMolecule qml.data.DatasetSparseArray qml.data.DatasetJSON qml.data.DatasetTuple   Datasets Creating a Dataset Reading and Writing Datasets Attribute Metadata Decl"
    },
    {
      "id": "qml.decomposition.CompressedResourceOp",
      "name": "qml.decomposition.CompressedResourceOp",
      "type": "function",
      "description": "PennyLane API: decomposition.CompressedResourceOp. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "                                         qml.decomposition.CompressedResourceOp — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.decomposition.Resources",
      "name": "qml.decomposition.Resources",
      "type": "function",
      "description": "PennyLane API: decomposition.Resources. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "resource_rep qml.decomposition.change_op_basis_resource_rep qml.decomposition.DecompositionRule qml.decomposition.Resources qml.decomposition.CompressedResourceOp qml.decomposition.null_decomp   Inspe"
    },
    {
      "id": "qml.decomposition.pow_resource_rep",
      "name": "qml.decomposition.pow_resource_rep",
      "type": "function",
      "description": "PennyLane API: decomposition.pow_resource_rep. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "n.resource_rep qml.decomposition.controlled_resource_rep qml.decomposition.adjoint_resource_rep qml.decomposition.pow_resource_rep qml.decomposition.change_op_basis_resource_rep qml.decomposition.Deco"
    },
    {
      "id": "qml.decomposition.null_decomp",
      "name": "qml.decomposition.null_decomp",
      "type": "function",
      "description": "PennyLane API: decomposition.null_decomp. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "omposition.DecompositionRule qml.decomposition.Resources qml.decomposition.CompressedResourceOp qml.decomposition.null_decomp   Inspecting and Managing Decomposition Rules Integration with the Decompo"
    },
    {
      "id": "qml.decomposition.change_op_basis_resource_rep",
      "name": "qml.decomposition.change_op_basis_resource_rep",
      "type": "function",
      "description": "PennyLane API: decomposition.change_op_basis_resource_rep. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "ntrolled_resource_rep qml.decomposition.adjoint_resource_rep qml.decomposition.pow_resource_rep qml.decomposition.change_op_basis_resource_rep qml.decomposition.DecompositionRule qml.decomposition.Res"
    },
    {
      "id": "qml.decomposition.register_resources",
      "name": "qml.decomposition.register_resources",
      "type": "function",
      "description": "PennyLane API: decomposition.register_resources. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "ph qml.decomposition.disable_graph qml.decomposition.enabled_graph Defining Decomposition Rules qml.decomposition.register_resources qml.decomposition.register_condition qml.decomposition.resource_rep"
    },
    {
      "id": "qml.decomposition.DecompositionRule",
      "name": "qml.decomposition.DecompositionRule",
      "type": "function",
      "description": "PennyLane API: decomposition.DecompositionRule. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "_resource_rep qml.decomposition.pow_resource_rep qml.decomposition.change_op_basis_resource_rep qml.decomposition.DecompositionRule qml.decomposition.Resources qml.decomposition.CompressedResourceOp q"
    },
    {
      "id": "qml.decomposition.resource_rep",
      "name": "qml.decomposition.resource_rep",
      "type": "function",
      "description": "PennyLane API: decomposition.resource_rep. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "g Decomposition Rules qml.decomposition.register_resources qml.decomposition.register_condition qml.decomposition.resource_rep qml.decomposition.controlled_resource_rep qml.decomposition.adjoint_resou"
    },
    {
      "id": "qml.decomposition.register_condition",
      "name": "qml.decomposition.register_condition",
      "type": "function",
      "description": "PennyLane API: decomposition.register_condition. Found in pennylane.decomposition.CompressedResourceOp.html",
      "source_file": "pennylane.decomposition.CompressedResourceOp.html",
      "context": "l.decomposition.enabled_graph Defining Decomposition Rules qml.decomposition.register_resources qml.decomposition.register_condition qml.decomposition.resource_rep qml.decomposition.controlled_resourc"
    },
    {
      "id": "qml.decomposition.DecompGraphSolution",
      "name": "qml.decomposition.DecompGraphSolution",
      "type": "function",
      "description": "PennyLane API: decomposition.DecompGraphSolution. Found in pennylane.decomposition.DecompGraphSolution.html",
      "source_file": "pennylane.decomposition.DecompGraphSolution.html",
      "context": "                                         qml.decomposition.DecompGraphSolution — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.decomposition.DecompositionGraph",
      "name": "qml.decomposition.DecompositionGraph",
      "type": "function",
      "description": "PennyLane API: decomposition.DecompositionGraph. Found in pennylane.decomposition.DecompGraphSolution.html",
      "source_file": "pennylane.decomposition.DecompGraphSolution.html",
      "context": "g Decomposition Rules Integration with the Decompose Transform Graph-based Decomposition Solver qml.decomposition.DecompositionGraph qml.decomposition.DecompGraphSolution   Utility Classes   qml.debug"
    },
    {
      "id": "qml.decomposition.DecompositionError",
      "name": "qml.decomposition.DecompositionError",
      "type": "function",
      "description": "PennyLane API: decomposition.DecompositionError. Found in pennylane.decomposition.DecompositionError.html",
      "source_file": "pennylane.decomposition.DecompositionError.html",
      "context": "                                         qml.decomposition.DecompositionError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.decomposition.add_decomps",
      "name": "qml.decomposition.add_decomps",
      "type": "function",
      "description": "PennyLane API: decomposition.add_decomps. Found in pennylane.decomposition.add_decomps.html",
      "source_file": "pennylane.decomposition.add_decomps.html",
      "context": "                                         qml.decomposition.add_decomps — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.decomposition.list_decomps",
      "name": "qml.decomposition.list_decomps",
      "type": "function",
      "description": "PennyLane API: decomposition.list_decomps. Found in pennylane.decomposition.add_decomps.html",
      "source_file": "pennylane.decomposition.add_decomps.html",
      "context": "g Decomposition Rules Inspecting and Managing Decomposition Rules qml.decomposition.add_decomps qml.decomposition.list_decomps qml.decomposition.has_decomp   Integration with the Decompose Transform G"
    },
    {
      "id": "qml.numpy_version",
      "name": "qml.numpy_version",
      "type": "function",
      "description": "PennyLane API: numpy_version. Found in pennylane.default_config.html",
      "source_file": "pennylane.default_config.html",
      "context": "n Adding new operators  API  qml Functions Classes Variables qml.default_config qml.jax_version qml.numpy_version     qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer qml.esti"
    },
    {
      "id": "qml.default_config",
      "name": "qml.default_config",
      "type": "function",
      "description": "PennyLane API: default_config. Found in pennylane.default_config.html",
      "source_file": "pennylane.default_config.html",
      "context": "                                         qml.default_config — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.jax_version",
      "name": "qml.jax_version",
      "type": "function",
      "description": "PennyLane API: jax_version. Found in pennylane.default_config.html",
      "source_file": "pennylane.default_config.html",
      "context": "Building a plugin Adding new operators  API  qml Functions Classes Variables qml.default_config qml.jax_version qml.numpy_version     qml.bose qml.compiler qml.data qml.decomposition qml.debugging qml"
    },
    {
      "id": "qml.about.",
      "name": "qml.about.",
      "type": "function",
      "description": "PennyLane API: about.. Found in pennylane.device.html",
      "source_file": "pennylane.device.html",
      "context": "ins — see the  available plugins for more details. To list all currently installed devices, run qml.about.  Parameters:  name (str) – the name of the device to load wires (Wires) – the wires (subsyste"
    },
    {
      "id": "qml.devices.DefaultQubit",
      "name": "qml.devices.DefaultQubit",
      "type": "function",
      "description": "PennyLane API: devices.DefaultQubit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "s qml.devices.ExecutionConfig qml.devices.MCMConfig qml.devices.Device qml.devices.DefaultMixed qml.devices.DefaultQubit qml.devices.default_tensor.DefaultTensor qml.devices.NullQubit qml.devices.Refe"
    },
    {
      "id": "qml.devices.DefaultQutritMixed",
      "name": "qml.devices.DefaultQutritMixed",
      "type": "function",
      "description": "PennyLane API: devices.DefaultQutritMixed. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "Qubit qml.devices.default_tensor.DefaultTensor qml.devices.NullQubit qml.devices.ReferenceQubit qml.devices.DefaultQutritMixed qml.devices.LegacyDeviceFacade   Preprocessing Transforms Modifiers Qubit"
    },
    {
      "id": "qml.devices.default_qutrit",
      "name": "qml.devices.default_qutrit",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "s.capabilities qml.devices.default_qubit qml.devices.default_gaussian qml.devices.default_mixed qml.devices.default_qutrit qml.devices.default_qutrit_mixed qml.devices.default_clifford qml.devices.def"
    },
    {
      "id": "qml.devices.NullQubit",
      "name": "qml.devices.NullQubit",
      "type": "function",
      "description": "PennyLane API: devices.NullQubit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "vice qml.devices.DefaultMixed qml.devices.DefaultQubit qml.devices.default_tensor.DefaultTensor qml.devices.NullQubit qml.devices.ReferenceQubit qml.devices.DefaultQutritMixed qml.devices.LegacyDevice"
    },
    {
      "id": "qml.devices.default_clifford",
      "name": "qml.devices.default_clifford",
      "type": "function",
      "description": "PennyLane API: devices.default_clifford. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "_gaussian qml.devices.default_mixed qml.devices.default_qutrit qml.devices.default_qutrit_mixed qml.devices.default_clifford qml.devices.default_tensor qml.devices._legacy_device qml.devices._qubit_de"
    },
    {
      "id": "qml.devices.ReferenceQubit",
      "name": "qml.devices.ReferenceQubit",
      "type": "function",
      "description": "PennyLane API: devices.ReferenceQubit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "ltMixed qml.devices.DefaultQubit qml.devices.default_tensor.DefaultTensor qml.devices.NullQubit qml.devices.ReferenceQubit qml.devices.DefaultQutritMixed qml.devices.LegacyDeviceFacade   Preprocessing"
    },
    {
      "id": "qml.devices.default_gaussian",
      "name": "qml.devices.default_gaussian",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "als  qml.capture qml.concurrency qml.devices qml.devices.capabilities qml.devices.default_qubit qml.devices.default_gaussian qml.devices.default_mixed qml.devices.default_qutrit qml.devices.default_qu"
    },
    {
      "id": "qml.devices.default_mixed",
      "name": "qml.devices.default_mixed",
      "type": "function",
      "description": "PennyLane API: devices.default_mixed. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "ncy qml.devices qml.devices.capabilities qml.devices.default_qubit qml.devices.default_gaussian qml.devices.default_mixed qml.devices.default_qutrit qml.devices.default_qutrit_mixed qml.devices.defaul"
    },
    {
      "id": "qml.devices.DefaultMixed",
      "name": "qml.devices.DefaultMixed",
      "type": "function",
      "description": "PennyLane API: devices.DefaultMixed. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "                                         qml.devices.DefaultMixed — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.capabilities",
      "name": "qml.devices.capabilities",
      "type": "function",
      "description": "PennyLane API: devices.capabilities. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "esource qml.shadows qml.spin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.devices.capabilities qml.devices.default_qubit qml.devices.default_gaussian qml.devices.default_mixe"
    },
    {
      "id": "qml.devices.default_qubit",
      "name": "qml.devices.default_qubit",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "pin qml.transforms  Internals  qml.capture qml.concurrency qml.devices qml.devices.capabilities qml.devices.default_qubit qml.devices.default_gaussian qml.devices.default_mixed qml.devices.default_qut"
    },
    {
      "id": "qml.devices.null_qubit",
      "name": "qml.devices.null_qubit",
      "type": "function",
      "description": "PennyLane API: devices.null_qubit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": ".default_tensor qml.devices._legacy_device qml.devices._qubit_device qml.devices._qutrit_device qml.devices.null_qubit qml.devices.reference_qubit qml.devices.tests Next generation devices qml.devices"
    },
    {
      "id": "qml.devices._qutrit_device",
      "name": "qml.devices._qutrit_device",
      "type": "function",
      "description": "PennyLane API: devices._qutrit_device. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "efault_clifford qml.devices.default_tensor qml.devices._legacy_device qml.devices._qubit_device qml.devices._qutrit_device qml.devices.null_qubit qml.devices.reference_qubit qml.devices.tests Next gen"
    },
    {
      "id": "qml.devices.default_qutrit_mixed",
      "name": "qml.devices.default_qutrit_mixed",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "default_qubit qml.devices.default_gaussian qml.devices.default_mixed qml.devices.default_qutrit qml.devices.default_qutrit_mixed qml.devices.default_clifford qml.devices.default_tensor qml.devices._le"
    },
    {
      "id": "qml.devices._qubit_device",
      "name": "qml.devices._qubit_device",
      "type": "function",
      "description": "PennyLane API: devices._qubit_device. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "qutrit_mixed qml.devices.default_clifford qml.devices.default_tensor qml.devices._legacy_device qml.devices._qubit_device qml.devices._qutrit_device qml.devices.null_qubit qml.devices.reference_qubit "
    },
    {
      "id": "qml.devices.tests",
      "name": "qml.devices.tests",
      "type": "function",
      "description": "PennyLane API: devices.tests. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "ces._qubit_device qml.devices._qutrit_device qml.devices.null_qubit qml.devices.reference_qubit qml.devices.tests Next generation devices qml.devices.ExecutionConfig qml.devices.MCMConfig qml.devices."
    },
    {
      "id": "qml.devices.default_tensor.DefaultTensor",
      "name": "qml.devices.default_tensor.DefaultTensor",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.DefaultTensor. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "nfig qml.devices.MCMConfig qml.devices.Device qml.devices.DefaultMixed qml.devices.DefaultQubit qml.devices.default_tensor.DefaultTensor qml.devices.NullQubit qml.devices.ReferenceQubit qml.devices.De"
    },
    {
      "id": "qml.devices.reference_qubit",
      "name": "qml.devices.reference_qubit",
      "type": "function",
      "description": "PennyLane API: devices.reference_qubit. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "ices._legacy_device qml.devices._qubit_device qml.devices._qutrit_device qml.devices.null_qubit qml.devices.reference_qubit qml.devices.tests Next generation devices qml.devices.ExecutionConfig qml.de"
    },
    {
      "id": "qml.devices.default_tensor",
      "name": "qml.devices.default_tensor",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "_mixed qml.devices.default_qutrit qml.devices.default_qutrit_mixed qml.devices.default_clifford qml.devices.default_tensor qml.devices._legacy_device qml.devices._qubit_device qml.devices._qutrit_devi"
    },
    {
      "id": "qml.devices._legacy_device",
      "name": "qml.devices._legacy_device",
      "type": "function",
      "description": "PennyLane API: devices._legacy_device. Found in pennylane.devices.DefaultMixed.html",
      "source_file": "pennylane.devices.DefaultMixed.html",
      "context": "qutrit qml.devices.default_qutrit_mixed qml.devices.default_clifford qml.devices.default_tensor qml.devices._legacy_device qml.devices._qubit_device qml.devices._qutrit_device qml.devices.null_qubit q"
    },
    {
      "id": "qml.devices._legacy_device.Device",
      "name": "qml.devices._legacy_device.Device",
      "type": "function",
      "description": "PennyLane API: devices._legacy_device.Device. Found in pennylane.devices._legacy_device.Device.html",
      "source_file": "pennylane.devices._legacy_device.Device.html",
      "context": "                                         qml.devices._legacy_device.Device — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices._qubit_device.QubitDevice",
      "name": "qml.devices._qubit_device.QubitDevice",
      "type": "function",
      "description": "PennyLane API: devices._qubit_device.QubitDevice. Found in pennylane.devices._qubit_device.QubitDevice.html",
      "source_file": "pennylane.devices._qubit_device.QubitDevice.html",
      "context": "                                         qml.devices._qubit_device.QubitDevice — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices._qutrit_device.QutritDevice",
      "name": "qml.devices._qutrit_device.QutritDevice",
      "type": "function",
      "description": "PennyLane API: devices._qutrit_device.QutritDevice. Found in pennylane.devices._qutrit_device.QutritDevice.html",
      "source_file": "pennylane.devices._qutrit_device.QutritDevice.html",
      "context": "                                         qml.devices._qutrit_device.QutritDevice — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.capabilities.validate_mcm_method",
      "name": "qml.devices.capabilities.validate_mcm_method",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.validate_mcm_method. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "ml.devices.capabilities.parse_toml_document qml.devices.capabilities.update_device_capabilities qml.devices.capabilities.validate_mcm_method   qml.devices.default_qubit qml.devices.default_gaussian qm"
    },
    {
      "id": "qml.devices.capabilities.OperatorProperties",
      "name": "qml.devices.capabilities.OperatorProperties",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.OperatorProperties. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "ilities qml.devices.capabilities.DeviceCapabilities qml.devices.capabilities.ExecutionCondition qml.devices.capabilities.OperatorProperties qml.devices.capabilities.load_toml_file qml.devices.capabili"
    },
    {
      "id": "qml.devices.capabilities.parse_toml_document",
      "name": "qml.devices.capabilities.parse_toml_document",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.parse_toml_document. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "ices.capabilities.load_toml_file qml.devices.capabilities.observable_stopping_condition_factory qml.devices.capabilities.parse_toml_document qml.devices.capabilities.update_device_capabilities qml.dev"
    },
    {
      "id": "qml.devices.capabilities.DeviceCapabilities",
      "name": "qml.devices.capabilities.DeviceCapabilities",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.DeviceCapabilities. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "                                         qml.devices.capabilities.DeviceCapabilities — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.capabilities.load_toml_file",
      "name": "qml.devices.capabilities.load_toml_file",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.load_toml_file. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "ilities qml.devices.capabilities.ExecutionCondition qml.devices.capabilities.OperatorProperties qml.devices.capabilities.load_toml_file qml.devices.capabilities.observable_stopping_condition_factory q"
    },
    {
      "id": "qml.devices.capabilities.update_device_capabilities",
      "name": "qml.devices.capabilities.update_device_capabilities",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.update_device_capabilities. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "capabilities.observable_stopping_condition_factory qml.devices.capabilities.parse_toml_document qml.devices.capabilities.update_device_capabilities qml.devices.capabilities.validate_mcm_method   qml.d"
    },
    {
      "id": "qml.devices.capabilities.observable_stopping_condition_factory",
      "name": "qml.devices.capabilities.observable_stopping_condition_factory",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.observable_stopping_condition_factory. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "onCondition qml.devices.capabilities.OperatorProperties qml.devices.capabilities.load_toml_file qml.devices.capabilities.observable_stopping_condition_factory qml.devices.capabilities.parse_toml_docum"
    },
    {
      "id": "qml.devices.capabilities.ExecutionCondition",
      "name": "qml.devices.capabilities.ExecutionCondition",
      "type": "function",
      "description": "PennyLane API: devices.capabilities.ExecutionCondition. Found in pennylane.devices.capabilities.DeviceCapabilities.html",
      "source_file": "pennylane.devices.capabilities.DeviceCapabilities.html",
      "context": "ml.concurrency qml.devices qml.devices.capabilities qml.devices.capabilities.DeviceCapabilities qml.devices.capabilities.ExecutionCondition qml.devices.capabilities.OperatorProperties qml.devices.capa"
    },
    {
      "id": "qml.devices.default_clifford.DefaultClifford",
      "name": "qml.devices.default_clifford.DefaultClifford",
      "type": "function",
      "description": "PennyLane API: devices.default_clifford.DefaultClifford. Found in pennylane.devices.default_clifford.DefaultClifford.html",
      "source_file": "pennylane.devices.default_clifford.DefaultClifford.html",
      "context": "                                         qml.devices.default_clifford.DefaultClifford — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.default_clifford.observable_stopping_condition",
      "name": "qml.devices.default_clifford.observable_stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_clifford.observable_stopping_condition. Found in pennylane.devices.default_clifford.DefaultClifford.html",
      "source_file": "pennylane.devices.default_clifford.DefaultClifford.html",
      "context": ".default_qutrit_mixed qml.devices.default_clifford qml.devices.default_clifford.DefaultClifford qml.devices.default_clifford.observable_stopping_condition qml.devices.default_clifford.operation_stoppi"
    },
    {
      "id": "qml.Projector.",
      "name": "qml.Projector.",
      "type": "class",
      "description": "PennyLane API: Projector.. Found in pennylane.devices.default_clifford.DefaultClifford.html",
      "source_file": "pennylane.devices.default_clifford.DefaultClifford.html",
      "context": "is state by computing the expectation value of the corresponding projector using qml.expval and qml.Projector. num_wires = 4 @qml.qnode(dev) def circuit(state):     qml.Hadamard(wires=[0])     for idx"
    },
    {
      "id": "qml.state.",
      "name": "qml.state.",
      "type": "function",
      "description": "PennyLane API: state.. Found in pennylane.devices.default_clifford.DefaultClifford.html",
      "source_file": "pennylane.devices.default_clifford.DefaultClifford.html",
      "context": "e. tableau (bool) – Determines what should be returned when the device’s state is computed with qml.state. When True, the device returns the final evolved Tableau. Alternatively, one may make it False"
    },
    {
      "id": "qml.devices.default_clifford.operation_stopping_condition",
      "name": "qml.devices.default_clifford.operation_stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_clifford.operation_stopping_condition. Found in pennylane.devices.default_clifford.DefaultClifford.html",
      "source_file": "pennylane.devices.default_clifford.DefaultClifford.html",
      "context": "ces.default_clifford.DefaultClifford qml.devices.default_clifford.observable_stopping_condition qml.devices.default_clifford.operation_stopping_condition   qml.devices.default_tensor qml.devices._lega"
    },
    {
      "id": "qml.devices.default_gaussian.coherent_state",
      "name": "qml.devices.default_gaussian.coherent_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.coherent_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "gaussian qml.devices.default_gaussian.DefaultGaussian qml.devices.default_gaussian.beamsplitter qml.devices.default_gaussian.coherent_state qml.devices.default_gaussian.controlled_addition qml.devices"
    },
    {
      "id": "qml.devices.default_gaussian.interferometer_unitary",
      "name": "qml.devices.default_gaussian.interferometer_unitary",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.interferometer_unitary. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "sian.gaussian_state qml.devices.default_gaussian.homodyne qml.devices.default_gaussian.identity qml.devices.default_gaussian.interferometer_unitary qml.devices.default_gaussian.partitions qml.devices."
    },
    {
      "id": "qml.devices.default_gaussian.partitions",
      "name": "qml.devices.default_gaussian.partitions",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.partitions. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "odyne qml.devices.default_gaussian.identity qml.devices.default_gaussian.interferometer_unitary qml.devices.default_gaussian.partitions qml.devices.default_gaussian.photon_number qml.devices.default_g"
    },
    {
      "id": "qml.devices.default_gaussian.rotation",
      "name": "qml.devices.default_gaussian.rotation",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.rotation. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "ml.devices.default_gaussian.poly_quad_expectations qml.devices.default_gaussian.quadratic_phase qml.devices.default_gaussian.rotation qml.devices.default_gaussian.set_state qml.devices.default_gaussia"
    },
    {
      "id": "qml.devices.default_gaussian.beamsplitter",
      "name": "qml.devices.default_gaussian.beamsplitter",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.beamsplitter. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "devices.default_qubit qml.devices.default_gaussian qml.devices.default_gaussian.DefaultGaussian qml.devices.default_gaussian.beamsplitter qml.devices.default_gaussian.coherent_state qml.devices.defaul"
    },
    {
      "id": "qml.devices.default_gaussian.controlled_addition",
      "name": "qml.devices.default_gaussian.controlled_addition",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.controlled_addition. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "tGaussian qml.devices.default_gaussian.beamsplitter qml.devices.default_gaussian.coherent_state qml.devices.default_gaussian.controlled_addition qml.devices.default_gaussian.controlled_phase qml.devic"
    },
    {
      "id": "qml.devices.default_gaussian.vacuum_state",
      "name": "qml.devices.default_gaussian.vacuum_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.vacuum_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "zing qml.devices.default_gaussian.thermal_state qml.devices.default_gaussian.two_mode_squeezing qml.devices.default_gaussian.vacuum_state   qml.devices.default_mixed qml.devices.default_qutrit qml.dev"
    },
    {
      "id": "qml.devices.default_gaussian.photon_number",
      "name": "qml.devices.default_gaussian.photon_number",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.photon_number. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "ity qml.devices.default_gaussian.interferometer_unitary qml.devices.default_gaussian.partitions qml.devices.default_gaussian.photon_number qml.devices.default_gaussian.poly_quad_expectations qml.devic"
    },
    {
      "id": "qml.devices.default_gaussian.controlled_phase",
      "name": "qml.devices.default_gaussian.controlled_phase",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.controlled_phase. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "er qml.devices.default_gaussian.coherent_state qml.devices.default_gaussian.controlled_addition qml.devices.default_gaussian.controlled_phase qml.devices.default_gaussian.displaced_squeezed_state qml."
    },
    {
      "id": "qml.devices.default_gaussian.gaussian_state",
      "name": "qml.devices.default_gaussian.gaussian_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.gaussian_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "splacement qml.devices.default_gaussian.fock_expectation qml.devices.default_gaussian.fock_prob qml.devices.default_gaussian.gaussian_state qml.devices.default_gaussian.homodyne qml.devices.default_ga"
    },
    {
      "id": "qml.devices.default_gaussian.thermal_state",
      "name": "qml.devices.default_gaussian.thermal_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.thermal_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "squeezed_cov qml.devices.default_gaussian.squeezed_state qml.devices.default_gaussian.squeezing qml.devices.default_gaussian.thermal_state qml.devices.default_gaussian.two_mode_squeezing qml.devices.d"
    },
    {
      "id": "qml.devices.default_gaussian.fock_expectation",
      "name": "qml.devices.default_gaussian.fock_expectation",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.fock_expectation. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "qml.devices.default_gaussian.displaced_squeezed_state qml.devices.default_gaussian.displacement qml.devices.default_gaussian.fock_expectation qml.devices.default_gaussian.fock_prob qml.devices.default"
    },
    {
      "id": "qml.devices.default_gaussian.squeezed_state",
      "name": "qml.devices.default_gaussian.squeezed_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.squeezed_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "ssian.rotation qml.devices.default_gaussian.set_state qml.devices.default_gaussian.squeezed_cov qml.devices.default_gaussian.squeezed_state qml.devices.default_gaussian.squeezing qml.devices.default_g"
    },
    {
      "id": "qml.devices.default_gaussian.identity",
      "name": "qml.devices.default_gaussian.identity",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.identity. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "ian.fock_prob qml.devices.default_gaussian.gaussian_state qml.devices.default_gaussian.homodyne qml.devices.default_gaussian.identity qml.devices.default_gaussian.interferometer_unitary qml.devices.de"
    },
    {
      "id": "qml.devices.default_gaussian.displacement",
      "name": "qml.devices.default_gaussian.displacement",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.displacement. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "devices.default_gaussian.controlled_phase qml.devices.default_gaussian.displaced_squeezed_state qml.devices.default_gaussian.displacement qml.devices.default_gaussian.fock_expectation qml.devices.defa"
    },
    {
      "id": "qml.devices.default_gaussian.homodyne",
      "name": "qml.devices.default_gaussian.homodyne",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.homodyne. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "_expectation qml.devices.default_gaussian.fock_prob qml.devices.default_gaussian.gaussian_state qml.devices.default_gaussian.homodyne qml.devices.default_gaussian.identity qml.devices.default_gaussian"
    },
    {
      "id": "qml.devices.default_gaussian.squeezing",
      "name": "qml.devices.default_gaussian.squeezing",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.squeezing. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "set_state qml.devices.default_gaussian.squeezed_cov qml.devices.default_gaussian.squeezed_state qml.devices.default_gaussian.squeezing qml.devices.default_gaussian.thermal_state qml.devices.default_ga"
    },
    {
      "id": "qml.devices.default_gaussian.DefaultGaussian",
      "name": "qml.devices.default_gaussian.DefaultGaussian",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.DefaultGaussian. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "                                         qml.devices.default_gaussian.DefaultGaussian — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.default_gaussian.squeezed_cov",
      "name": "qml.devices.default_gaussian.squeezed_cov",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.squeezed_cov. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "an.quadratic_phase qml.devices.default_gaussian.rotation qml.devices.default_gaussian.set_state qml.devices.default_gaussian.squeezed_cov qml.devices.default_gaussian.squeezed_state qml.devices.defaul"
    },
    {
      "id": "qml.devices.default_gaussian.fock_prob",
      "name": "qml.devices.default_gaussian.fock_prob",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.fock_prob. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "d_state qml.devices.default_gaussian.displacement qml.devices.default_gaussian.fock_expectation qml.devices.default_gaussian.fock_prob qml.devices.default_gaussian.gaussian_state qml.devices.default_g"
    },
    {
      "id": "qml.devices.default_gaussian.two_mode_squeezing",
      "name": "qml.devices.default_gaussian.two_mode_squeezing",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.two_mode_squeezing. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "queezed_state qml.devices.default_gaussian.squeezing qml.devices.default_gaussian.thermal_state qml.devices.default_gaussian.two_mode_squeezing qml.devices.default_gaussian.vacuum_state   qml.devices."
    },
    {
      "id": "qml.devices.default_gaussian.poly_quad_expectations",
      "name": "qml.devices.default_gaussian.poly_quad_expectations",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.poly_quad_expectations. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "eter_unitary qml.devices.default_gaussian.partitions qml.devices.default_gaussian.photon_number qml.devices.default_gaussian.poly_quad_expectations qml.devices.default_gaussian.quadratic_phase qml.dev"
    },
    {
      "id": "qml.devices.default_gaussian.displaced_squeezed_state",
      "name": "qml.devices.default_gaussian.displaced_squeezed_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.displaced_squeezed_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": " qml.devices.default_gaussian.controlled_addition qml.devices.default_gaussian.controlled_phase qml.devices.default_gaussian.displaced_squeezed_state qml.devices.default_gaussian.displacement qml.devi"
    },
    {
      "id": "qml.devices.default_gaussian.quadratic_phase",
      "name": "qml.devices.default_gaussian.quadratic_phase",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.quadratic_phase. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": " qml.devices.default_gaussian.photon_number qml.devices.default_gaussian.poly_quad_expectations qml.devices.default_gaussian.quadratic_phase qml.devices.default_gaussian.rotation qml.devices.default_g"
    },
    {
      "id": "qml.devices.default_gaussian.set_state",
      "name": "qml.devices.default_gaussian.set_state",
      "type": "function",
      "description": "PennyLane API: devices.default_gaussian.set_state. Found in pennylane.devices.default_gaussian.DefaultGaussian.html",
      "source_file": "pennylane.devices.default_gaussian.DefaultGaussian.html",
      "context": "expectations qml.devices.default_gaussian.quadratic_phase qml.devices.default_gaussian.rotation qml.devices.default_gaussian.set_state qml.devices.default_gaussian.squeezed_cov qml.devices.default_gau"
    },
    {
      "id": "qml.devices.default_mixed.observable_stopping_condition",
      "name": "qml.devices.default_mixed.observable_stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_mixed.observable_stopping_condition. Found in pennylane.devices.default_mixed.DefaultMixed.html",
      "source_file": "pennylane.devices.default_mixed.DefaultMixed.html",
      "context": "t qml.devices.default_gaussian qml.devices.default_mixed qml.devices.default_mixed.DefaultMixed qml.devices.default_mixed.observable_stopping_condition qml.devices.default_mixed.stopping_condition qml"
    },
    {
      "id": "qml.devices.default_mixed.DefaultMixed",
      "name": "qml.devices.default_mixed.DefaultMixed",
      "type": "function",
      "description": "PennyLane API: devices.default_mixed.DefaultMixed. Found in pennylane.devices.default_mixed.DefaultMixed.html",
      "source_file": "pennylane.devices.default_mixed.DefaultMixed.html",
      "context": "                                         qml.devices.default_mixed.DefaultMixed — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.default_mixed.stopping_condition",
      "name": "qml.devices.default_mixed.stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_mixed.stopping_condition. Found in pennylane.devices.default_mixed.DefaultMixed.html",
      "source_file": "pennylane.devices.default_mixed.DefaultMixed.html",
      "context": " qml.devices.default_mixed.DefaultMixed qml.devices.default_mixed.observable_stopping_condition qml.devices.default_mixed.stopping_condition qml.devices.default_mixed.warn_readout_error_state   qml.de"
    },
    {
      "id": "qml.devices.default_mixed.warn_readout_error_state",
      "name": "qml.devices.default_mixed.warn_readout_error_state",
      "type": "function",
      "description": "PennyLane API: devices.default_mixed.warn_readout_error_state. Found in pennylane.devices.default_mixed.DefaultMixed.html",
      "source_file": "pennylane.devices.default_mixed.DefaultMixed.html",
      "context": "evices.default_mixed.observable_stopping_condition qml.devices.default_mixed.stopping_condition qml.devices.default_mixed.warn_readout_error_state   qml.devices.default_qutrit qml.devices.default_qutr"
    },
    {
      "id": "qml.devices.default_qubit.all_state_postprocessing",
      "name": "qml.devices.default_qubit.all_state_postprocessing",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.all_state_postprocessing. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "bles qml.devices.default_qubit.adjoint_ops qml.devices.default_qubit.adjoint_state_measurements qml.devices.default_qubit.all_state_postprocessing qml.devices.default_qubit.no_counts qml.devices.defau"
    },
    {
      "id": "qml.devices.default_qubit.DefaultQubit",
      "name": "qml.devices.default_qubit.DefaultQubit",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.DefaultQubit. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "                                         qml.devices.default_qubit.DefaultQubit — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.default_qubit.stopping_condition",
      "name": "qml.devices.default_qubit.stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.stopping_condition. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "default_qubit.observable_accepts_analytic qml.devices.default_qubit.observable_accepts_sampling qml.devices.default_qubit.stopping_condition   qml.devices.default_gaussian qml.devices.default_mixed qm"
    },
    {
      "id": "qml.devices.default_qubit.observable_accepts_analytic",
      "name": "qml.devices.default_qubit.observable_accepts_analytic",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.observable_accepts_analytic. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "ostprocessing qml.devices.default_qubit.no_counts qml.devices.default_qubit.null_postprocessing qml.devices.default_qubit.observable_accepts_analytic qml.devices.default_qubit.observable_accepts_sampl"
    },
    {
      "id": "qml.devices.default_qubit.null_postprocessing",
      "name": "qml.devices.default_qubit.null_postprocessing",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.null_postprocessing. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "urements qml.devices.default_qubit.all_state_postprocessing qml.devices.default_qubit.no_counts qml.devices.default_qubit.null_postprocessing qml.devices.default_qubit.observable_accepts_analytic qml."
    },
    {
      "id": "qml.devices.default_qubit.adjoint_ops",
      "name": "qml.devices.default_qubit.adjoint_ops",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.adjoint_ops. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "devices.default_qubit.accepted_sample_measurement qml.devices.default_qubit.adjoint_observables qml.devices.default_qubit.adjoint_ops qml.devices.default_qubit.adjoint_state_measurements qml.devices.d"
    },
    {
      "id": "qml.devices.default_qubit.observable_accepts_sampling",
      "name": "qml.devices.default_qubit.observable_accepts_sampling",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.observable_accepts_sampling. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "devices.default_qubit.null_postprocessing qml.devices.default_qubit.observable_accepts_analytic qml.devices.default_qubit.observable_accepts_sampling qml.devices.default_qubit.stopping_condition   qml"
    },
    {
      "id": "qml.devices.default_qubit.adjoint_observables",
      "name": "qml.devices.default_qubit.adjoint_observables",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.adjoint_observables. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "fault_qubit.accepted_analytic_measurement qml.devices.default_qubit.accepted_sample_measurement qml.devices.default_qubit.adjoint_observables qml.devices.default_qubit.adjoint_ops qml.devices.default_"
    },
    {
      "id": "qml.devices.default_qubit.adjoint_state_measurements",
      "name": "qml.devices.default_qubit.adjoint_state_measurements",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.adjoint_state_measurements. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "measurement qml.devices.default_qubit.adjoint_observables qml.devices.default_qubit.adjoint_ops qml.devices.default_qubit.adjoint_state_measurements qml.devices.default_qubit.all_state_postprocessing "
    },
    {
      "id": "qml.devices.default_qubit.no_counts",
      "name": "qml.devices.default_qubit.no_counts",
      "type": "function",
      "description": "PennyLane API: devices.default_qubit.no_counts. Found in pennylane.devices.default_qubit.DefaultQubit.html",
      "source_file": "pennylane.devices.default_qubit.DefaultQubit.html",
      "context": "ces.default_qubit.adjoint_state_measurements qml.devices.default_qubit.all_state_postprocessing qml.devices.default_qubit.no_counts qml.devices.default_qubit.null_postprocessing qml.devices.default_qu"
    },
    {
      "id": "qml.devices.default_qutrit.DefaultQutrit",
      "name": "qml.devices.default_qutrit.DefaultQutrit",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit.DefaultQutrit. Found in pennylane.devices.default_qutrit.DefaultQutrit.html",
      "source_file": "pennylane.devices.default_qutrit.DefaultQutrit.html",
      "context": "                                         qml.devices.default_qutrit.DefaultQutrit — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.default_qutrit_mixed.accepted_sample_measurement",
      "name": "qml.devices.default_qutrit_mixed.accepted_sample_measurement",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed.accepted_sample_measurement. Found in pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "source_file": "pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "context": "ult_qutrit qml.devices.default_qutrit_mixed qml.devices.default_qutrit_mixed.DefaultQutritMixed qml.devices.default_qutrit_mixed.accepted_sample_measurement qml.devices.default_qutrit_mixed.get_readou"
    },
    {
      "id": "qml.devices.default_qutrit_mixed.stopping_condition",
      "name": "qml.devices.default_qutrit_mixed.stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed.stopping_condition. Found in pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "source_file": "pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "context": "_qutrit_mixed.get_readout_errors qml.devices.default_qutrit_mixed.observable_stopping_condition qml.devices.default_qutrit_mixed.stopping_condition qml.devices.default_qutrit_mixed.warn_readout_error_"
    },
    {
      "id": "qml.devices.default_qutrit_mixed.get_readout_errors",
      "name": "qml.devices.default_qutrit_mixed.get_readout_errors",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed.get_readout_errors. Found in pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "source_file": "pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "context": "lt_qutrit_mixed.DefaultQutritMixed qml.devices.default_qutrit_mixed.accepted_sample_measurement qml.devices.default_qutrit_mixed.get_readout_errors qml.devices.default_qutrit_mixed.observable_stopping"
    },
    {
      "id": "qml.devices.default_qutrit_mixed.observable_stopping_condition",
      "name": "qml.devices.default_qutrit_mixed.observable_stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed.observable_stopping_condition. Found in pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "source_file": "pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "context": "lt_qutrit_mixed.accepted_sample_measurement qml.devices.default_qutrit_mixed.get_readout_errors qml.devices.default_qutrit_mixed.observable_stopping_condition qml.devices.default_qutrit_mixed.stopping"
    },
    {
      "id": "qml.devices.default_qutrit_mixed.DefaultQutritMixed",
      "name": "qml.devices.default_qutrit_mixed.DefaultQutritMixed",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed.DefaultQutritMixed. Found in pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "source_file": "pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "context": "                                         qml.devices.default_qutrit_mixed.DefaultQutritMixed — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.default_qutrit_mixed.warn_readout_error_state",
      "name": "qml.devices.default_qutrit_mixed.warn_readout_error_state",
      "type": "function",
      "description": "PennyLane API: devices.default_qutrit_mixed.warn_readout_error_state. Found in pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "source_file": "pennylane.devices.default_qutrit_mixed.DefaultQutritMixed.html",
      "context": "_qutrit_mixed.observable_stopping_condition qml.devices.default_qutrit_mixed.stopping_condition qml.devices.default_qutrit_mixed.warn_readout_error_state   qml.devices.default_clifford qml.devices.def"
    },
    {
      "id": "qml.devices.default_tensor.expval_core_sprod",
      "name": "qml.devices.default_tensor.expval_core_sprod",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.expval_core_sprod. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "vices.default_tensor.expval_core_linear_combination qml.devices.default_tensor.expval_core_prod qml.devices.default_tensor.expval_core_sprod qml.devices.default_tensor.expval_core_sum qml.devices.defa"
    },
    {
      "id": "qml.devices.default_tensor.accepted_observables",
      "name": "qml.devices.default_tensor.accepted_observables",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.accepted_observables. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "ult_tensor qml.devices.default_tensor.DefaultTensor qml.devices.default_tensor.accepted_methods qml.devices.default_tensor.accepted_observables qml.devices.default_tensor.apply_operation_core qml.devi"
    },
    {
      "id": "qml.devices.default_tensor.expval_core_sum",
      "name": "qml.devices.default_tensor.expval_core_sum",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.expval_core_sum. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "nation qml.devices.default_tensor.expval_core_prod qml.devices.default_tensor.expval_core_sprod qml.devices.default_tensor.expval_core_sum qml.devices.default_tensor.stopping_condition   qml.devices._"
    },
    {
      "id": "qml.devices.default_tensor.apply_operation_core_multirz",
      "name": "qml.devices.default_tensor.apply_operation_core_multirz",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.apply_operation_core_multirz. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "efault_tensor.apply_operation_core qml.devices.default_tensor.apply_operation_core_global_phase qml.devices.default_tensor.apply_operation_core_multirz qml.devices.default_tensor.apply_operation_core_"
    },
    {
      "id": "qml.devices.default_tensor.expval_core",
      "name": "qml.devices.default_tensor.expval_core",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.expval_core. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "r.apply_operation_core_paulirot qml.devices.default_tensor.apply_operation_core_trotter_product qml.devices.default_tensor.expval_core qml.devices.default_tensor.expval_core_linear_combination qml.dev"
    },
    {
      "id": "qml.devices.default_tensor.apply_operation_core_trotter_product",
      "name": "qml.devices.default_tensor.apply_operation_core_trotter_product",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.apply_operation_core_trotter_product. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "lt_tensor.apply_operation_core_multirz qml.devices.default_tensor.apply_operation_core_paulirot qml.devices.default_tensor.apply_operation_core_trotter_product qml.devices.default_tensor.expval_core q"
    },
    {
      "id": "qml.devices.default_tensor.expval_core_linear_combination",
      "name": "qml.devices.default_tensor.expval_core_linear_combination",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.expval_core_linear_combination. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "ices.default_tensor.apply_operation_core_trotter_product qml.devices.default_tensor.expval_core qml.devices.default_tensor.expval_core_linear_combination qml.devices.default_tensor.expval_core_prod qm"
    },
    {
      "id": "qml.devices.default_tensor.apply_operation_core_global_phase",
      "name": "qml.devices.default_tensor.apply_operation_core_global_phase",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.apply_operation_core_global_phase. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "qml.devices.default_tensor.accepted_observables qml.devices.default_tensor.apply_operation_core qml.devices.default_tensor.apply_operation_core_global_phase qml.devices.default_tensor.apply_operation_"
    },
    {
      "id": "qml.devices.default_tensor.expval_core_prod",
      "name": "qml.devices.default_tensor.expval_core_prod",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.expval_core_prod. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "ml.devices.default_tensor.expval_core qml.devices.default_tensor.expval_core_linear_combination qml.devices.default_tensor.expval_core_prod qml.devices.default_tensor.expval_core_sprod qml.devices.def"
    },
    {
      "id": "qml.devices.default_tensor.apply_operation_core",
      "name": "qml.devices.default_tensor.apply_operation_core",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.apply_operation_core. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "sor qml.devices.default_tensor.accepted_methods qml.devices.default_tensor.accepted_observables qml.devices.default_tensor.apply_operation_core qml.devices.default_tensor.apply_operation_core_global_p"
    },
    {
      "id": "qml.devices.default_tensor.accepted_methods",
      "name": "qml.devices.default_tensor.accepted_methods",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.accepted_methods. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "                                         qml.devices.default_tensor.accepted_methods — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.default_tensor.apply_operation_core_paulirot",
      "name": "qml.devices.default_tensor.apply_operation_core_paulirot",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.apply_operation_core_paulirot. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "ensor.apply_operation_core_global_phase qml.devices.default_tensor.apply_operation_core_multirz qml.devices.default_tensor.apply_operation_core_paulirot qml.devices.default_tensor.apply_operation_core"
    },
    {
      "id": "qml.devices.default_tensor.stopping_condition",
      "name": "qml.devices.default_tensor.stopping_condition",
      "type": "function",
      "description": "PennyLane API: devices.default_tensor.stopping_condition. Found in pennylane.devices.default_tensor.accepted_methods.html",
      "source_file": "pennylane.devices.default_tensor.accepted_methods.html",
      "context": "re_prod qml.devices.default_tensor.expval_core_sprod qml.devices.default_tensor.expval_core_sum qml.devices.default_tensor.stopping_condition   qml.devices._legacy_device qml.devices._qubit_device qml"
    },
    {
      "id": "qml.devices.modifiers.simulator_tracking",
      "name": "qml.devices.modifiers.simulator_tracking",
      "type": "function",
      "description": "PennyLane API: devices.modifiers.simulator_tracking. Found in pennylane.devices.modifiers.simulator_tracking.html",
      "source_file": "pennylane.devices.modifiers.simulator_tracking.html",
      "context": "                                         qml.devices.modifiers.simulator_tracking — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.modifiers.single_tape_support",
      "name": "qml.devices.modifiers.single_tape_support",
      "type": "function",
      "description": "PennyLane API: devices.modifiers.single_tape_support. Found in pennylane.devices.modifiers.simulator_tracking.html",
      "source_file": "pennylane.devices.modifiers.simulator_tracking.html",
      "context": "es.reference_qubit qml.devices.tests Next generation devices Preprocessing Transforms Modifiers qml.devices.modifiers.single_tape_support qml.devices.modifiers.simulator_tracking   Qubit Simulation To"
    },
    {
      "id": "qml.devices.null_qubit.NullQubit",
      "name": "qml.devices.null_qubit.NullQubit",
      "type": "function",
      "description": "PennyLane API: devices.null_qubit.NullQubit. Found in pennylane.devices.null_qubit.NullQubit.html",
      "source_file": "pennylane.devices.null_qubit.NullQubit.html",
      "context": "                                         qml.devices.null_qubit.NullQubit — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.null_qubit.zero_measurement",
      "name": "qml.devices.null_qubit.zero_measurement",
      "type": "function",
      "description": "PennyLane API: devices.null_qubit.zero_measurement. Found in pennylane.devices.null_qubit.NullQubit.html",
      "source_file": "pennylane.devices.null_qubit.NullQubit.html",
      "context": "qubit_device qml.devices._qutrit_device qml.devices.null_qubit qml.devices.null_qubit.NullQubit qml.devices.null_qubit.zero_measurement   qml.devices.reference_qubit qml.devices.tests Next generation "
    },
    {
      "id": "qml.devices.preprocess.device_resolve_dynamic_wires",
      "name": "qml.devices.preprocess.device_resolve_dynamic_wires",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.device_resolve_dynamic_wires. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "devices.tests Next generation devices Preprocessing Transforms qml.devices.preprocess.decompose qml.devices.preprocess.device_resolve_dynamic_wires qml.devices.preprocess.mid_circuit_measurements qml."
    },
    {
      "id": "qml.devices.preprocess.validate_device_wires",
      "name": "qml.devices.preprocess.validate_device_wires",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.validate_device_wires. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "params qml.devices.preprocess.validate_observables qml.devices.preprocess.validate_measurements qml.devices.preprocess.validate_device_wires qml.devices.preprocess.validate_multiprocessing_workers qml"
    },
    {
      "id": "qml.devices.preprocess.no_sampling",
      "name": "qml.devices.preprocess.no_sampling",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.no_sampling. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "ers qml.devices.preprocess.validate_adjoint_trainable_params qml.devices.preprocess.no_analytic qml.devices.preprocess.no_sampling qml.defer_measurements qml.transforms.broadcast_expand qml.transforms"
    },
    {
      "id": "qml.devices.preprocess.validate_adjoint_trainable_params",
      "name": "qml.devices.preprocess.validate_adjoint_trainable_params",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.validate_adjoint_trainable_params. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "ml.devices.preprocess.measurements_from_counts qml.devices.preprocess.measurements_from_samples qml.devices.preprocess.validate_adjoint_trainable_params qml.devices.preprocess.validate_observables qml"
    },
    {
      "id": "qml.devices.preprocess.validate_multiprocessing_workers",
      "name": "qml.devices.preprocess.validate_multiprocessing_workers",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.validate_multiprocessing_workers. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "ables qml.devices.preprocess.validate_measurements qml.devices.preprocess.validate_device_wires qml.devices.preprocess.validate_multiprocessing_workers qml.devices.preprocess.validate_adjoint_trainabl"
    },
    {
      "id": "qml.devices.preprocess.mid_circuit_measurements",
      "name": "qml.devices.preprocess.mid_circuit_measurements",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.mid_circuit_measurements. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "Transforms qml.devices.preprocess.decompose qml.devices.preprocess.device_resolve_dynamic_wires qml.devices.preprocess.mid_circuit_measurements qml.devices.preprocess.measurements_from_counts qml.devi"
    },
    {
      "id": "qml.devices.preprocess.validate_measurements",
      "name": "qml.devices.preprocess.validate_measurements",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.validate_measurements. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "evices.preprocess.validate_adjoint_trainable_params qml.devices.preprocess.validate_observables qml.devices.preprocess.validate_measurements qml.devices.preprocess.validate_device_wires qml.devices.pr"
    },
    {
      "id": "qml.devices.preprocess.validate_observables",
      "name": "qml.devices.preprocess.validate_observables",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.validate_observables. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "s.preprocess.measurements_from_samples qml.devices.preprocess.validate_adjoint_trainable_params qml.devices.preprocess.validate_observables qml.devices.preprocess.validate_measurements qml.devices.pre"
    },
    {
      "id": "qml.devices.preprocess.no_analytic",
      "name": "qml.devices.preprocess.no_analytic",
      "type": "function",
      "description": "PennyLane API: devices.preprocess.no_analytic. Found in pennylane.devices.preprocess.decompose.html",
      "source_file": "pennylane.devices.preprocess.decompose.html",
      "context": "ocess.validate_multiprocessing_workers qml.devices.preprocess.validate_adjoint_trainable_params qml.devices.preprocess.no_analytic qml.devices.preprocess.no_sampling qml.defer_measurements qml.transfo"
    },
    {
      "id": "qml.devices.qubit.sample_state",
      "name": "qml.devices.qubit.sample_state",
      "type": "function",
      "description": "PennyLane API: devices.qubit.sample_state. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": "qml.devices.qubit.measure qml.devices.qubit.measure_with_samples qml.devices.qubit.sample_probs qml.devices.qubit.sample_state qml.devices.qubit.simulate qml.devices.qubit.adjoint_jacobian qml.devices"
    },
    {
      "id": "qml.devices.qubit.simulate",
      "name": "qml.devices.qubit.simulate",
      "type": "function",
      "description": "PennyLane API: devices.qubit.simulate. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": "evices.qubit.measure_with_samples qml.devices.qubit.sample_probs qml.devices.qubit.sample_state qml.devices.qubit.simulate qml.devices.qubit.adjoint_jacobian qml.devices.qubit.adjoint_jvp qml.devices."
    },
    {
      "id": "qml.devices.qubit.adjoint_vjp",
      "name": "qml.devices.qubit.adjoint_vjp",
      "type": "function",
      "description": "PennyLane API: devices.qubit.adjoint_vjp. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": "ate qml.devices.qubit.simulate qml.devices.qubit.adjoint_jacobian qml.devices.qubit.adjoint_jvp qml.devices.qubit.adjoint_vjp   Qubit Mixed-State Simulation Tools Qutrit Mixed-State Simulation Tools  "
    },
    {
      "id": "qml.devices.qubit.adjoint_jvp",
      "name": "qml.devices.qubit.adjoint_jvp",
      "type": "function",
      "description": "PennyLane API: devices.qubit.adjoint_jvp. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": "bs qml.devices.qubit.sample_state qml.devices.qubit.simulate qml.devices.qubit.adjoint_jacobian qml.devices.qubit.adjoint_jvp qml.devices.qubit.adjoint_vjp   Qubit Mixed-State Simulation Tools Qutrit "
    },
    {
      "id": "qml.devices.qubit.sample_probs",
      "name": "qml.devices.qubit.sample_probs",
      "type": "function",
      "description": "PennyLane API: devices.qubit.sample_probs. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": ".devices.qubit.apply_operation qml.devices.qubit.measure qml.devices.qubit.measure_with_samples qml.devices.qubit.sample_probs qml.devices.qubit.sample_state qml.devices.qubit.simulate qml.devices.qub"
    },
    {
      "id": "qml.devices.qubit.adjoint_jacobian",
      "name": "qml.devices.qubit.adjoint_jacobian",
      "type": "function",
      "description": "PennyLane API: devices.qubit.adjoint_jacobian. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": "                                         qml.devices.qubit.adjoint_jacobian — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.qubit.create_initial_state",
      "name": "qml.devices.qubit.create_initial_state",
      "type": "function",
      "description": "PennyLane API: devices.qubit.create_initial_state. Found in pennylane.devices.qubit.adjoint_jacobian.html",
      "source_file": "pennylane.devices.qubit.adjoint_jacobian.html",
      "context": "devices.tests Next generation devices Preprocessing Transforms Modifiers Qubit Simulation Tools qml.devices.qubit.create_initial_state qml.devices.qubit.apply_operation qml.devices.qubit.measure qml.d"
    },
    {
      "id": "qml.devices.qubit_mixed.apply_operation",
      "name": "qml.devices.qubit_mixed.apply_operation",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed.apply_operation. Found in pennylane.devices.qubit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qubit_mixed.apply_operation.html",
      "context": "                                         qml.devices.qubit_mixed.apply_operation — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.qubit_mixed.create_initial_state",
      "name": "qml.devices.qubit_mixed.create_initial_state",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed.create_initial_state. Found in pennylane.devices.qubit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qubit_mixed.apply_operation.html",
      "context": "es Preprocessing Transforms Modifiers Qubit Simulation Tools Qubit Mixed-State Simulation Tools qml.devices.qubit_mixed.create_initial_state qml.devices.qubit_mixed.apply_operation qml.devices.qubit_m"
    },
    {
      "id": "qml.devices.qubit_mixed.simulate",
      "name": "qml.devices.qubit_mixed.simulate",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed.simulate. Found in pennylane.devices.qubit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qubit_mixed.apply_operation.html",
      "context": "mixed.measure qml.devices.qubit_mixed.measure_with_samples qml.devices.qubit_mixed.sample_state qml.devices.qubit_mixed.simulate   Qutrit Mixed-State Simulation Tools   qml.exceptions qml.ftqc qml.mea"
    },
    {
      "id": "qml.devices.qubit_mixed.sample_state",
      "name": "qml.devices.qubit_mixed.sample_state",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed.sample_state. Found in pennylane.devices.qubit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qubit_mixed.apply_operation.html",
      "context": "ed.apply_operation qml.devices.qubit_mixed.measure qml.devices.qubit_mixed.measure_with_samples qml.devices.qubit_mixed.sample_state qml.devices.qubit_mixed.simulate   Qutrit Mixed-State Simulation To"
    },
    {
      "id": "qml.devices.qutrit_mixed.sample_state",
      "name": "qml.devices.qutrit_mixed.sample_state",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.sample_state. Found in pennylane.devices.qutrit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qutrit_mixed.apply_operation.html",
      "context": "xed.measure qml.devices.qutrit_mixed.measure_with_samples qml.devices.qutrit_mixed.sample_probs qml.devices.qutrit_mixed.sample_state qml.devices.qutrit_mixed.simulate     qml.exceptions qml.ftqc qml."
    },
    {
      "id": "qml.devices.qutrit_mixed.apply_operation",
      "name": "qml.devices.qutrit_mixed.apply_operation",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.apply_operation. Found in pennylane.devices.qutrit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qutrit_mixed.apply_operation.html",
      "context": "                                         qml.devices.qutrit_mixed.apply_operation — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.qutrit_mixed.create_initial_state",
      "name": "qml.devices.qutrit_mixed.create_initial_state",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.create_initial_state. Found in pennylane.devices.qutrit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qutrit_mixed.apply_operation.html",
      "context": "s Qubit Simulation Tools Qubit Mixed-State Simulation Tools Qutrit Mixed-State Simulation Tools qml.devices.qutrit_mixed.create_initial_state qml.devices.qutrit_mixed.apply_operation qml.devices.qutri"
    },
    {
      "id": "qml.devices.qutrit_mixed.sample_probs",
      "name": "qml.devices.qutrit_mixed.sample_probs",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.sample_probs. Found in pennylane.devices.qutrit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qutrit_mixed.apply_operation.html",
      "context": ".apply_operation qml.devices.qutrit_mixed.measure qml.devices.qutrit_mixed.measure_with_samples qml.devices.qutrit_mixed.sample_probs qml.devices.qutrit_mixed.sample_state qml.devices.qutrit_mixed.sim"
    },
    {
      "id": "qml.devices.qutrit_mixed.simulate",
      "name": "qml.devices.qutrit_mixed.simulate",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed.simulate. Found in pennylane.devices.qutrit_mixed.apply_operation.html",
      "source_file": "pennylane.devices.qutrit_mixed.apply_operation.html",
      "context": "easure_with_samples qml.devices.qutrit_mixed.sample_probs qml.devices.qutrit_mixed.sample_state qml.devices.qutrit_mixed.simulate     qml.exceptions qml.ftqc qml.measurements qml.pytrees qml.operation"
    },
    {
      "id": "qml.devices.reference_qubit.supports_operation",
      "name": "qml.devices.reference_qubit.supports_operation",
      "type": "function",
      "description": "PennyLane API: devices.reference_qubit.supports_operation. Found in pennylane.devices.reference_qubit.ReferenceQubit.html",
      "source_file": "pennylane.devices.reference_qubit.ReferenceQubit.html",
      "context": "it.ReferenceQubit qml.devices.reference_qubit.sample_state qml.devices.reference_qubit.simulate qml.devices.reference_qubit.supports_operation   qml.devices.tests Next generation devices Preprocessing"
    },
    {
      "id": "qml.devices.reference_qubit.sample_state",
      "name": "qml.devices.reference_qubit.sample_state",
      "type": "function",
      "description": "PennyLane API: devices.reference_qubit.sample_state. Found in pennylane.devices.reference_qubit.ReferenceQubit.html",
      "source_file": "pennylane.devices.reference_qubit.ReferenceQubit.html",
      "context": "e qml.devices.null_qubit qml.devices.reference_qubit qml.devices.reference_qubit.ReferenceQubit qml.devices.reference_qubit.sample_state qml.devices.reference_qubit.simulate qml.devices.reference_qubi"
    },
    {
      "id": "qml.devices.reference_qubit.ReferenceQubit",
      "name": "qml.devices.reference_qubit.ReferenceQubit",
      "type": "function",
      "description": "PennyLane API: devices.reference_qubit.ReferenceQubit. Found in pennylane.devices.reference_qubit.ReferenceQubit.html",
      "source_file": "pennylane.devices.reference_qubit.ReferenceQubit.html",
      "context": "                                         qml.devices.reference_qubit.ReferenceQubit — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.devices.reference_qubit.simulate",
      "name": "qml.devices.reference_qubit.simulate",
      "type": "function",
      "description": "PennyLane API: devices.reference_qubit.simulate. Found in pennylane.devices.reference_qubit.ReferenceQubit.html",
      "source_file": "pennylane.devices.reference_qubit.ReferenceQubit.html",
      "context": "rence_qubit qml.devices.reference_qubit.ReferenceQubit qml.devices.reference_qubit.sample_state qml.devices.reference_qubit.simulate qml.devices.reference_qubit.supports_operation   qml.devices.tests "
    },
    {
      "id": "qml.devices.tests.get_device_tests",
      "name": "qml.devices.tests.get_device_tests",
      "type": "function",
      "description": "PennyLane API: devices.tests.get_device_tests. Found in pennylane.devices.tests.cli.html",
      "source_file": "pennylane.devices.tests.cli.html",
      "context": "devices.tests Using pytest The pl-device-test CLI Within Python Functions qml.devices.tests.cli qml.devices.tests.get_device_tests qml.devices.tests.test_device   Next generation devices Preprocessing"
    },
    {
      "id": "qml.devices.tests.cli",
      "name": "qml.devices.tests.cli",
      "type": "function",
      "description": "PennyLane API: devices.tests.cli. Found in pennylane.devices.tests.cli.html",
      "source_file": "pennylane.devices.tests.cli.html",
      "context": "                                         qml.devices.tests.cli — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.devices.tests.test_device",
      "name": "qml.devices.tests.test_device",
      "type": "function",
      "description": "PennyLane API: devices.tests.test_device. Found in pennylane.devices.tests.cli.html",
      "source_file": "pennylane.devices.tests.cli.html",
      "context": "evice-test CLI Within Python Functions qml.devices.tests.cli qml.devices.tests.get_device_tests qml.devices.tests.test_device   Next generation devices Preprocessing Transforms Modifiers Qubit Simulat"
    },
    {
      "id": "qml.drawer.use_style.",
      "name": "qml.drawer.use_style.",
      "type": "function",
      "description": "PennyLane API: drawer.use_style.. Found in pennylane.drawer.MPLDrawer.html",
      "source_file": "pennylane.drawer.MPLDrawer.html",
      "context": "ermined by evaluating qml.drawer.available_styles(). Any available string can then be passed to qml.drawer.use_style. qml.drawer.use_style('black_white')      You can also control the appearance with "
    },
    {
      "id": "qml.drawer.draw_mpl",
      "name": "qml.drawer.draw_mpl",
      "type": "function",
      "description": "PennyLane API: drawer.draw_mpl. Found in pennylane.drawer.draw.html",
      "source_file": "pennylane.drawer.draw.html",
      "context": "bose qml.compiler qml.data qml.decomposition qml.debugging qml.drawer Functions qml.drawer.draw qml.drawer.draw_mpl qml.drawer.tape_mpl qml.drawer.tape_text   Classes Currently Available Styles   qml."
    },
    {
      "id": "qml.drawer.draw",
      "name": "qml.drawer.draw",
      "type": "function",
      "description": "PennyLane API: drawer.draw. Found in pennylane.drawer.draw.html",
      "source_file": "pennylane.drawer.draw.html",
      "context": "                                         qml.drawer.draw — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.equal.",
      "name": "qml.equal.",
      "type": "function",
      "description": "PennyLane API: equal.. Found in pennylane.equal.html",
      "source_file": "pennylane.equal.html",
      "context": "matically equivalent operators defined via different classes may return False when compared via qml.equal. To be more thorough would require the matrix forms to be calculated, which may drastically in"
    },
    {
      "id": "qml.estimator.compact_hamiltonian.PauliHamiltonian",
      "name": "qml.estimator.compact_hamiltonian.PauliHamiltonian",
      "type": "function",
      "description": "PennyLane API: estimator.compact_hamiltonian.PauliHamiltonian. Found in pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "source_file": "pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "context": "ators Resource Templates Resource Hamiltonians qml.estimator.compact_hamiltonian.CDFHamiltonian qml.estimator.compact_hamiltonian.PauliHamiltonian qml.estimator.compact_hamiltonian.THCHamiltonian qml."
    },
    {
      "id": "qml.estimator.compact_hamiltonian.CDFHamiltonian",
      "name": "qml.estimator.compact_hamiltonian.CDFHamiltonian",
      "type": "function",
      "description": "PennyLane API: estimator.compact_hamiltonian.CDFHamiltonian. Found in pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "source_file": "pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "context": "                                         qml.estimator.compact_hamiltonian.CDFHamiltonian — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.estimator.compact_hamiltonian.VibronicHamiltonian",
      "name": "qml.estimator.compact_hamiltonian.VibronicHamiltonian",
      "type": "function",
      "description": "PennyLane API: estimator.compact_hamiltonian.VibronicHamiltonian. Found in pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "source_file": "pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "context": "tor.compact_hamiltonian.THCHamiltonian qml.estimator.compact_hamiltonian.VibrationalHamiltonian qml.estimator.compact_hamiltonian.VibronicHamiltonian   QPE Resource Classes Measurement Functions   qml"
    },
    {
      "id": "qml.estimator.compact_hamiltonian.VibrationalHamiltonian",
      "name": "qml.estimator.compact_hamiltonian.VibrationalHamiltonian",
      "type": "function",
      "description": "PennyLane API: estimator.compact_hamiltonian.VibrationalHamiltonian. Found in pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "source_file": "pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "context": "estimator.compact_hamiltonian.PauliHamiltonian qml.estimator.compact_hamiltonian.THCHamiltonian qml.estimator.compact_hamiltonian.VibrationalHamiltonian qml.estimator.compact_hamiltonian.VibronicHamil"
    },
    {
      "id": "qml.estimator.compact_hamiltonian.THCHamiltonian",
      "name": "qml.estimator.compact_hamiltonian.THCHamiltonian",
      "type": "function",
      "description": "PennyLane API: estimator.compact_hamiltonian.THCHamiltonian. Found in pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "source_file": "pennylane.estimator.compact_hamiltonian.CDFHamiltonian.html",
      "context": "estimator.compact_hamiltonian.CDFHamiltonian qml.estimator.compact_hamiltonian.PauliHamiltonian qml.estimator.compact_hamiltonian.THCHamiltonian qml.estimator.compact_hamiltonian.VibrationalHamiltonia"
    },
    {
      "id": "qml.estimator.estimate.estimate",
      "name": "qml.estimator.estimate.estimate",
      "type": "function",
      "description": "PennyLane API: estimator.estimate.estimate. Found in pennylane.estimator.estimate.estimate.html",
      "source_file": "pennylane.estimator.estimate.estimate.html",
      "context": "                                         qml.estimator.estimate.estimate — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.estimator.resource_config.ResourceConfig",
      "name": "qml.estimator.resource_config.ResourceConfig",
      "type": "function",
      "description": "PennyLane API: estimator.resource_config.ResourceConfig. Found in pennylane.estimator.estimate.estimate.html",
      "source_file": "pennylane.estimator.estimate.estimate.html",
      "context": "ator Resource Estimation qml.estimator.estimate.estimate qml.estimator.resources_base.Resources qml.estimator.resource_config.ResourceConfig   Resource Operators Qubit Management Resource Operators Re"
    },
    {
      "id": "qml.estimator.resources_base.Resources",
      "name": "qml.estimator.resources_base.Resources",
      "type": "function",
      "description": "PennyLane API: estimator.resources_base.Resources. Found in pennylane.estimator.estimate.estimate.html",
      "source_file": "pennylane.estimator.estimate.estimate.html",
      "context": "tion qml.debugging qml.drawer qml.estimator Resource Estimation qml.estimator.estimate.estimate qml.estimator.resources_base.Resources qml.estimator.resource_config.ResourceConfig   Resource Operators"
    },
    {
      "id": "qml.estimator.measurement.estimate_shots",
      "name": "qml.estimator.measurement.estimate_shots",
      "type": "function",
      "description": "PennyLane API: estimator.measurement.estimate_shots. Found in pennylane.estimator.measurement.estimate_error.html",
      "source_file": "pennylane.estimator.measurement.estimate_error.html",
      "context": "e Operators Resource Templates Resource Hamiltonians QPE Resource Classes Measurement Functions qml.estimator.measurement.estimate_shots qml.estimator.measurement.estimate_error     qml.fermi qml.four"
    },
    {
      "id": "qml.estimator.measurement.estimate_error",
      "name": "qml.estimator.measurement.estimate_error",
      "type": "function",
      "description": "PennyLane API: estimator.measurement.estimate_error. Found in pennylane.estimator.measurement.estimate_error.html",
      "source_file": "pennylane.estimator.measurement.estimate_error.html",
      "context": "                                         qml.estimator.measurement.estimate_error — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.estimator.ops.TemporaryAND",
      "name": "qml.estimator.ops.TemporaryAND",
      "type": "function",
      "description": "PennyLane API: estimator.ops.TemporaryAND. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "l.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops.SingleExcitation qml.estimator.ops.T qml.estimator.ops.TemporaryAND qml.estimator.ops.Toffoli qml.estimator.ops.X qml.estimator.ops.Y qml.est"
    },
    {
      "id": "qml.estimator.ops.PCPhase",
      "name": "qml.estimator.ops.PCPhase",
      "type": "function",
      "description": "PennyLane API: estimator.ops.PCPhase. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "adamard qml.estimator.ops.Identity qml.estimator.ops.MultiControlledX qml.estimator.ops.MultiRZ qml.estimator.ops.PCPhase qml.estimator.ops.PauliRot qml.estimator.ops.PhaseShift qml.estimator.ops.Pow "
    },
    {
      "id": "qml.estimator.ops.GlobalPhase",
      "name": "qml.estimator.ops.GlobalPhase",
      "type": "function",
      "description": "PennyLane API: estimator.ops.GlobalPhase. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "estimator.ops.ChangeOpBasis qml.estimator.ops.Controlled qml.estimator.ops.ControlledPhaseShift qml.estimator.ops.GlobalPhase qml.estimator.ops.Hadamard qml.estimator.ops.Identity qml.estimator.ops.Mu"
    },
    {
      "id": "qml.estimator.ops.QubitUnitary",
      "name": "qml.estimator.ops.QubitUnitary",
      "type": "function",
      "description": "PennyLane API: estimator.ops.QubitUnitary. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "stimator.ops.PauliRot qml.estimator.ops.PhaseShift qml.estimator.ops.Pow qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estima"
    },
    {
      "id": "qml.estimator.ops.RZ",
      "name": "qml.estimator.ops.RZ",
      "type": "function",
      "description": "PennyLane API: estimator.ops.RZ. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops."
    },
    {
      "id": "qml.estimator.ops.CRX",
      "name": "qml.estimator.ops.CRX",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CRX. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ors qml.estimator.ops.Adjoint qml.estimator.ops.CCZ qml.estimator.ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.o"
    },
    {
      "id": "qml.estimator.ops.ControlledPhaseShift",
      "name": "qml.estimator.ops.ControlledPhaseShift",
      "type": "function",
      "description": "PennyLane API: estimator.ops.ControlledPhaseShift. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "imator.ops.CY qml.estimator.ops.CZ qml.estimator.ops.ChangeOpBasis qml.estimator.ops.Controlled qml.estimator.ops.ControlledPhaseShift qml.estimator.ops.GlobalPhase qml.estimator.ops.Hadamard qml.esti"
    },
    {
      "id": "qml.estimator.ops.Rot",
      "name": "qml.estimator.ops.Rot",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Rot. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "d qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops.SingleExcitation qml."
    },
    {
      "id": "qml.estimator.ops.Toffoli",
      "name": "qml.estimator.ops.Toffoli",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Toffoli. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": ".ops.SWAP qml.estimator.ops.SingleExcitation qml.estimator.ops.T qml.estimator.ops.TemporaryAND qml.estimator.ops.Toffoli qml.estimator.ops.X qml.estimator.ops.Y qml.estimator.ops.Z   Resource Templat"
    },
    {
      "id": "qml.estimator.ops.Pow",
      "name": "qml.estimator.ops.Pow",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Pow. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "r.ops.MultiRZ qml.estimator.ops.PCPhase qml.estimator.ops.PauliRot qml.estimator.ops.PhaseShift qml.estimator.ops.Pow qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.est"
    },
    {
      "id": "qml.estimator.ops.MultiRZ",
      "name": "qml.estimator.ops.MultiRZ",
      "type": "function",
      "description": "PennyLane API: estimator.ops.MultiRZ. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "lPhase qml.estimator.ops.Hadamard qml.estimator.ops.Identity qml.estimator.ops.MultiControlledX qml.estimator.ops.MultiRZ qml.estimator.ops.PCPhase qml.estimator.ops.PauliRot qml.estimator.ops.PhaseSh"
    },
    {
      "id": "qml.estimator.ops.ChangeOpBasis",
      "name": "qml.estimator.ops.ChangeOpBasis",
      "type": "function",
      "description": "PennyLane API: estimator.ops.ChangeOpBasis. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ps.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator.ops.CZ qml.estimator.ops.ChangeOpBasis qml.estimator.ops.Controlled qml.estimator.ops.ControlledPhaseShift qml."
    },
    {
      "id": "qml.estimator.ops.CSWAP",
      "name": "qml.estimator.ops.CSWAP",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CSWAP. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "s.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator.ops.CZ qml.estimator.ops.ChangeOpBasis qml.es"
    },
    {
      "id": "qml.estimator.ops.X",
      "name": "qml.estimator.ops.X",
      "type": "function",
      "description": "PennyLane API: estimator.ops.X. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "s.SingleExcitation qml.estimator.ops.T qml.estimator.ops.TemporaryAND qml.estimator.ops.Toffoli qml.estimator.ops.X qml.estimator.ops.Y qml.estimator.ops.Z   Resource Templates Resource Hamiltonians Q"
    },
    {
      "id": "qml.estimator.ops.Z",
      "name": "qml.estimator.ops.Z",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Z. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ml.estimator.ops.TemporaryAND qml.estimator.ops.Toffoli qml.estimator.ops.X qml.estimator.ops.Y qml.estimator.ops.Z   Resource Templates Resource Hamiltonians QPE Resource Classes Measurement Function"
    },
    {
      "id": "qml.estimator.ops.RX",
      "name": "qml.estimator.ops.RX",
      "type": "function",
      "description": "PennyLane API: estimator.ops.RX. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ator.ops.PhaseShift qml.estimator.ops.Pow qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S"
    },
    {
      "id": "qml.estimator.ops.RY",
      "name": "qml.estimator.ops.RY",
      "type": "function",
      "description": "PennyLane API: estimator.ops.RY. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ml.estimator.ops.Pow qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SW"
    },
    {
      "id": "qml.estimator.ops.Adjoint",
      "name": "qml.estimator.ops.Adjoint",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Adjoint. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "                                         qml.estimator.ops.Adjoint — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.estimator.ops.SingleExcitation",
      "name": "qml.estimator.ops.SingleExcitation",
      "type": "function",
      "description": "PennyLane API: estimator.ops.SingleExcitation. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "or.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops.SingleExcitation qml.estimator.ops.T qml.estimator.ops.TemporaryAND qml.estimator.ops."
    },
    {
      "id": "qml.estimator.ops.S",
      "name": "qml.estimator.ops.S",
      "type": "function",
      "description": "PennyLane API: estimator.ops.S. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "bitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops.SingleExcitation qml.estimator.ops.T qml.es"
    },
    {
      "id": "qml.estimator.ops.T",
      "name": "qml.estimator.ops.T",
      "type": "function",
      "description": "PennyLane API: estimator.ops.T. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops.SingleExcitation qml.estimator.ops.T qml.estimator.ops.TemporaryAND qml.estimator.ops.Toffoli qml.estimator.ops.X qml.est"
    },
    {
      "id": "qml.estimator.ops.CRot",
      "name": "qml.estimator.ops.CRot",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CRot. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator.ops.CZ qml.estimator.o"
    },
    {
      "id": "qml.estimator.ops.Hadamard",
      "name": "qml.estimator.ops.Hadamard",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Hadamard. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "l.estimator.ops.Controlled qml.estimator.ops.ControlledPhaseShift qml.estimator.ops.GlobalPhase qml.estimator.ops.Hadamard qml.estimator.ops.Identity qml.estimator.ops.MultiControlledX qml.estimator.o"
    },
    {
      "id": "qml.estimator.ops.Prod",
      "name": "qml.estimator.ops.Prod",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Prod. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "mator.ops.PCPhase qml.estimator.ops.PauliRot qml.estimator.ops.PhaseShift qml.estimator.ops.Pow qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary qml.estimator.ops.RX qml.estimator.ops.RY qml.esti"
    },
    {
      "id": "qml.estimator.ops.CH",
      "name": "qml.estimator.ops.CH",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CH. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "e Operators Qubit Management Resource Operators qml.estimator.ops.Adjoint qml.estimator.ops.CCZ qml.estimator.ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.op"
    },
    {
      "id": "qml.estimator.ops.CY",
      "name": "qml.estimator.ops.CY",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CY. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": ".CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator.ops.CZ qml.estimator.ops.ChangeOpBasis qml.estimator.ops.Controlled q"
    },
    {
      "id": "qml.estimator.ops.Identity",
      "name": "qml.estimator.ops.Identity",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Identity. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "qml.estimator.ops.ControlledPhaseShift qml.estimator.ops.GlobalPhase qml.estimator.ops.Hadamard qml.estimator.ops.Identity qml.estimator.ops.MultiControlledX qml.estimator.ops.MultiRZ qml.estimator.op"
    },
    {
      "id": "qml.estimator.ops.CRZ",
      "name": "qml.estimator.ops.CRZ",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CRZ. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ops.CCZ qml.estimator.ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator."
    },
    {
      "id": "qml.estimator.ops.Controlled",
      "name": "qml.estimator.ops.Controlled",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Controlled. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "l.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator.ops.CZ qml.estimator.ops.ChangeOpBasis qml.estimator.ops.Controlled qml.estimator.ops.ControlledPhaseShift qml.estimator.ops.GlobalPhase qml.es"
    },
    {
      "id": "qml.estimator.ops.CNOT",
      "name": "qml.estimator.ops.CNOT",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CNOT. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "agement Resource Operators qml.estimator.ops.Adjoint qml.estimator.ops.CCZ qml.estimator.ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.o"
    },
    {
      "id": "qml.estimator.ops.Y",
      "name": "qml.estimator.ops.Y",
      "type": "function",
      "description": "PennyLane API: estimator.ops.Y. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ml.estimator.ops.T qml.estimator.ops.TemporaryAND qml.estimator.ops.Toffoli qml.estimator.ops.X qml.estimator.ops.Y qml.estimator.ops.Z   Resource Templates Resource Hamiltonians QPE Resource Classes "
    },
    {
      "id": "qml.estimator.ops.CRY",
      "name": "qml.estimator.ops.CRY",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CRY. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "Adjoint qml.estimator.ops.CCZ qml.estimator.ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.ops.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator"
    },
    {
      "id": "qml.estimator.ops.PauliRot",
      "name": "qml.estimator.ops.PauliRot",
      "type": "function",
      "description": "PennyLane API: estimator.ops.PauliRot. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "Identity qml.estimator.ops.MultiControlledX qml.estimator.ops.MultiRZ qml.estimator.ops.PCPhase qml.estimator.ops.PauliRot qml.estimator.ops.PhaseShift qml.estimator.ops.Pow qml.estimator.ops.Prod qml"
    },
    {
      "id": "qml.estimator.ops.SWAP",
      "name": "qml.estimator.ops.SWAP",
      "type": "function",
      "description": "PennyLane API: estimator.ops.SWAP. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "ator.ops.RX qml.estimator.ops.RY qml.estimator.ops.RZ qml.estimator.ops.Rot qml.estimator.ops.S qml.estimator.ops.SWAP qml.estimator.ops.SingleExcitation qml.estimator.ops.T qml.estimator.ops.Temporar"
    },
    {
      "id": "qml.estimator.ops.MultiControlledX",
      "name": "qml.estimator.ops.MultiControlledX",
      "type": "function",
      "description": "PennyLane API: estimator.ops.MultiControlledX. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "dPhaseShift qml.estimator.ops.GlobalPhase qml.estimator.ops.Hadamard qml.estimator.ops.Identity qml.estimator.ops.MultiControlledX qml.estimator.ops.MultiRZ qml.estimator.ops.PCPhase qml.estimator.ops"
    },
    {
      "id": "qml.estimator.ops.CCZ",
      "name": "qml.estimator.ops.CCZ",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CCZ. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "rce Estimation Resource Operators Qubit Management Resource Operators qml.estimator.ops.Adjoint qml.estimator.ops.CCZ qml.estimator.ops.CH qml.estimator.ops.CNOT qml.estimator.ops.CRX qml.estimator.op"
    },
    {
      "id": "qml.estimator.ops.PhaseShift",
      "name": "qml.estimator.ops.PhaseShift",
      "type": "function",
      "description": "PennyLane API: estimator.ops.PhaseShift. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "MultiControlledX qml.estimator.ops.MultiRZ qml.estimator.ops.PCPhase qml.estimator.ops.PauliRot qml.estimator.ops.PhaseShift qml.estimator.ops.Pow qml.estimator.ops.Prod qml.estimator.ops.QubitUnitary"
    },
    {
      "id": "qml.estimator.ops.CZ",
      "name": "qml.estimator.ops.CZ",
      "type": "function",
      "description": "PennyLane API: estimator.ops.CZ. Found in pennylane.estimator.ops.Adjoint.html",
      "source_file": "pennylane.estimator.ops.Adjoint.html",
      "context": "s.CRY qml.estimator.ops.CRZ qml.estimator.ops.CRot qml.estimator.ops.CSWAP qml.estimator.ops.CY qml.estimator.ops.CZ qml.estimator.ops.ChangeOpBasis qml.estimator.ops.Controlled qml.estimator.ops.Cont"
    },
    {
      "id": "qml.estimator.qpe_resources.FirstQuantization",
      "name": "qml.estimator.qpe_resources.FirstQuantization",
      "type": "function",
      "description": "PennyLane API: estimator.qpe_resources.FirstQuantization. Found in pennylane.estimator.qpe_resources.DoubleFactorization.html",
      "source_file": "pennylane.estimator.qpe_resources.DoubleFactorization.html",
      "context": "bit Management Resource Operators Resource Templates Resource Hamiltonians QPE Resource Classes qml.estimator.qpe_resources.FirstQuantization qml.estimator.qpe_resources.DoubleFactorization   Measurem"
    },
    {
      "id": "qml.estimator.qpe_resources.DoubleFactorization",
      "name": "qml.estimator.qpe_resources.DoubleFactorization",
      "type": "function",
      "description": "PennyLane API: estimator.qpe_resources.DoubleFactorization. Found in pennylane.estimator.qpe_resources.DoubleFactorization.html",
      "source_file": "pennylane.estimator.qpe_resources.DoubleFactorization.html",
      "context": "                                         qml.estimator.qpe_resources.DoubleFactorization — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.estimator.resource_operator.CompressedResourceOp",
      "name": "qml.estimator.resource_operator.CompressedResourceOp",
      "type": "function",
      "description": "PennyLane API: estimator.resource_operator.CompressedResourceOp. Found in pennylane.estimator.resource_operator.CompressedResourceOp.html",
      "source_file": "pennylane.estimator.resource_operator.CompressedResourceOp.html",
      "context": "                                         qml.estimator.resource_operator.CompressedResourceOp — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.estimator.resource_operator.GateCount",
      "name": "qml.estimator.resource_operator.GateCount",
      "type": "function",
      "description": "PennyLane API: estimator.resource_operator.GateCount. Found in pennylane.estimator.resource_operator.CompressedResourceOp.html",
      "source_file": "pennylane.estimator.resource_operator.CompressedResourceOp.html",
      "context": "timator.resource_operator.ResourceOperator qml.estimator.resource_operator.CompressedResourceOp qml.estimator.resource_operator.GateCount   Qubit Management Resource Operators Resource Templates Resou"
    },
    {
      "id": "qml.estimator.resource_operator.ResourceOperator",
      "name": "qml.estimator.resource_operator.ResourceOperator",
      "type": "function",
      "description": "PennyLane API: estimator.resource_operator.ResourceOperator. Found in pennylane.estimator.resource_operator.CompressedResourceOp.html",
      "source_file": "pennylane.estimator.resource_operator.CompressedResourceOp.html",
      "context": "qml.decomposition qml.debugging qml.drawer qml.estimator Resource Estimation Resource Operators qml.estimator.resource_operator.ResourceOperator qml.estimator.resource_operator.CompressedResourceOp qm"
    },
    {
      "id": "qml.estimator.templates.RegisterComparator",
      "name": "qml.estimator.templates.RegisterComparator",
      "type": "function",
      "description": "PennyLane API: estimator.templates.RegisterComparator. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "r.templates.Qubitization qml.estimator.templates.QubitizeTHC qml.estimator.templates.Reflection qml.estimator.templates.RegisterComparator qml.estimator.templates.Select qml.estimator.templates.Select"
    },
    {
      "id": "qml.estimator.templates.QubitizeTHC",
      "name": "qml.estimator.templates.QubitizeTHC",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QubitizeTHC. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "n qml.estimator.templates.QSP qml.estimator.templates.QSVT qml.estimator.templates.Qubitization qml.estimator.templates.QubitizeTHC qml.estimator.templates.Reflection qml.estimator.templates.RegisterC"
    },
    {
      "id": "qml.estimator.templates.UnaryIterationQPE",
      "name": "qml.estimator.templates.UnaryIterationQPE",
      "type": "function",
      "description": "PennyLane API: estimator.templates.UnaryIterationQPE. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "rVibrational qml.estimator.templates.TrotterVibronic qml.estimator.templates.TwoQubitComparator qml.estimator.templates.UnaryIterationQPE qml.estimator.templates.UniformStatePrep   Resource Hamiltonia"
    },
    {
      "id": "qml.estimator.templates.GQSP",
      "name": "qml.estimator.templates.GQSP",
      "type": "function",
      "description": "PennyLane API: estimator.templates.GQSP. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "mplates.BBQRAM qml.estimator.templates.BasisRotation qml.estimator.templates.ControlledSequence qml.estimator.templates.GQSP qml.estimator.templates.GQSPTimeEvolution qml.estimator.templates.IQP qml.e"
    },
    {
      "id": "qml.estimator.templates.PrepTHC",
      "name": "qml.estimator.templates.PrepTHC",
      "type": "function",
      "description": "PennyLane API: estimator.templates.PrepTHC. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "es.OutMultiplier qml.estimator.templates.OutOfPlaceSquare qml.estimator.templates.PhaseGradient qml.estimator.templates.PrepTHC qml.estimator.templates.QFT qml.estimator.templates.QPE qml.estimator.te"
    },
    {
      "id": "qml.estimator.templates.IntegerComparator",
      "name": "qml.estimator.templates.IntegerComparator",
      "type": "function",
      "description": "PennyLane API: estimator.templates.IntegerComparator. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": ".estimator.templates.GQSP qml.estimator.templates.GQSPTimeEvolution qml.estimator.templates.IQP qml.estimator.templates.IntegerComparator qml.estimator.templates.IterativeQPE qml.estimator.templates.M"
    },
    {
      "id": "qml.estimator.templates.IterativeQPE",
      "name": "qml.estimator.templates.IterativeQPE",
      "type": "function",
      "description": "PennyLane API: estimator.templates.IterativeQPE. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "mplates.GQSPTimeEvolution qml.estimator.templates.IQP qml.estimator.templates.IntegerComparator qml.estimator.templates.IterativeQPE qml.estimator.templates.MPSPrep qml.estimator.templates.OutMultipli"
    },
    {
      "id": "qml.estimator.templates.SelectTHC",
      "name": "qml.estimator.templates.SelectTHC",
      "type": "function",
      "description": "PennyLane API: estimator.templates.SelectTHC. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "tor.templates.Select qml.estimator.templates.SelectPauli qml.estimator.templates.SelectPauliRot qml.estimator.templates.SelectTHC qml.estimator.templates.SemiAdder qml.estimator.templates.SingleQubitC"
    },
    {
      "id": "qml.estimator.templates.TrotterPauli",
      "name": "qml.estimator.templates.TrotterPauli",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TrotterPauli. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "ates.SemiAdder qml.estimator.templates.SingleQubitComparator qml.estimator.templates.TrotterCDF qml.estimator.templates.TrotterPauli qml.estimator.templates.TrotterProduct qml.estimator.templates.Trot"
    },
    {
      "id": "qml.estimator.templates.BasisRotation",
      "name": "qml.estimator.templates.BasisRotation",
      "type": "function",
      "description": "PennyLane API: estimator.templates.BasisRotation. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "l.estimator.templates.AQFT qml.estimator.templates.AliasSampling qml.estimator.templates.BBQRAM qml.estimator.templates.BasisRotation qml.estimator.templates.ControlledSequence qml.estimator.templates"
    },
    {
      "id": "qml.estimator.templates.ControlledSequence",
      "name": "qml.estimator.templates.ControlledSequence",
      "type": "function",
      "description": "PennyLane API: estimator.templates.ControlledSequence. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "or.templates.AliasSampling qml.estimator.templates.BBQRAM qml.estimator.templates.BasisRotation qml.estimator.templates.ControlledSequence qml.estimator.templates.GQSP qml.estimator.templates.GQSPTime"
    },
    {
      "id": "qml.estimator.templates.GQSPTimeEvolution",
      "name": "qml.estimator.templates.GQSPTimeEvolution",
      "type": "function",
      "description": "PennyLane API: estimator.templates.GQSPTimeEvolution. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "templates.BasisRotation qml.estimator.templates.ControlledSequence qml.estimator.templates.GQSP qml.estimator.templates.GQSPTimeEvolution qml.estimator.templates.IQP qml.estimator.templates.IntegerCom"
    },
    {
      "id": "qml.estimator.templates.QROM",
      "name": "qml.estimator.templates.QROM",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QROM. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "radient qml.estimator.templates.PrepTHC qml.estimator.templates.QFT qml.estimator.templates.QPE qml.estimator.templates.QROM qml.estimator.templates.QROMStatePreparation qml.estimator.templates.QSP qm"
    },
    {
      "id": "qml.estimator.templates.IQP",
      "name": "qml.estimator.templates.IQP",
      "type": "function",
      "description": "PennyLane API: estimator.templates.IQP. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "lates.ControlledSequence qml.estimator.templates.GQSP qml.estimator.templates.GQSPTimeEvolution qml.estimator.templates.IQP qml.estimator.templates.IntegerComparator qml.estimator.templates.IterativeQ"
    },
    {
      "id": "qml.estimator.templates.QROMStatePreparation",
      "name": "qml.estimator.templates.QROMStatePreparation",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QROMStatePreparation. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "es.PrepTHC qml.estimator.templates.QFT qml.estimator.templates.QPE qml.estimator.templates.QROM qml.estimator.templates.QROMStatePreparation qml.estimator.templates.QSP qml.estimator.templates.QSVT qm"
    },
    {
      "id": "qml.estimator.templates.OutMultiplier",
      "name": "qml.estimator.templates.OutMultiplier",
      "type": "function",
      "description": "PennyLane API: estimator.templates.OutMultiplier. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "emplates.IntegerComparator qml.estimator.templates.IterativeQPE qml.estimator.templates.MPSPrep qml.estimator.templates.OutMultiplier qml.estimator.templates.OutOfPlaceSquare qml.estimator.templates.P"
    },
    {
      "id": "qml.estimator.templates.Select",
      "name": "qml.estimator.templates.Select",
      "type": "function",
      "description": "PennyLane API: estimator.templates.Select. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "lates.QubitizeTHC qml.estimator.templates.Reflection qml.estimator.templates.RegisterComparator qml.estimator.templates.Select qml.estimator.templates.SelectPauli qml.estimator.templates.SelectPauliRo"
    },
    {
      "id": "qml.estimator.templates.TrotterVibrational",
      "name": "qml.estimator.templates.TrotterVibrational",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TrotterVibrational. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "emplates.TrotterPauli qml.estimator.templates.TrotterProduct qml.estimator.templates.TrotterTHC qml.estimator.templates.TrotterVibrational qml.estimator.templates.TrotterVibronic qml.estimator.templat"
    },
    {
      "id": "qml.estimator.templates.TrotterTHC",
      "name": "qml.estimator.templates.TrotterTHC",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TrotterTHC. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "emplates.TrotterCDF qml.estimator.templates.TrotterPauli qml.estimator.templates.TrotterProduct qml.estimator.templates.TrotterTHC qml.estimator.templates.TrotterVibrational qml.estimator.templates.Tr"
    },
    {
      "id": "qml.estimator.templates.QPE",
      "name": "qml.estimator.templates.QPE",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QPE. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "l.estimator.templates.PhaseGradient qml.estimator.templates.PrepTHC qml.estimator.templates.QFT qml.estimator.templates.QPE qml.estimator.templates.QROM qml.estimator.templates.QROMStatePreparation qm"
    },
    {
      "id": "qml.estimator.templates.QFT",
      "name": "qml.estimator.templates.QFT",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QFT. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "emplates.OutOfPlaceSquare qml.estimator.templates.PhaseGradient qml.estimator.templates.PrepTHC qml.estimator.templates.QFT qml.estimator.templates.QPE qml.estimator.templates.QROM qml.estimator.templ"
    },
    {
      "id": "qml.estimator.templates.TrotterVibronic",
      "name": "qml.estimator.templates.TrotterVibronic",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TrotterVibronic. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "es.TrotterProduct qml.estimator.templates.TrotterTHC qml.estimator.templates.TrotterVibrational qml.estimator.templates.TrotterVibronic qml.estimator.templates.TwoQubitComparator qml.estimator.templat"
    },
    {
      "id": "qml.estimator.templates.SemiAdder",
      "name": "qml.estimator.templates.SemiAdder",
      "type": "function",
      "description": "PennyLane API: estimator.templates.SemiAdder. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": ".templates.SelectPauli qml.estimator.templates.SelectPauliRot qml.estimator.templates.SelectTHC qml.estimator.templates.SemiAdder qml.estimator.templates.SingleQubitComparator qml.estimator.templates."
    },
    {
      "id": "qml.estimator.templates.AQFT",
      "name": "qml.estimator.templates.AQFT",
      "type": "function",
      "description": "PennyLane API: estimator.templates.AQFT. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "                                         qml.estimator.templates.AQFT — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.estimator.templates.PhaseGradient",
      "name": "qml.estimator.templates.PhaseGradient",
      "type": "function",
      "description": "PennyLane API: estimator.templates.PhaseGradient. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "emplates.MPSPrep qml.estimator.templates.OutMultiplier qml.estimator.templates.OutOfPlaceSquare qml.estimator.templates.PhaseGradient qml.estimator.templates.PrepTHC qml.estimator.templates.QFT qml.es"
    },
    {
      "id": "qml.estimator.templates.QSVT",
      "name": "qml.estimator.templates.QSVT",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QSVT. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "timator.templates.QROM qml.estimator.templates.QROMStatePreparation qml.estimator.templates.QSP qml.estimator.templates.QSVT qml.estimator.templates.Qubitization qml.estimator.templates.QubitizeTHC qm"
    },
    {
      "id": "qml.estimator.templates.SingleQubitComparator",
      "name": "qml.estimator.templates.SingleQubitComparator",
      "type": "function",
      "description": "PennyLane API: estimator.templates.SingleQubitComparator. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "or.templates.SelectPauliRot qml.estimator.templates.SelectTHC qml.estimator.templates.SemiAdder qml.estimator.templates.SingleQubitComparator qml.estimator.templates.TrotterCDF qml.estimator.templates"
    },
    {
      "id": "qml.estimator.templates.SelectPauliRot",
      "name": "qml.estimator.templates.SelectPauliRot",
      "type": "function",
      "description": "PennyLane API: estimator.templates.SelectPauliRot. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "templates.RegisterComparator qml.estimator.templates.Select qml.estimator.templates.SelectPauli qml.estimator.templates.SelectPauliRot qml.estimator.templates.SelectTHC qml.estimator.templates.SemiAdd"
    },
    {
      "id": "qml.estimator.templates.UniformStatePrep",
      "name": "qml.estimator.templates.UniformStatePrep",
      "type": "function",
      "description": "PennyLane API: estimator.templates.UniformStatePrep. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "erVibronic qml.estimator.templates.TwoQubitComparator qml.estimator.templates.UnaryIterationQPE qml.estimator.templates.UniformStatePrep   Resource Hamiltonians QPE Resource Classes Measurement Functi"
    },
    {
      "id": "qml.estimator.templates.OutOfPlaceSquare",
      "name": "qml.estimator.templates.OutOfPlaceSquare",
      "type": "function",
      "description": "PennyLane API: estimator.templates.OutOfPlaceSquare. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "or.templates.IterativeQPE qml.estimator.templates.MPSPrep qml.estimator.templates.OutMultiplier qml.estimator.templates.OutOfPlaceSquare qml.estimator.templates.PhaseGradient qml.estimator.templates.P"
    },
    {
      "id": "qml.estimator.templates.TrotterCDF",
      "name": "qml.estimator.templates.TrotterCDF",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TrotterCDF. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "lates.SelectTHC qml.estimator.templates.SemiAdder qml.estimator.templates.SingleQubitComparator qml.estimator.templates.TrotterCDF qml.estimator.templates.TrotterPauli qml.estimator.templates.TrotterP"
    },
    {
      "id": "qml.estimator.templates.TrotterProduct",
      "name": "qml.estimator.templates.TrotterProduct",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TrotterProduct. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "s.SingleQubitComparator qml.estimator.templates.TrotterCDF qml.estimator.templates.TrotterPauli qml.estimator.templates.TrotterProduct qml.estimator.templates.TrotterTHC qml.estimator.templates.Trotte"
    },
    {
      "id": "qml.estimator.templates.Qubitization",
      "name": "qml.estimator.templates.Qubitization",
      "type": "function",
      "description": "PennyLane API: estimator.templates.Qubitization. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "timator.templates.QROMStatePreparation qml.estimator.templates.QSP qml.estimator.templates.QSVT qml.estimator.templates.Qubitization qml.estimator.templates.QubitizeTHC qml.estimator.templates.Reflect"
    },
    {
      "id": "qml.estimator.templates.AliasSampling",
      "name": "qml.estimator.templates.AliasSampling",
      "type": "function",
      "description": "PennyLane API: estimator.templates.AliasSampling. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "e Operators Qubit Management Resource Operators Resource Templates qml.estimator.templates.AQFT qml.estimator.templates.AliasSampling qml.estimator.templates.BBQRAM qml.estimator.templates.BasisRotati"
    },
    {
      "id": "qml.estimator.templates.SelectPauli",
      "name": "qml.estimator.templates.SelectPauli",
      "type": "function",
      "description": "PennyLane API: estimator.templates.SelectPauli. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": ".templates.Reflection qml.estimator.templates.RegisterComparator qml.estimator.templates.Select qml.estimator.templates.SelectPauli qml.estimator.templates.SelectPauliRot qml.estimator.templates.Selec"
    },
    {
      "id": "qml.estimator.templates.BBQRAM",
      "name": "qml.estimator.templates.BBQRAM",
      "type": "function",
      "description": "PennyLane API: estimator.templates.BBQRAM. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "Operators Resource Templates qml.estimator.templates.AQFT qml.estimator.templates.AliasSampling qml.estimator.templates.BBQRAM qml.estimator.templates.BasisRotation qml.estimator.templates.ControlledS"
    },
    {
      "id": "qml.estimator.templates.Reflection",
      "name": "qml.estimator.templates.Reflection",
      "type": "function",
      "description": "PennyLane API: estimator.templates.Reflection. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "timator.templates.QSVT qml.estimator.templates.Qubitization qml.estimator.templates.QubitizeTHC qml.estimator.templates.Reflection qml.estimator.templates.RegisterComparator qml.estimator.templates.Se"
    },
    {
      "id": "qml.estimator.templates.QSP",
      "name": "qml.estimator.templates.QSP",
      "type": "function",
      "description": "PennyLane API: estimator.templates.QSP. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "timator.templates.QPE qml.estimator.templates.QROM qml.estimator.templates.QROMStatePreparation qml.estimator.templates.QSP qml.estimator.templates.QSVT qml.estimator.templates.Qubitization qml.estima"
    },
    {
      "id": "qml.estimator.templates.TwoQubitComparator",
      "name": "qml.estimator.templates.TwoQubitComparator",
      "type": "function",
      "description": "PennyLane API: estimator.templates.TwoQubitComparator. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "s.TrotterTHC qml.estimator.templates.TrotterVibrational qml.estimator.templates.TrotterVibronic qml.estimator.templates.TwoQubitComparator qml.estimator.templates.UnaryIterationQPE qml.estimator.templ"
    },
    {
      "id": "qml.estimator.templates.MPSPrep",
      "name": "qml.estimator.templates.MPSPrep",
      "type": "function",
      "description": "PennyLane API: estimator.templates.MPSPrep. Found in pennylane.estimator.templates.AQFT.html",
      "source_file": "pennylane.estimator.templates.AQFT.html",
      "context": "or.templates.IQP qml.estimator.templates.IntegerComparator qml.estimator.templates.IterativeQPE qml.estimator.templates.MPSPrep qml.estimator.templates.OutMultiplier qml.estimator.templates.OutOfPlace"
    },
    {
      "id": "qml.estimator.wires_manager.WireResourceManager",
      "name": "qml.estimator.wires_manager.WireResourceManager",
      "type": "function",
      "description": "PennyLane API: estimator.wires_manager.WireResourceManager. Found in pennylane.estimator.wires_manager.Allocate.html",
      "source_file": "pennylane.estimator.wires_manager.Allocate.html",
      "context": "rs Qubit Management qml.estimator.wires_manager.Allocate qml.estimator.wires_manager.Deallocate qml.estimator.wires_manager.WireResourceManager   Resource Operators Resource Templates Resource Hamilto"
    },
    {
      "id": "qml.estimator.wires_manager.Allocate",
      "name": "qml.estimator.wires_manager.Allocate",
      "type": "function",
      "description": "PennyLane API: estimator.wires_manager.Allocate. Found in pennylane.estimator.wires_manager.Allocate.html",
      "source_file": "pennylane.estimator.wires_manager.Allocate.html",
      "context": "                                         qml.estimator.wires_manager.Allocate — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.estimator.wires_manager.Deallocate",
      "name": "qml.estimator.wires_manager.Deallocate",
      "type": "function",
      "description": "PennyLane API: estimator.wires_manager.Deallocate. Found in pennylane.estimator.wires_manager.Allocate.html",
      "source_file": "pennylane.estimator.wires_manager.Allocate.html",
      "context": "or Resource Estimation Resource Operators Qubit Management qml.estimator.wires_manager.Allocate qml.estimator.wires_manager.Deallocate qml.estimator.wires_manager.WireResourceManager   Resource Operat"
    },
    {
      "id": "qml.exceptions.AdjointUndefinedError",
      "name": "qml.exceptions.AdjointUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.AdjointUndefinedError. Found in pennylane.exceptions.AdjointUndefinedError.html",
      "source_file": "pennylane.exceptions.AdjointUndefinedError.html",
      "context": "                                         qml.exceptions.AdjointUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.AllocationError",
      "name": "qml.exceptions.AllocationError",
      "type": "function",
      "description": "PennyLane API: exceptions.AllocationError. Found in pennylane.exceptions.AllocationError.html",
      "source_file": "pennylane.exceptions.AllocationError.html",
      "context": "                                         qml.exceptions.AllocationError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.AutoGraphError",
      "name": "qml.exceptions.AutoGraphError",
      "type": "function",
      "description": "PennyLane API: exceptions.AutoGraphError. Found in pennylane.exceptions.AutoGraphError.html",
      "source_file": "pennylane.exceptions.AutoGraphError.html",
      "context": "                                         qml.exceptions.AutoGraphError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.AutoGraphWarning",
      "name": "qml.exceptions.AutoGraphWarning",
      "type": "function",
      "description": "PennyLane API: exceptions.AutoGraphWarning. Found in pennylane.exceptions.AutoGraphWarning.html",
      "source_file": "pennylane.exceptions.AutoGraphWarning.html",
      "context": "                                         qml.exceptions.AutoGraphWarning — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.CaptureError",
      "name": "qml.exceptions.CaptureError",
      "type": "function",
      "description": "PennyLane API: exceptions.CaptureError. Found in pennylane.exceptions.CaptureError.html",
      "source_file": "pennylane.exceptions.CaptureError.html",
      "context": "                                         qml.exceptions.CaptureError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.CompileError",
      "name": "qml.exceptions.CompileError",
      "type": "function",
      "description": "PennyLane API: exceptions.CompileError. Found in pennylane.exceptions.CompileError.html",
      "source_file": "pennylane.exceptions.CompileError.html",
      "context": "                                         qml.exceptions.CompileError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.ConditionalTransformError",
      "name": "qml.exceptions.ConditionalTransformError",
      "type": "function",
      "description": "PennyLane API: exceptions.ConditionalTransformError. Found in pennylane.exceptions.ConditionalTransformError.html",
      "source_file": "pennylane.exceptions.ConditionalTransformError.html",
      "context": "                                         qml.exceptions.ConditionalTransformError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.DecompositionError",
      "name": "qml.exceptions.DecompositionError",
      "type": "function",
      "description": "PennyLane API: exceptions.DecompositionError. Found in pennylane.exceptions.DecompositionError.html",
      "source_file": "pennylane.exceptions.DecompositionError.html",
      "context": "                                         qml.exceptions.DecompositionError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.DecompositionUndefinedError",
      "name": "qml.exceptions.DecompositionUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.DecompositionUndefinedError. Found in pennylane.exceptions.DecompositionUndefinedError.html",
      "source_file": "pennylane.exceptions.DecompositionUndefinedError.html",
      "context": "                                         qml.exceptions.DecompositionUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.DeviceError",
      "name": "qml.exceptions.DeviceError",
      "type": "function",
      "description": "PennyLane API: exceptions.DeviceError. Found in pennylane.exceptions.DeviceError.html",
      "source_file": "pennylane.exceptions.DeviceError.html",
      "context": "                                         qml.exceptions.DeviceError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.DiagGatesUndefinedError",
      "name": "qml.exceptions.DiagGatesUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.DiagGatesUndefinedError. Found in pennylane.exceptions.DiagGatesUndefinedError.html",
      "source_file": "pennylane.exceptions.DiagGatesUndefinedError.html",
      "context": "                                         qml.exceptions.DiagGatesUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.EigvalsUndefinedError",
      "name": "qml.exceptions.EigvalsUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.EigvalsUndefinedError. Found in pennylane.exceptions.EigvalsUndefinedError.html",
      "source_file": "pennylane.exceptions.EigvalsUndefinedError.html",
      "context": "                                         qml.exceptions.EigvalsUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.ExperimentalWarning",
      "name": "qml.exceptions.ExperimentalWarning",
      "type": "function",
      "description": "PennyLane API: exceptions.ExperimentalWarning. Found in pennylane.exceptions.ExperimentalWarning.html",
      "source_file": "pennylane.exceptions.ExperimentalWarning.html",
      "context": "                                         qml.exceptions.ExperimentalWarning — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.GeneratorUndefinedError",
      "name": "qml.exceptions.GeneratorUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.GeneratorUndefinedError. Found in pennylane.exceptions.GeneratorUndefinedError.html",
      "source_file": "pennylane.exceptions.GeneratorUndefinedError.html",
      "context": "                                         qml.exceptions.GeneratorUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.InvalidCapabilitiesError",
      "name": "qml.exceptions.InvalidCapabilitiesError",
      "type": "function",
      "description": "PennyLane API: exceptions.InvalidCapabilitiesError. Found in pennylane.exceptions.InvalidCapabilitiesError.html",
      "source_file": "pennylane.exceptions.InvalidCapabilitiesError.html",
      "context": "                                         qml.exceptions.InvalidCapabilitiesError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.MatrixUndefinedError",
      "name": "qml.exceptions.MatrixUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.MatrixUndefinedError. Found in pennylane.exceptions.MatrixUndefinedError.html",
      "source_file": "pennylane.exceptions.MatrixUndefinedError.html",
      "context": "                                         qml.exceptions.MatrixUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.MeasurementShapeError",
      "name": "qml.exceptions.MeasurementShapeError",
      "type": "function",
      "description": "PennyLane API: exceptions.MeasurementShapeError. Found in pennylane.exceptions.MeasurementShapeError.html",
      "source_file": "pennylane.exceptions.MeasurementShapeError.html",
      "context": "                                         qml.exceptions.MeasurementShapeError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.NonDifferentiableError",
      "name": "qml.exceptions.NonDifferentiableError",
      "type": "function",
      "description": "PennyLane API: exceptions.NonDifferentiableError. Found in pennylane.exceptions.NonDifferentiableError.html",
      "source_file": "pennylane.exceptions.NonDifferentiableError.html",
      "context": "                                         qml.exceptions.NonDifferentiableError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.OperatorPropertyUndefined",
      "name": "qml.exceptions.OperatorPropertyUndefined",
      "type": "function",
      "description": "PennyLane API: exceptions.OperatorPropertyUndefined. Found in pennylane.exceptions.OperatorPropertyUndefined.html",
      "source_file": "pennylane.exceptions.OperatorPropertyUndefined.html",
      "context": "                                         qml.exceptions.OperatorPropertyUndefined — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.ParameterFrequenciesUndefinedError",
      "name": "qml.exceptions.ParameterFrequenciesUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.ParameterFrequenciesUndefinedError. Found in pennylane.exceptions.ParameterFrequenciesUndefinedError.html",
      "source_file": "pennylane.exceptions.ParameterFrequenciesUndefinedError.html",
      "context": "                                         qml.exceptions.ParameterFrequenciesUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.PennyLaneDeprecationWarning",
      "name": "qml.exceptions.PennyLaneDeprecationWarning",
      "type": "function",
      "description": "PennyLane API: exceptions.PennyLaneDeprecationWarning. Found in pennylane.exceptions.PennyLaneDeprecationWarning.html",
      "source_file": "pennylane.exceptions.PennyLaneDeprecationWarning.html",
      "context": "                                         qml.exceptions.PennyLaneDeprecationWarning — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.PowUndefinedError",
      "name": "qml.exceptions.PowUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.PowUndefinedError. Found in pennylane.exceptions.PowUndefinedError.html",
      "source_file": "pennylane.exceptions.PowUndefinedError.html",
      "context": "                                         qml.exceptions.PowUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.QuantumFunctionError",
      "name": "qml.exceptions.QuantumFunctionError",
      "type": "function",
      "description": "PennyLane API: exceptions.QuantumFunctionError. Found in pennylane.exceptions.QuantumFunctionError.html",
      "source_file": "pennylane.exceptions.QuantumFunctionError.html",
      "context": "                                         qml.exceptions.QuantumFunctionError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.QueuingError",
      "name": "qml.exceptions.QueuingError",
      "type": "function",
      "description": "PennyLane API: exceptions.QueuingError. Found in pennylane.exceptions.QueuingError.html",
      "source_file": "pennylane.exceptions.QueuingError.html",
      "context": "                                         qml.exceptions.QueuingError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.SparseMatrixUndefinedError",
      "name": "qml.exceptions.SparseMatrixUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.SparseMatrixUndefinedError. Found in pennylane.exceptions.SparseMatrixUndefinedError.html",
      "source_file": "pennylane.exceptions.SparseMatrixUndefinedError.html",
      "context": "                                         qml.exceptions.SparseMatrixUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.TermsUndefinedError",
      "name": "qml.exceptions.TermsUndefinedError",
      "type": "function",
      "description": "PennyLane API: exceptions.TermsUndefinedError. Found in pennylane.exceptions.TermsUndefinedError.html",
      "source_file": "pennylane.exceptions.TermsUndefinedError.html",
      "context": "                                         qml.exceptions.TermsUndefinedError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.TransformError",
      "name": "qml.exceptions.TransformError",
      "type": "function",
      "description": "PennyLane API: exceptions.TransformError. Found in pennylane.exceptions.TransformError.html",
      "source_file": "pennylane.exceptions.TransformError.html",
      "context": "                                         qml.exceptions.TransformError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.exceptions.WireError",
      "name": "qml.exceptions.WireError",
      "type": "function",
      "description": "PennyLane API: exceptions.WireError. Found in pennylane.exceptions.WireError.html",
      "source_file": "pennylane.exceptions.WireError.html",
      "context": "                                         qml.exceptions.WireError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.workflow.get_best_diff_method",
      "name": "qml.workflow.get_best_diff_method",
      "type": "function",
      "description": "PennyLane API: workflow.get_best_diff_method. Found in pennylane.execute.html",
      "source_file": "pennylane.execute.html",
      "context": "flow.construct_batch qml.workflow.construct_execution_config qml.workflow.get_transform_program qml.workflow.get_best_diff_method qml.workflow.set_shots   Jacobian Product Calculation Return Type Spec"
    },
    {
      "id": "qml.workflow.set_shots",
      "name": "qml.workflow.set_shots",
      "type": "function",
      "description": "PennyLane API: workflow.set_shots. Found in pennylane.execute.html",
      "source_file": "pennylane.execute.html",
      "context": "construct_execution_config qml.workflow.get_transform_program qml.workflow.get_best_diff_method qml.workflow.set_shots   Jacobian Product Calculation Return Type Specification           Navigation   i"
    },
    {
      "id": "qml.fourier.get_spectrum",
      "name": "qml.fourier.get_spectrum",
      "type": "function",
      "description": "PennyLane API: fourier.get_spectrum. Found in pennylane.fourier.get_spectrum.html",
      "source_file": "pennylane.fourier.get_spectrum.html",
      "context": "                                         qml.fourier.get_spectrum — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.fourier.join_spectra",
      "name": "qml.fourier.join_spectra",
      "type": "function",
      "description": "PennyLane API: fourier.join_spectra. Found in pennylane.fourier.join_spectra.html",
      "source_file": "pennylane.fourier.join_spectra.html",
      "context": "                                         qml.fourier.join_spectra — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.fourier.visualize.bar",
      "name": "qml.fourier.visualize.bar",
      "type": "function",
      "description": "PennyLane API: fourier.visualize.bar. Found in pennylane.fourier.visualize.bar.html",
      "source_file": "pennylane.fourier.visualize.bar.html",
      "context": "                                         qml.fourier.visualize.bar — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.fourier.visualize.box",
      "name": "qml.fourier.visualize.box",
      "type": "function",
      "description": "PennyLane API: fourier.visualize.box. Found in pennylane.fourier.visualize.box.html",
      "source_file": "pennylane.fourier.visualize.box.html",
      "context": "                                         qml.fourier.visualize.box — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.fourier.visualize.panel",
      "name": "qml.fourier.visualize.panel",
      "type": "function",
      "description": "PennyLane API: fourier.visualize.panel. Found in pennylane.fourier.visualize.panel.html",
      "source_file": "pennylane.fourier.visualize.panel.html",
      "context": "                                         qml.fourier.visualize.panel — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.fourier.visualize.violin",
      "name": "qml.fourier.visualize.violin",
      "type": "function",
      "description": "PennyLane API: fourier.visualize.violin. Found in pennylane.fourier.visualize.violin.html",
      "source_file": "pennylane.fourier.visualize.violin.html",
      "context": "                                         qml.fourier.visualize.violin — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.QNode.",
      "name": "qml.QNode.",
      "type": "class",
      "description": "PennyLane API: QNode.. Found in pennylane.from_qasm.html",
      "source_file": "pennylane.from_qasm.html",
      "context": "rom_qasm using the measurements argument, making it possible to create a PennyLane circuit with qml.QNode. dev = qml.device(\"default.qubit\") measurements = [qml.var(qml.Y(0))] circuit = qml.QNode(qml."
    },
    {
      "id": "qml.ftqc.RotXZX",
      "name": "qml.ftqc.RotXZX",
      "type": "function",
      "description": "PennyLane API: ftqc.RotXZX. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": "ncurrency qml.devices qml.exceptions qml.ftqc Modules Functions Classes qml.ftqc.GraphStatePrep qml.ftqc.RotXZX qml.ftqc.Lattice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml"
    },
    {
      "id": "qml.ftqc.ParametricMidMeasure",
      "name": "qml.ftqc.ParametricMidMeasure",
      "type": "function",
      "description": "PennyLane API: ftqc.ParametricMidMeasure. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": " qml.ftqc.GraphStatePrep qml.ftqc.RotXZX qml.ftqc.Lattice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml.ftqc.XMidMeasure qml.ftqc.YMidMeasure Overview   Pauli Tracker   qml.m"
    },
    {
      "id": "qml.ftqc.QubitGraph",
      "name": "qml.ftqc.QubitGraph",
      "type": "function",
      "description": "PennyLane API: ftqc.QubitGraph. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": "ons qml.ftqc Modules Functions Classes qml.ftqc.GraphStatePrep qml.ftqc.RotXZX qml.ftqc.Lattice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml.ftqc.XMidMeasure qml.ftqc.YMidMe"
    },
    {
      "id": "qml.ftqc.YMidMeasure",
      "name": "qml.ftqc.YMidMeasure",
      "type": "function",
      "description": "PennyLane API: ftqc.YMidMeasure. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": "attice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml.ftqc.XMidMeasure qml.ftqc.YMidMeasure Overview   Pauli Tracker   qml.measurements qml.pytrees qml.operation qml.queuing q"
    },
    {
      "id": "qml.ftqc.Lattice",
      "name": "qml.ftqc.Lattice",
      "type": "function",
      "description": "PennyLane API: ftqc.Lattice. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": "vices qml.exceptions qml.ftqc Modules Functions Classes qml.ftqc.GraphStatePrep qml.ftqc.RotXZX qml.ftqc.Lattice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml.ftqc.XMidMeasur"
    },
    {
      "id": "qml.ftqc.QubitMgr",
      "name": "qml.ftqc.QubitMgr",
      "type": "function",
      "description": "PennyLane API: ftqc.QubitMgr. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": " Functions Classes qml.ftqc.GraphStatePrep qml.ftqc.RotXZX qml.ftqc.Lattice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml.ftqc.XMidMeasure qml.ftqc.YMidMeasure Overview   Pau"
    },
    {
      "id": "qml.ftqc.XMidMeasure",
      "name": "qml.ftqc.XMidMeasure",
      "type": "function",
      "description": "PennyLane API: ftqc.XMidMeasure. Found in pennylane.ftqc.GraphStatePrep.html",
      "source_file": "pennylane.ftqc.GraphStatePrep.html",
      "context": "tqc.RotXZX qml.ftqc.Lattice qml.ftqc.QubitGraph qml.ftqc.QubitMgr qml.ftqc.ParametricMidMeasure qml.ftqc.XMidMeasure qml.ftqc.YMidMeasure Overview   Pauli Tracker   qml.measurements qml.pytrees qml.op"
    },
    {
      "id": "qml.ftqc.measure_y",
      "name": "qml.ftqc.measure_y",
      "type": "function",
      "description": "PennyLane API: ftqc.measure_y. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "tqc Modules Functions qml.ftqc.cond_measure qml.ftqc.measure_arbitrary_basis qml.ftqc.measure_x qml.ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_mbqc_formalism qml.f"
    },
    {
      "id": "qml.ftqc.measure_x",
      "name": "qml.ftqc.measure_x",
      "type": "function",
      "description": "PennyLane API: ftqc.measure_x. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "ml.exceptions qml.ftqc Modules Functions qml.ftqc.cond_measure qml.ftqc.measure_arbitrary_basis qml.ftqc.measure_x qml.ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_m"
    },
    {
      "id": "qml.ftqc.diagonalize_mcms",
      "name": "qml.ftqc.diagonalize_mcms",
      "type": "function",
      "description": "PennyLane API: ftqc.diagonalize_mcms. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "asure qml.ftqc.measure_arbitrary_basis qml.ftqc.measure_x qml.ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_mbqc_formalism qml.ftqc.convert_to_mbqc_gateset qml.ftqc.g"
    },
    {
      "id": "qml.ftqc.convert_to_mbqc_gateset",
      "name": "qml.ftqc.convert_to_mbqc_gateset",
      "type": "function",
      "description": "PennyLane API: ftqc.convert_to_mbqc_gateset. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": ".ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_mbqc_formalism qml.ftqc.convert_to_mbqc_gateset qml.ftqc.generate_lattice qml.ftqc.make_graph_state qml.ftqc.get_byprod"
    },
    {
      "id": "qml.ftqc.make_graph_state",
      "name": "qml.ftqc.make_graph_state",
      "type": "function",
      "description": "PennyLane API: ftqc.make_graph_state. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "s qml.ftqc.convert_to_mbqc_formalism qml.ftqc.convert_to_mbqc_gateset qml.ftqc.generate_lattice qml.ftqc.make_graph_state qml.ftqc.get_byproduct_corrections   Classes Pauli Tracker   qml.measurements "
    },
    {
      "id": "qml.ftqc.measure_z",
      "name": "qml.ftqc.measure_z",
      "type": "function",
      "description": "PennyLane API: ftqc.measure_z. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "ns qml.ftqc.cond_measure qml.ftqc.measure_arbitrary_basis qml.ftqc.measure_x qml.ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_mbqc_formalism qml.ftqc.convert_to_mbqc"
    },
    {
      "id": "qml.ftqc.measure_arbitrary_basis",
      "name": "qml.ftqc.measure_arbitrary_basis",
      "type": "function",
      "description": "PennyLane API: ftqc.measure_arbitrary_basis. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "ure qml.concurrency qml.devices qml.exceptions qml.ftqc Modules Functions qml.ftqc.cond_measure qml.ftqc.measure_arbitrary_basis qml.ftqc.measure_x qml.ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diago"
    },
    {
      "id": "qml.ftqc.convert_to_mbqc_formalism",
      "name": "qml.ftqc.convert_to_mbqc_formalism",
      "type": "function",
      "description": "PennyLane API: ftqc.convert_to_mbqc_formalism. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "itrary_basis qml.ftqc.measure_x qml.ftqc.measure_y qml.ftqc.measure_z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_mbqc_formalism qml.ftqc.convert_to_mbqc_gateset qml.ftqc.generate_lattice qml.ftqc.m"
    },
    {
      "id": "qml.ftqc.generate_lattice",
      "name": "qml.ftqc.generate_lattice",
      "type": "function",
      "description": "PennyLane API: ftqc.generate_lattice. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "z qml.ftqc.diagonalize_mcms qml.ftqc.convert_to_mbqc_formalism qml.ftqc.convert_to_mbqc_gateset qml.ftqc.generate_lattice qml.ftqc.make_graph_state qml.ftqc.get_byproduct_corrections   Classes Pauli T"
    },
    {
      "id": "qml.ftqc.get_byproduct_corrections",
      "name": "qml.ftqc.get_byproduct_corrections",
      "type": "function",
      "description": "PennyLane API: ftqc.get_byproduct_corrections. Found in pennylane.ftqc.cond_measure.html",
      "source_file": "pennylane.ftqc.cond_measure.html",
      "context": "_formalism qml.ftqc.convert_to_mbqc_gateset qml.ftqc.generate_lattice qml.ftqc.make_graph_state qml.ftqc.get_byproduct_corrections   Classes Pauli Tracker   qml.measurements qml.pytrees qml.operation "
    },
    {
      "id": "qml.ftqc.cond_measure.",
      "name": "qml.ftqc.cond_measure.",
      "type": "function",
      "description": "PennyLane API: ftqc.cond_measure.. Found in pennylane.ftqc.diagonalize_mcms.html",
      "source_file": "pennylane.ftqc.diagonalize_mcms.html",
      "context": "ents       The transform can also handle diagonalization of conditional measurements created by qml.ftqc.cond_measure. This is done by replacing the measurements for the true and false condition with "
    },
    {
      "id": "qml.measure.",
      "name": "qml.measure.",
      "type": "function",
      "description": "PennyLane API: measure.. Found in pennylane.ftqc.measure_x.html",
      "source_file": "pennylane.ftqc.measure_x.html",
      "context": "onvention. For more details on the results of mid-circuit measurements and how to use them, see qml.measure. For more details on mid-circuit measurements in an arbitrary basis (besides the computation"
    },
    {
      "id": "qml.ftqc.pauli_tracker.pauli_to_xz",
      "name": "qml.ftqc.pauli_tracker.pauli_to_xz",
      "type": "function",
      "description": "PennyLane API: ftqc.pauli_tracker.pauli_to_xz. Found in pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "source_file": "pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "context": "ure qml.concurrency qml.devices qml.exceptions qml.ftqc Modules Functions Classes Pauli Tracker qml.ftqc.pauli_tracker.pauli_to_xz qml.ftqc.pauli_tracker.xz_to_pauli qml.ftqc.pauli_tracker.pauli_prod "
    },
    {
      "id": "qml.ftqc.pauli_tracker.xz_to_pauli",
      "name": "qml.ftqc.pauli_tracker.xz_to_pauli",
      "type": "function",
      "description": "PennyLane API: ftqc.pauli_tracker.xz_to_pauli. Found in pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "source_file": "pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "context": ".exceptions qml.ftqc Modules Functions Classes Pauli Tracker qml.ftqc.pauli_tracker.pauli_to_xz qml.ftqc.pauli_tracker.xz_to_pauli qml.ftqc.pauli_tracker.pauli_prod qml.ftqc.pauli_tracker.commute_clif"
    },
    {
      "id": "qml.ftqc.pauli_tracker.get_byproduct_corrections",
      "name": "qml.ftqc.pauli_tracker.get_byproduct_corrections",
      "type": "function",
      "description": "PennyLane API: ftqc.pauli_tracker.get_byproduct_corrections. Found in pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "source_file": "pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "context": "racker.xz_to_pauli qml.ftqc.pauli_tracker.pauli_prod qml.ftqc.pauli_tracker.commute_clifford_op qml.ftqc.pauli_tracker.get_byproduct_corrections     qml.measurements qml.pytrees qml.operation qml.queu"
    },
    {
      "id": "qml.ftqc.pauli_tracker.commute_clifford_op",
      "name": "qml.ftqc.pauli_tracker.commute_clifford_op",
      "type": "function",
      "description": "PennyLane API: ftqc.pauli_tracker.commute_clifford_op. Found in pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "source_file": "pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "context": "                                         qml.ftqc.pauli_tracker.commute_clifford_op — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.ftqc.pauli_tracker.pauli_prod",
      "name": "qml.ftqc.pauli_tracker.pauli_prod",
      "type": "function",
      "description": "PennyLane API: ftqc.pauli_tracker.pauli_prod. Found in pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "source_file": "pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "context": "ons Classes Pauli Tracker qml.ftqc.pauli_tracker.pauli_to_xz qml.ftqc.pauli_tracker.xz_to_pauli qml.ftqc.pauli_tracker.pauli_prod qml.ftqc.pauli_tracker.commute_clifford_op qml.ftqc.pauli_tracker.get_"
    },
    {
      "id": "qml.CNOT.",
      "name": "qml.CNOT.",
      "type": "class",
      "description": "PennyLane API: CNOT.. Found in pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "source_file": "pennylane.ftqc.pauli_tracker.commute_clifford_op.html",
      "context": "rs:  clifford_op (Operator) – A Clifford operator class. Supported operators are: qml.S, qml.H, qml.CNOT. xz (list(tuple)) – A list of xz tuples which map to Pauli operators   Returns: A list of new x"
    },
    {
      "id": "qml.gradients.finite_diff_coeffs",
      "name": "qml.gradients.finite_diff_coeffs",
      "type": "function",
      "description": "PennyLane API: gradients.finite_diff_coeffs. Found in pennylane.gradients.finite_diff_coeffs.html",
      "source_file": "pennylane.gradients.finite_diff_coeffs.html",
      "context": "                                         qml.gradients.finite_diff_coeffs — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.gradients.generate_multi_shift_rule",
      "name": "qml.gradients.generate_multi_shift_rule",
      "type": "function",
      "description": "PennyLane API: gradients.generate_multi_shift_rule. Found in pennylane.gradients.generate_multi_shift_rule.html",
      "source_file": "pennylane.gradients.generate_multi_shift_rule.html",
      "context": "                                         qml.gradients.generate_multi_shift_rule — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.gradients.generate_multishifted_tapes",
      "name": "qml.gradients.generate_multishifted_tapes",
      "type": "function",
      "description": "PennyLane API: gradients.generate_multishifted_tapes. Found in pennylane.gradients.generate_multishifted_tapes.html",
      "source_file": "pennylane.gradients.generate_multishifted_tapes.html",
      "context": "                                         qml.gradients.generate_multishifted_tapes — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.gradients.generate_shift_rule",
      "name": "qml.gradients.generate_shift_rule",
      "type": "function",
      "description": "PennyLane API: gradients.generate_shift_rule. Found in pennylane.gradients.generate_shift_rule.html",
      "source_file": "pennylane.gradients.generate_shift_rule.html",
      "context": "                                         qml.gradients.generate_shift_rule — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.gradients.generate_shifted_tapes",
      "name": "qml.gradients.generate_shifted_tapes",
      "type": "function",
      "description": "PennyLane API: gradients.generate_shifted_tapes. Found in pennylane.gradients.generate_shifted_tapes.html",
      "source_file": "pennylane.gradients.generate_shifted_tapes.html",
      "context": "                                         qml.gradients.generate_shifted_tapes — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.io.ToBloq",
      "name": "qml.io.ToBloq",
      "type": "function",
      "description": "PennyLane API: io.ToBloq. Found in pennylane.io.ToBloq.html",
      "source_file": "pennylane.io.ToBloq.html",
      "context": "                                         qml.io.ToBloq — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.kernels.mitigate_depolarizing_noise",
      "name": "qml.kernels.mitigate_depolarizing_noise",
      "type": "function",
      "description": "PennyLane API: kernels.mitigate_depolarizing_noise. Found in pennylane.kernels.mitigate_depolarizing_noise.html",
      "source_file": "pennylane.kernels.mitigate_depolarizing_noise.html",
      "context": "                                         qml.kernels.mitigate_depolarizing_noise — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.layer.",
      "name": "qml.layer.",
      "type": "function",
      "description": "PennyLane API: layer.. Found in pennylane.layer.html",
      "source_file": "pennylane.layer.html",
      "context": "on’t change with each repetition. Static parameters are always passed as keyword arguments into qml.layer. For example, consider the following subroutine: def subroutine(wires):     qml.Hadamard(wires"
    },
    {
      "id": "qml.liealg.A",
      "name": "qml.liealg.A",
      "type": "function",
      "description": "PennyLane API: liealg.A. Found in pennylane.liealg.A.html",
      "source_file": "pennylane.liealg.A.html",
      "context": "                                         qml.liealg.A — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.AI",
      "name": "qml.liealg.AI",
      "type": "function",
      "description": "PennyLane API: liealg.AI. Found in pennylane.liealg.AI.html",
      "source_file": "pennylane.liealg.AI.html",
      "context": "                                         qml.liealg.AI — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.AII",
      "name": "qml.liealg.AII",
      "type": "function",
      "description": "PennyLane API: liealg.AII. Found in pennylane.liealg.AII.html",
      "source_file": "pennylane.liealg.AII.html",
      "context": "                                         qml.liealg.AII — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.AIII",
      "name": "qml.liealg.AIII",
      "type": "function",
      "description": "PennyLane API: liealg.AIII. Found in pennylane.liealg.AIII.html",
      "source_file": "pennylane.liealg.AIII.html",
      "context": "                                         qml.liealg.AIII — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.BD",
      "name": "qml.liealg.BD",
      "type": "function",
      "description": "PennyLane API: liealg.BD. Found in pennylane.liealg.BD.html",
      "source_file": "pennylane.liealg.BD.html",
      "context": "                                         qml.liealg.BD — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.BDI",
      "name": "qml.liealg.BDI",
      "type": "function",
      "description": "PennyLane API: liealg.BDI. Found in pennylane.liealg.BDI.html",
      "source_file": "pennylane.liealg.BDI.html",
      "context": "                                         qml.liealg.BDI — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.C",
      "name": "qml.liealg.C",
      "type": "function",
      "description": "PennyLane API: liealg.C. Found in pennylane.liealg.C.html",
      "source_file": "pennylane.liealg.C.html",
      "context": "                                         qml.liealg.C — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.CI",
      "name": "qml.liealg.CI",
      "type": "function",
      "description": "PennyLane API: liealg.CI. Found in pennylane.liealg.CI.html",
      "source_file": "pennylane.liealg.CI.html",
      "context": "                                         qml.liealg.CI — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.CII",
      "name": "qml.liealg.CII",
      "type": "function",
      "description": "PennyLane API: liealg.CII. Found in pennylane.liealg.CII.html",
      "source_file": "pennylane.liealg.CII.html",
      "context": "                                         qml.liealg.CII — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.DIII",
      "name": "qml.liealg.DIII",
      "type": "function",
      "description": "PennyLane API: liealg.DIII. Found in pennylane.liealg.DIII.html",
      "source_file": "pennylane.liealg.DIII.html",
      "context": "                                         qml.liealg.DIII — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.center",
      "name": "qml.liealg.center",
      "type": "function",
      "description": "PennyLane API: liealg.center. Found in pennylane.liealg.center.html",
      "source_file": "pennylane.liealg.center.html",
      "context": "                                         qml.liealg.center — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.change_basis_ad_rep",
      "name": "qml.liealg.change_basis_ad_rep",
      "type": "function",
      "description": "PennyLane API: liealg.change_basis_ad_rep. Found in pennylane.liealg.change_basis_ad_rep.html",
      "source_file": "pennylane.liealg.change_basis_ad_rep.html",
      "context": "                                         qml.liealg.change_basis_ad_rep — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.check_cartan_decomp",
      "name": "qml.liealg.check_cartan_decomp",
      "type": "function",
      "description": "PennyLane API: liealg.check_cartan_decomp. Found in pennylane.liealg.check_cartan_decomp.html",
      "source_file": "pennylane.liealg.check_cartan_decomp.html",
      "context": "                                         qml.liealg.check_cartan_decomp — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.concurrence_involution",
      "name": "qml.liealg.concurrence_involution",
      "type": "function",
      "description": "PennyLane API: liealg.concurrence_involution. Found in pennylane.liealg.concurrence_involution.html",
      "source_file": "pennylane.liealg.concurrence_involution.html",
      "context": "                                         qml.liealg.concurrence_involution — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.lie_closure",
      "name": "qml.liealg.lie_closure",
      "type": "function",
      "description": "PennyLane API: liealg.lie_closure. Found in pennylane.liealg.lie_closure.html",
      "source_file": "pennylane.liealg.lie_closure.html",
      "context": "                                         qml.liealg.lie_closure — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.op_to_adjvec",
      "name": "qml.liealg.op_to_adjvec",
      "type": "function",
      "description": "PennyLane API: liealg.op_to_adjvec. Found in pennylane.liealg.op_to_adjvec.html",
      "source_file": "pennylane.liealg.op_to_adjvec.html",
      "context": "                                         qml.liealg.op_to_adjvec — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.liealg.structure_constants",
      "name": "qml.liealg.structure_constants",
      "type": "function",
      "description": "PennyLane API: liealg.structure_constants. Found in pennylane.liealg.structure_constants.html",
      "source_file": "pennylane.liealg.structure_constants.html",
      "context": "                                         qml.liealg.structure_constants — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.logging.DebugOnlyFilter",
      "name": "qml.logging.DebugOnlyFilter",
      "type": "function",
      "description": "PennyLane API: logging.DebugOnlyFilter. Found in pennylane.logging.DebugOnlyFilter.html",
      "source_file": "pennylane.logging.DebugOnlyFilter.html",
      "context": "                                         qml.logging.DebugOnlyFilter — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.logging.LocalProcessFilter",
      "name": "qml.logging.LocalProcessFilter",
      "type": "function",
      "description": "PennyLane API: logging.LocalProcessFilter. Found in pennylane.logging.DebugOnlyFilter.html",
      "source_file": "pennylane.logging.DebugOnlyFilter.html",
      "context": "l.liealg qml.logging Functions Classes qml.logging.DebugOnlyFilter qml.logging.DefaultFormatter qml.logging.LocalProcessFilter qml.logging.SimpleFormatter   Variables   qml.math qml.noise qml.numpy qm"
    },
    {
      "id": "qml.logging.DefaultFormatter",
      "name": "qml.logging.DefaultFormatter",
      "type": "function",
      "description": "PennyLane API: logging.DefaultFormatter. Found in pennylane.logging.DebugOnlyFilter.html",
      "source_file": "pennylane.logging.DebugOnlyFilter.html",
      "context": "ml.io qml.kernels qml.labs qml.liealg qml.logging Functions Classes qml.logging.DebugOnlyFilter qml.logging.DefaultFormatter qml.logging.LocalProcessFilter qml.logging.SimpleFormatter   Variables   qm"
    },
    {
      "id": "qml.logging.SimpleFormatter",
      "name": "qml.logging.SimpleFormatter",
      "type": "function",
      "description": "PennyLane API: logging.SimpleFormatter. Found in pennylane.logging.DebugOnlyFilter.html",
      "source_file": "pennylane.logging.DebugOnlyFilter.html",
      "context": "Classes qml.logging.DebugOnlyFilter qml.logging.DefaultFormatter qml.logging.LocalProcessFilter qml.logging.SimpleFormatter   Variables   qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pul"
    },
    {
      "id": "qml.logging.config_path",
      "name": "qml.logging.config_path",
      "type": "function",
      "description": "PennyLane API: logging.config_path. Found in pennylane.logging.config_path.html",
      "source_file": "pennylane.logging.config_path.html",
      "context": "                                         qml.logging.config_path — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.logging.edit_system_config",
      "name": "qml.logging.edit_system_config",
      "type": "function",
      "description": "PennyLane API: logging.edit_system_config. Found in pennylane.logging.config_path.html",
      "source_file": "pennylane.logging.config_path.html",
      "context": ".gradients qml.io qml.kernels qml.labs qml.liealg qml.logging Functions qml.logging.config_path qml.logging.edit_system_config qml.logging.enable_logging   Classes Variables   qml.math qml.noise qml.n"
    },
    {
      "id": "qml.logging.debug_logger",
      "name": "qml.logging.debug_logger",
      "type": "function",
      "description": "PennyLane API: logging.debug_logger. Found in pennylane.logging.debug_logger.html",
      "source_file": "pennylane.logging.debug_logger.html",
      "context": "                                         qml.logging.debug_logger — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.logging.debug_logger_init",
      "name": "qml.logging.debug_logger_init",
      "type": "function",
      "description": "PennyLane API: logging.debug_logger_init. Found in pennylane.logging.debug_logger.html",
      "source_file": "pennylane.logging.debug_logger.html",
      "context": "ml.kernels qml.labs qml.liealg qml.logging Functions Classes Variables qml.logging.debug_logger qml.logging.debug_logger_init     qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.q"
    },
    {
      "id": "qml.math.Interface",
      "name": "qml.math.Interface",
      "type": "function",
      "description": "PennyLane API: math.Interface. Found in pennylane.math.Interface.html",
      "source_file": "pennylane.math.Interface.html",
      "context": "                                         qml.math.Interface — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.convert_to_su2",
      "name": "qml.math.convert_to_su2",
      "type": "function",
      "description": "PennyLane API: math.convert_to_su2. Found in pennylane.math.convert_to_su2.html",
      "source_file": "pennylane.math.convert_to_su2.html",
      "context": "                                         qml.math.convert_to_su2 — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.math.convert_to_su4",
      "name": "qml.math.convert_to_su4",
      "type": "function",
      "description": "PennyLane API: math.convert_to_su4. Found in pennylane.math.convert_to_su4.html",
      "source_file": "pennylane.math.convert_to_su4.html",
      "context": "                                         qml.math.convert_to_su4 — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.math.decomposition.decomp_int_to_powers_of_two",
      "name": "qml.math.decomposition.decomp_int_to_powers_of_two",
      "type": "function",
      "description": "PennyLane API: math.decomposition.decomp_int_to_powers_of_two. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": "                                         qml.math.decomposition.decomp_int_to_powers_of_two — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.math.decomposition.givens_decomposition",
      "name": "qml.math.decomposition.givens_decomposition",
      "type": "function",
      "description": "PennyLane API: math.decomposition.givens_decomposition. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": "verview Utility functions for decompositions qml.math.decomposition.decomp_int_to_powers_of_two qml.math.decomposition.givens_decomposition qml.math.decomposition.su2su2_to_tensor_products qml.math.de"
    },
    {
      "id": "qml.math.decomposition.xzx_rotation_angles",
      "name": "qml.math.decomposition.xzx_rotation_angles",
      "type": "function",
      "description": "PennyLane API: math.decomposition.xzx_rotation_angles. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": "ion qml.math.decomposition.su2su2_to_tensor_products qml.math.decomposition.xyx_rotation_angles qml.math.decomposition.xzx_rotation_angles qml.math.decomposition.zxz_rotation_angles qml.math.decomposi"
    },
    {
      "id": "qml.math.decomposition.zxz_rotation_angles",
      "name": "qml.math.decomposition.zxz_rotation_angles",
      "type": "function",
      "description": "PennyLane API: math.decomposition.zxz_rotation_angles. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": "_products qml.math.decomposition.xyx_rotation_angles qml.math.decomposition.xzx_rotation_angles qml.math.decomposition.zxz_rotation_angles qml.math.decomposition.zyz_rotation_angles     qml.noise qml."
    },
    {
      "id": "qml.math.decomposition.zyz_rotation_angles",
      "name": "qml.math.decomposition.zyz_rotation_angles",
      "type": "function",
      "description": "PennyLane API: math.decomposition.zyz_rotation_angles. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": "on_angles qml.math.decomposition.xzx_rotation_angles qml.math.decomposition.zxz_rotation_angles qml.math.decomposition.zyz_rotation_angles     qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse q"
    },
    {
      "id": "qml.math.decomposition.xyx_rotation_angles",
      "name": "qml.math.decomposition.xyx_rotation_angles",
      "type": "function",
      "description": "PennyLane API: math.decomposition.xyx_rotation_angles. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": "wo qml.math.decomposition.givens_decomposition qml.math.decomposition.su2su2_to_tensor_products qml.math.decomposition.xyx_rotation_angles qml.math.decomposition.xzx_rotation_angles qml.math.decomposi"
    },
    {
      "id": "qml.math.decomposition.su2su2_to_tensor_products",
      "name": "qml.math.decomposition.su2su2_to_tensor_products",
      "type": "function",
      "description": "PennyLane API: math.decomposition.su2su2_to_tensor_products. Found in pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "source_file": "pennylane.math.decomposition.decomp_int_to_powers_of_two.html",
      "context": " qml.math.decomposition.decomp_int_to_powers_of_two qml.math.decomposition.givens_decomposition qml.math.decomposition.su2su2_to_tensor_products qml.math.decomposition.xyx_rotation_angles qml.math.dec"
    },
    {
      "id": "qml.math.get_batch_size",
      "name": "qml.math.get_batch_size",
      "type": "function",
      "description": "PennyLane API: math.get_batch_size. Found in pennylane.math.get_batch_size.html",
      "source_file": "pennylane.math.get_batch_size.html",
      "context": "                                         qml.math.get_batch_size — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.in_backprop",
      "name": "qml.math.in_backprop",
      "type": "function",
      "description": "PennyLane API: math.in_backprop. Found in pennylane.math.in_backprop.html",
      "source_file": "pennylane.math.in_backprop.html",
      "context": "                                         qml.math.in_backprop — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.iscomplex",
      "name": "qml.math.iscomplex",
      "type": "function",
      "description": "PennyLane API: math.iscomplex. Found in pennylane.math.iscomplex.html",
      "source_file": "pennylane.math.iscomplex.html",
      "context": "                                         qml.math.iscomplex — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.marginal_prob",
      "name": "qml.math.marginal_prob",
      "type": "function",
      "description": "PennyLane API: math.marginal_prob. Found in pennylane.math.marginal_prob.html",
      "source_file": "pennylane.math.marginal_prob.html",
      "context": "                                         qml.math.marginal_prob — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.max_entropy",
      "name": "qml.math.max_entropy",
      "type": "function",
      "description": "PennyLane API: math.max_entropy. Found in pennylane.math.max_entropy.html",
      "source_file": "pennylane.math.max_entropy.html",
      "context": "                                         qml.math.max_entropy — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.math.min_entropy",
      "name": "qml.math.min_entropy",
      "type": "function",
      "description": "PennyLane API: math.min_entropy. Found in pennylane.math.min_entropy.html",
      "source_file": "pennylane.math.min_entropy.html",
      "context": "                                         qml.math.min_entropy — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.math.purity",
      "name": "qml.math.purity",
      "type": "function",
      "description": "PennyLane API: math.purity. Found in pennylane.math.purity.html",
      "source_file": "pennylane.math.purity.html",
      "context": "                                         qml.math.purity — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.math.reduce_dm",
      "name": "qml.math.reduce_dm",
      "type": "function",
      "description": "PennyLane API: math.reduce_dm. Found in pennylane.math.reduce_dm.html",
      "source_file": "pennylane.math.reduce_dm.html",
      "context": "                                         qml.math.reduce_dm — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.reduce_matrices",
      "name": "qml.math.reduce_matrices",
      "type": "function",
      "description": "PennyLane API: math.reduce_matrices. Found in pennylane.math.reduce_matrices.html",
      "source_file": "pennylane.math.reduce_matrices.html",
      "context": "                                         qml.math.reduce_matrices — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.set_index",
      "name": "qml.math.set_index",
      "type": "function",
      "description": "PennyLane API: math.set_index. Found in pennylane.math.set_index.html",
      "source_file": "pennylane.math.set_index.html",
      "context": "                                         qml.math.set_index — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.sqrt_matrix",
      "name": "qml.math.sqrt_matrix",
      "type": "function",
      "description": "PennyLane API: math.sqrt_matrix. Found in pennylane.math.sqrt_matrix.html",
      "source_file": "pennylane.math.sqrt_matrix.html",
      "context": "                                         qml.math.sqrt_matrix — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.ClassicalShadowMP",
      "name": "qml.measurements.ClassicalShadowMP",
      "type": "function",
      "description": "PennyLane API: measurements.ClassicalShadowMP. Found in pennylane.measurements.ClassicalShadowMP.html",
      "source_file": "pennylane.measurements.ClassicalShadowMP.html",
      "context": "                                         qml.measurements.ClassicalShadowMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.DensityMatrixMP",
      "name": "qml.measurements.DensityMatrixMP",
      "type": "function",
      "description": "PennyLane API: measurements.DensityMatrixMP. Found in pennylane.measurements.DensityMatrixMP.html",
      "source_file": "pennylane.measurements.DensityMatrixMP.html",
      "context": "                                         qml.measurements.DensityMatrixMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.MeasurementTransform",
      "name": "qml.measurements.MeasurementTransform",
      "type": "function",
      "description": "PennyLane API: measurements.MeasurementTransform. Found in pennylane.measurements.MeasurementTransform.html",
      "source_file": "pennylane.measurements.MeasurementTransform.html",
      "context": "                                         qml.measurements.MeasurementTransform — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.measurements.MutualInfoMP",
      "name": "qml.measurements.MutualInfoMP",
      "type": "function",
      "description": "PennyLane API: measurements.MutualInfoMP. Found in pennylane.measurements.MutualInfoMP.html",
      "source_file": "pennylane.measurements.MutualInfoMP.html",
      "context": "                                         qml.measurements.MutualInfoMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.ProbabilityMP",
      "name": "qml.measurements.ProbabilityMP",
      "type": "function",
      "description": "PennyLane API: measurements.ProbabilityMP. Found in pennylane.measurements.ProbabilityMP.html",
      "source_file": "pennylane.measurements.ProbabilityMP.html",
      "context": "                                         qml.measurements.ProbabilityMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.PurityMP",
      "name": "qml.measurements.PurityMP",
      "type": "function",
      "description": "PennyLane API: measurements.PurityMP. Found in pennylane.measurements.PurityMP.html",
      "source_file": "pennylane.measurements.PurityMP.html",
      "context": "                                         qml.measurements.PurityMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.SampleMP",
      "name": "qml.measurements.SampleMP",
      "type": "function",
      "description": "PennyLane API: measurements.SampleMP. Found in pennylane.measurements.SampleMP.html",
      "source_file": "pennylane.measurements.SampleMP.html",
      "context": "                                         qml.measurements.SampleMP — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.measurements.ShadowExpvalMP",
      "name": "qml.measurements.ShadowExpvalMP",
      "type": "function",
      "description": "PennyLane API: measurements.ShadowExpvalMP. Found in pennylane.measurements.ShadowExpvalMP.html",
      "source_file": "pennylane.measurements.ShadowExpvalMP.html",
      "context": "                                         qml.measurements.ShadowExpvalMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.ShotCopies",
      "name": "qml.measurements.ShotCopies",
      "type": "function",
      "description": "PennyLane API: measurements.ShotCopies. Found in pennylane.measurements.ShotCopies.html",
      "source_file": "pennylane.measurements.ShotCopies.html",
      "context": "                                         qml.measurements.ShotCopies — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.measurements.ShotsLike",
      "name": "qml.measurements.ShotsLike",
      "type": "function",
      "description": "PennyLane API: measurements.ShotsLike. Found in pennylane.measurements.ShotsLike.html",
      "source_file": "pennylane.measurements.ShotsLike.html",
      "context": "                                         qml.measurements.ShotsLike — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.measurements.StateMeasurement",
      "name": "qml.measurements.StateMeasurement",
      "type": "function",
      "description": "PennyLane API: measurements.StateMeasurement. Found in pennylane.measurements.StateMeasurement.html",
      "source_file": "pennylane.measurements.StateMeasurement.html",
      "context": "                                         qml.measurements.StateMeasurement — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.measurements.VnEntropyMP",
      "name": "qml.measurements.VnEntropyMP",
      "type": "function",
      "description": "PennyLane API: measurements.VnEntropyMP. Found in pennylane.measurements.VnEntropyMP.html",
      "source_file": "pennylane.measurements.VnEntropyMP.html",
      "context": "                                         qml.measurements.VnEntropyMP — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.noise.conditionals.MeasEq",
      "name": "qml.noise.conditionals.MeasEq",
      "type": "function",
      "description": "PennyLane API: noise.conditionals.MeasEq. Found in pennylane.noise.conditionals.MeasEq.html",
      "source_file": "pennylane.noise.conditionals.MeasEq.html",
      "context": "                                         qml.noise.conditionals.MeasEq — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.noise.conditionals.OpEq",
      "name": "qml.noise.conditionals.OpEq",
      "type": "function",
      "description": "PennyLane API: noise.conditionals.OpEq. Found in pennylane.noise.conditionals.OpEq.html",
      "source_file": "pennylane.noise.conditionals.OpEq.html",
      "context": "                                         qml.noise.conditionals.OpEq — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.noise.conditionals.OpIn",
      "name": "qml.noise.conditionals.OpIn",
      "type": "function",
      "description": "PennyLane API: noise.conditionals.OpIn. Found in pennylane.noise.conditionals.OpIn.html",
      "source_file": "pennylane.noise.conditionals.OpIn.html",
      "context": "                                         qml.noise.conditionals.OpIn — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.noise.conditionals.WiresEq",
      "name": "qml.noise.conditionals.WiresEq",
      "type": "function",
      "description": "PennyLane API: noise.conditionals.WiresEq. Found in pennylane.noise.conditionals.WiresEq.html",
      "source_file": "pennylane.noise.conditionals.WiresEq.html",
      "context": "                                         qml.noise.conditionals.WiresEq — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.noise.conditionals.WiresIn",
      "name": "qml.noise.conditionals.WiresIn",
      "type": "function",
      "description": "PennyLane API: noise.conditionals.WiresIn. Found in pennylane.noise.conditionals.WiresIn.html",
      "source_file": "pennylane.noise.conditionals.WiresIn.html",
      "context": "                                         qml.noise.conditionals.WiresIn — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.numpy.wrap_arrays",
      "name": "qml.numpy.wrap_arrays",
      "type": "function",
      "description": "PennyLane API: numpy.wrap_arrays. Found in pennylane.numpy.NonDifferentiableError.html",
      "source_file": "pennylane.numpy.NonDifferentiableError.html",
      "context": "dients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy Overview qml.numpy.wrap_arrays qml.numpy.extract_tensors qml.numpy.tensor_wrapper qml.numpy.tensor qml.numpy.NonD"
    },
    {
      "id": "qml.numpy.extract_tensors",
      "name": "qml.numpy.extract_tensors",
      "type": "function",
      "description": "PennyLane API: numpy.extract_tensors. Found in pennylane.numpy.NonDifferentiableError.html",
      "source_file": "pennylane.numpy.NonDifferentiableError.html",
      "context": "els qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy Overview qml.numpy.wrap_arrays qml.numpy.extract_tensors qml.numpy.tensor_wrapper qml.numpy.tensor qml.numpy.NonDifferentiableError   C"
    },
    {
      "id": "qml.numpy.tensor_wrapper",
      "name": "qml.numpy.tensor_wrapper",
      "type": "function",
      "description": "PennyLane API: numpy.tensor_wrapper. Found in pennylane.numpy.NonDifferentiableError.html",
      "source_file": "pennylane.numpy.NonDifferentiableError.html",
      "context": "l.logging qml.math qml.noise qml.numpy Overview qml.numpy.wrap_arrays qml.numpy.extract_tensors qml.numpy.tensor_wrapper qml.numpy.tensor qml.numpy.NonDifferentiableError   Caveats   qml.ops.op_math q"
    },
    {
      "id": "qml.numpy.NonDifferentiableError",
      "name": "qml.numpy.NonDifferentiableError",
      "type": "function",
      "description": "PennyLane API: numpy.NonDifferentiableError. Found in pennylane.numpy.NonDifferentiableError.html",
      "source_file": "pennylane.numpy.NonDifferentiableError.html",
      "context": "                                         qml.numpy.NonDifferentiableError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.operation.CV",
      "name": "qml.operation.CV",
      "type": "function",
      "description": "PennyLane API: operation.CV. Found in pennylane.operation.CV.html",
      "source_file": "pennylane.operation.CV.html",
      "context": "                                         qml.operation.CV — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.math.requires_grad.",
      "name": "qml.math.requires_grad.",
      "type": "function",
      "description": "PennyLane API: math.requires_grad.. Found in pennylane.operation.is_trainable.html",
      "source_file": "pennylane.operation.is_trainable.html",
      "context": "inable)[source]¶ Returns True if any of the parameters of an operator is trainable according to qml.math.requires_grad.    code/api/pennylane.operation.is_trainable                      Download Pytho"
    },
    {
      "id": "qml.operation.is_trainable",
      "name": "qml.operation.is_trainable",
      "type": "function",
      "description": "PennyLane API: operation.is_trainable. Found in pennylane.operation.is_trainable.html",
      "source_file": "pennylane.operation.is_trainable.html",
      "context": "                                         qml.operation.is_trainable — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.operation.operation_derivative",
      "name": "qml.operation.operation_derivative",
      "type": "function",
      "description": "PennyLane API: operation.operation_derivative. Found in pennylane.operation.operation_derivative.html",
      "source_file": "pennylane.operation.operation_derivative.html",
      "context": "                                         qml.operation.operation_derivative — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.ops.functions.assert_valid",
      "name": "qml.ops.functions.assert_valid",
      "type": "function",
      "description": "PennyLane API: ops.functions.assert_valid. Found in pennylane.ops.functions.assert_valid.html",
      "source_file": "pennylane.ops.functions.assert_valid.html",
      "context": "                                         qml.ops.functions.assert_valid — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ops.op_math.ChangeOpBasis",
      "name": "qml.ops.op_math.ChangeOpBasis",
      "type": "function",
      "description": "PennyLane API: ops.op_math.ChangeOpBasis. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": ".noise qml.numpy qml.ops.op_math Constructor Functions Symbolic Classes qml.ops.op_math.Adjoint qml.ops.op_math.ChangeOpBasis qml.ops.op_math.CompositeOp qml.ops.op_math.Conditional qml.ops.op_math.Co"
    },
    {
      "id": "qml.ops.op_math.Conditional",
      "name": "qml.ops.op_math.Conditional",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Conditional. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "bolic Classes qml.ops.op_math.Adjoint qml.ops.op_math.ChangeOpBasis qml.ops.op_math.CompositeOp qml.ops.op_math.Conditional qml.ops.op_math.Controlled qml.ops.op_math.ControlledOp qml.ops.op_math.Evol"
    },
    {
      "id": "qml.ops.op_math.LinearCombination",
      "name": "qml.ops.op_math.LinearCombination",
      "type": "function",
      "description": "PennyLane API: ops.op_math.LinearCombination. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "s.op_math.Controlled qml.ops.op_math.ControlledOp qml.ops.op_math.Evolution qml.ops.op_math.Exp qml.ops.op_math.LinearCombination qml.ops.op_math.Pow qml.ops.op_math.Prod qml.ops.op_math.Sum qml.ops.o"
    },
    {
      "id": "qml.ops.op_math.CompositeOp",
      "name": "qml.ops.op_math.CompositeOp",
      "type": "function",
      "description": "PennyLane API: ops.op_math.CompositeOp. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "th Constructor Functions Symbolic Classes qml.ops.op_math.Adjoint qml.ops.op_math.ChangeOpBasis qml.ops.op_math.CompositeOp qml.ops.op_math.Conditional qml.ops.op_math.Controlled qml.ops.op_math.Contr"
    },
    {
      "id": "qml.ops.op_math.ControlledOp",
      "name": "qml.ops.op_math.ControlledOp",
      "type": "function",
      "description": "PennyLane API: ops.op_math.ControlledOp. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "hangeOpBasis qml.ops.op_math.CompositeOp qml.ops.op_math.Conditional qml.ops.op_math.Controlled qml.ops.op_math.ControlledOp qml.ops.op_math.Evolution qml.ops.op_math.Exp qml.ops.op_math.LinearCombina"
    },
    {
      "id": "qml.ops.op_math.Pow",
      "name": "qml.ops.op_math.Pow",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Pow. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "th.ControlledOp qml.ops.op_math.Evolution qml.ops.op_math.Exp qml.ops.op_math.LinearCombination qml.ops.op_math.Pow qml.ops.op_math.Prod qml.ops.op_math.Sum qml.ops.op_math.SProd qml.ops.op_math.Symbo"
    },
    {
      "id": "qml.ops.op_math.Exp",
      "name": "qml.ops.op_math.Exp",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Exp. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "h.Conditional qml.ops.op_math.Controlled qml.ops.op_math.ControlledOp qml.ops.op_math.Evolution qml.ops.op_math.Exp qml.ops.op_math.LinearCombination qml.ops.op_math.Pow qml.ops.op_math.Prod qml.ops.o"
    },
    {
      "id": "qml.ops.op_math.SymbolicOp",
      "name": "qml.ops.op_math.SymbolicOp",
      "type": "function",
      "description": "PennyLane API: ops.op_math.SymbolicOp. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "rCombination qml.ops.op_math.Pow qml.ops.op_math.Prod qml.ops.op_math.Sum qml.ops.op_math.SProd qml.ops.op_math.SymbolicOp qml.ops.op_math.ScalarSymbolicOp   Controlled Operator Classes Decompositions"
    },
    {
      "id": "qml.ops.op_math.Sum",
      "name": "qml.ops.op_math.Sum",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Sum. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": " qml.ops.op_math.Exp qml.ops.op_math.LinearCombination qml.ops.op_math.Pow qml.ops.op_math.Prod qml.ops.op_math.Sum qml.ops.op_math.SProd qml.ops.op_math.SymbolicOp qml.ops.op_math.ScalarSymbolicOp   "
    },
    {
      "id": "qml.ops.op_math.ScalarSymbolicOp",
      "name": "qml.ops.op_math.ScalarSymbolicOp",
      "type": "function",
      "description": "PennyLane API: ops.op_math.ScalarSymbolicOp. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "h.Pow qml.ops.op_math.Prod qml.ops.op_math.Sum qml.ops.op_math.SProd qml.ops.op_math.SymbolicOp qml.ops.op_math.ScalarSymbolicOp   Controlled Operator Classes Decompositions Control Decompositions   q"
    },
    {
      "id": "qml.ops.op_math.Adjoint",
      "name": "qml.ops.op_math.Adjoint",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Adjoint. Found in pennylane.ops.op_math.Adjoint.html",
      "source_file": "pennylane.ops.op_math.Adjoint.html",
      "context": "                                         qml.ops.op_math.Adjoint — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.ops.op_math.ctrl_decomp_zyz",
      "name": "qml.ops.op_math.ctrl_decomp_zyz",
      "type": "function",
      "description": "PennyLane API: ops.op_math.ctrl_decomp_zyz. Found in pennylane.ops.op_math.ctrl_decomp_bisect.html",
      "source_file": "pennylane.ops.op_math.ctrl_decomp_bisect.html",
      "context": "or Functions Symbolic Classes Controlled Operator Classes Decompositions Control Decompositions qml.ops.op_math.ctrl_decomp_zyz qml.ops.op_math.ctrl_decomp_bisect     qml.pauli qml.pulse qml.qaoa qml."
    },
    {
      "id": "qml.ops.op_math.ctrl_decomp_bisect",
      "name": "qml.ops.op_math.ctrl_decomp_bisect",
      "type": "function",
      "description": "PennyLane API: ops.op_math.ctrl_decomp_bisect. Found in pennylane.ops.op_math.ctrl_decomp_bisect.html",
      "source_file": "pennylane.ops.op_math.ctrl_decomp_bisect.html",
      "context": "                                         qml.ops.op_math.ctrl_decomp_bisect — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ctrl_decomp_zyz.",
      "name": "qml.ctrl_decomp_zyz.",
      "type": "function",
      "description": "PennyLane API: ctrl_decomp_zyz.. Found in pennylane.ops.op_math.ctrl_decomp_zyz.html",
      "source_file": "pennylane.ops.op_math.ctrl_decomp_zyz.html",
      "context": "e a controlled operation using qml.ctrl, or by creating the decomposed controlled version using qml.ctrl_decomp_zyz. dev = qml.device(\"default.qubit\", wires=2)  @qml.qnode(dev) def expected_circuit(op"
    },
    {
      "id": "qml.ops.qubit.attributes.Attribute",
      "name": "qml.ops.qubit.attributes.Attribute",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.Attribute. Found in pennylane.ops.qubit.attributes.Attribute.html",
      "source_file": "pennylane.ops.qubit.attributes.Attribute.html",
      "context": "                                         qml.ops.qubit.attributes.Attribute — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ops.qubit.attributes.composable_rotations",
      "name": "qml.ops.qubit.attributes.composable_rotations",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.composable_rotations. Found in pennylane.ops.qubit.attributes.composable_rotations.html",
      "source_file": "pennylane.ops.qubit.attributes.composable_rotations.html",
      "context": "                                         qml.ops.qubit.attributes.composable_rotations — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ops.qubit.attributes.diagonal_in_z_basis",
      "name": "qml.ops.qubit.attributes.diagonal_in_z_basis",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.diagonal_in_z_basis. Found in pennylane.ops.qubit.attributes.diagonal_in_z_basis.html",
      "source_file": "pennylane.ops.qubit.attributes.diagonal_in_z_basis.html",
      "context": "                                         qml.ops.qubit.attributes.diagonal_in_z_basis — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ops.qubit.attributes.self_inverses",
      "name": "qml.ops.qubit.attributes.self_inverses",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.self_inverses. Found in pennylane.ops.qubit.attributes.self_inverses.html",
      "source_file": "pennylane.ops.qubit.attributes.self_inverses.html",
      "context": "                                         qml.ops.qubit.attributes.self_inverses — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.ops.qubit.attributes.symmetric_over_control_wires",
      "name": "qml.ops.qubit.attributes.symmetric_over_control_wires",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes.symmetric_over_control_wires. Found in pennylane.ops.qubit.attributes.symmetric_over_control_wires.html",
      "source_file": "pennylane.ops.qubit.attributes.symmetric_over_control_wires.html",
      "context": "                                         qml.ops.qubit.attributes.symmetric_over_control_wires — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pattern_matching.",
      "name": "qml.pattern_matching.",
      "type": "function",
      "description": "PennyLane API: pattern_matching.. Found in pennylane.pattern_matching.html",
      "source_file": "pennylane.pattern_matching.html",
      "context": "circuit_dag, pattern_dag)   The matches are accessible by looping through the list outputted by qml.pattern_matching. This output is a list of lists containing indices. Each list represents a match be"
    },
    {
      "id": "qml.pauli.PauliGroupingStrategy",
      "name": "qml.pauli.PauliGroupingStrategy",
      "type": "function",
      "description": "PennyLane API: pauli.PauliGroupingStrategy. Found in pennylane.pauli.PauliGroupingStrategy.html",
      "source_file": "pennylane.pauli.PauliGroupingStrategy.html",
      "context": "                                         qml.pauli.PauliGroupingStrategy — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.are_pauli_words_qwc",
      "name": "qml.pauli.are_pauli_words_qwc",
      "type": "function",
      "description": "PennyLane API: pauli.are_pauli_words_qwc. Found in pennylane.pauli.are_pauli_words_qwc.html",
      "source_file": "pennylane.pauli.are_pauli_words_qwc.html",
      "context": "                                         qml.pauli.are_pauli_words_qwc — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.binary_to_pauli",
      "name": "qml.pauli.binary_to_pauli",
      "type": "function",
      "description": "PennyLane API: pauli.binary_to_pauli. Found in pennylane.pauli.binary_to_pauli.html",
      "source_file": "pennylane.pauli.binary_to_pauli.html",
      "context": "                                         qml.pauli.binary_to_pauli — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.diagonalize_pauli_word",
      "name": "qml.pauli.diagonalize_pauli_word",
      "type": "function",
      "description": "PennyLane API: pauli.diagonalize_pauli_word. Found in pennylane.pauli.diagonalize_pauli_word.html",
      "source_file": "pennylane.pauli.diagonalize_pauli_word.html",
      "context": "                                         qml.pauli.diagonalize_pauli_word — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.diagonalize_qwc_groupings",
      "name": "qml.pauli.diagonalize_qwc_groupings",
      "type": "function",
      "description": "PennyLane API: pauli.diagonalize_qwc_groupings. Found in pennylane.pauli.diagonalize_qwc_groupings.html",
      "source_file": "pennylane.pauli.diagonalize_qwc_groupings.html",
      "context": "                                         qml.pauli.diagonalize_qwc_groupings — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.grouping.graph_colouring.largest_first",
      "name": "qml.pauli.grouping.graph_colouring.largest_first",
      "type": "function",
      "description": "PennyLane API: pauli.grouping.graph_colouring.largest_first. Found in pennylane.pauli.grouping.graph_colouring.largest_first.html",
      "source_file": "pennylane.pauli.grouping.graph_colouring.largest_first.html",
      "context": "                                         qml.pauli.grouping.graph_colouring.largest_first — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.grouping.graph_colouring.recursive_largest_first",
      "name": "qml.pauli.grouping.graph_colouring.recursive_largest_first",
      "type": "function",
      "description": "PennyLane API: pauli.grouping.graph_colouring.recursive_largest_first. Found in pennylane.pauli.grouping.graph_colouring.recursive_largest_first.html",
      "source_file": "pennylane.pauli.grouping.graph_colouring.recursive_largest_first.html",
      "context": "                                         qml.pauli.grouping.graph_colouring.recursive_largest_first — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.is_qwc",
      "name": "qml.pauli.is_qwc",
      "type": "function",
      "description": "PennyLane API: pauli.is_qwc. Found in pennylane.pauli.is_qwc.html",
      "source_file": "pennylane.pauli.is_qwc.html",
      "context": "                                         qml.pauli.is_qwc — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.observables_to_binary_matrix",
      "name": "qml.pauli.observables_to_binary_matrix",
      "type": "function",
      "description": "PennyLane API: pauli.observables_to_binary_matrix. Found in pennylane.pauli.observables_to_binary_matrix.html",
      "source_file": "pennylane.pauli.observables_to_binary_matrix.html",
      "context": "                                         qml.pauli.observables_to_binary_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.optimize_measurements",
      "name": "qml.pauli.optimize_measurements",
      "type": "function",
      "description": "PennyLane API: pauli.optimize_measurements. Found in pennylane.pauli.optimize_measurements.html",
      "source_file": "pennylane.pauli.optimize_measurements.html",
      "context": "                                         qml.pauli.optimize_measurements — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.pauli_decompose",
      "name": "qml.pauli.pauli_decompose",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_decompose. Found in pennylane.pauli.pauli_decompose.html",
      "source_file": "pennylane.pauli.pauli_decompose.html",
      "context": "                                         qml.pauli.pauli_decompose — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.pauli.pauli_to_binary",
      "name": "qml.pauli.pauli_to_binary",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_to_binary. Found in pennylane.pauli.pauli_to_binary.html",
      "source_file": "pennylane.pauli.pauli_to_binary.html",
      "context": "                                         qml.pauli.pauli_to_binary — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.pauli_word_prefactor",
      "name": "qml.pauli.pauli_word_prefactor",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_word_prefactor. Found in pennylane.pauli.pauli_word_prefactor.html",
      "source_file": "pennylane.pauli.pauli_word_prefactor.html",
      "context": "                                         qml.pauli.pauli_word_prefactor — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.pauli_word_to_matrix",
      "name": "qml.pauli.pauli_word_to_matrix",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_word_to_matrix. Found in pennylane.pauli.pauli_word_to_matrix.html",
      "source_file": "pennylane.pauli.pauli_word_to_matrix.html",
      "context": "                                         qml.pauli.pauli_word_to_matrix — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.pauli.qwc_complement_adj_matrix",
      "name": "qml.pauli.qwc_complement_adj_matrix",
      "type": "function",
      "description": "PennyLane API: pauli.qwc_complement_adj_matrix. Found in pennylane.pauli.qwc_complement_adj_matrix.html",
      "source_file": "pennylane.pauli.qwc_complement_adj_matrix.html",
      "context": "                                         qml.pauli.qwc_complement_adj_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pauli.qwc_rotation",
      "name": "qml.pauli.qwc_rotation",
      "type": "function",
      "description": "PennyLane API: pauli.qwc_rotation. Found in pennylane.pauli.qwc_rotation.html",
      "source_file": "pennylane.pauli.qwc_rotation.html",
      "context": "                                         qml.pauli.qwc_rotation — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pytrees.PyTreeStructure",
      "name": "qml.pytrees.PyTreeStructure",
      "type": "function",
      "description": "PennyLane API: pytrees.PyTreeStructure. Found in pennylane.pytrees.PyTreeStructure.html",
      "source_file": "pennylane.pytrees.PyTreeStructure.html",
      "context": "                                         qml.pytrees.PyTreeStructure — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.pytrees.is_pytree",
      "name": "qml.pytrees.is_pytree",
      "type": "function",
      "description": "PennyLane API: pytrees.is_pytree. Found in pennylane.pytrees.flatten.html",
      "source_file": "pennylane.pytrees.flatten.html",
      "context": " qml.devices qml.exceptions qml.ftqc qml.measurements qml.pytrees Functions qml.pytrees.flatten qml.pytrees.is_pytree qml.pytrees.register_pytree qml.pytrees.unflatten   Classes Variables   qml.operat"
    },
    {
      "id": "qml.pytrees.register_pytree",
      "name": "qml.pytrees.register_pytree",
      "type": "function",
      "description": "PennyLane API: pytrees.register_pytree. Found in pennylane.pytrees.flatten.html",
      "source_file": "pennylane.pytrees.flatten.html",
      "context": "tions qml.ftqc qml.measurements qml.pytrees Functions qml.pytrees.flatten qml.pytrees.is_pytree qml.pytrees.register_pytree qml.pytrees.unflatten   Classes Variables   qml.operation qml.queuing qml.ta"
    },
    {
      "id": "qml.pytrees.leaf",
      "name": "qml.pytrees.leaf",
      "type": "function",
      "description": "PennyLane API: pytrees.leaf. Found in pennylane.pytrees.leaf.html",
      "source_file": "pennylane.pytrees.leaf.html",
      "context": "                                         qml.pytrees.leaf — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qaoa.cost.bit_driver",
      "name": "qml.qaoa.cost.bit_driver",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.bit_driver. Found in pennylane.qaoa.cost.bit_driver.html",
      "source_file": "pennylane.qaoa.cost.bit_driver.html",
      "context": "                                         qml.qaoa.cost.bit_driver — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cost.edge_driver",
      "name": "qml.qaoa.cost.edge_driver",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.edge_driver. Found in pennylane.qaoa.cost.edge_driver.html",
      "source_file": "pennylane.qaoa.cost.edge_driver.html",
      "context": "                                         qml.qaoa.cost.edge_driver — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cost.max_clique",
      "name": "qml.qaoa.cost.max_clique",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.max_clique. Found in pennylane.qaoa.cost.max_clique.html",
      "source_file": "pennylane.qaoa.cost.max_clique.html",
      "context": "                                         qml.qaoa.cost.max_clique — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cost.max_independent_set",
      "name": "qml.qaoa.cost.max_independent_set",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.max_independent_set. Found in pennylane.qaoa.cost.max_independent_set.html",
      "source_file": "pennylane.qaoa.cost.max_independent_set.html",
      "context": "                                         qml.qaoa.cost.max_independent_set — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cost.max_weight_cycle",
      "name": "qml.qaoa.cost.max_weight_cycle",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.max_weight_cycle. Found in pennylane.qaoa.cost.max_weight_cycle.html",
      "source_file": "pennylane.qaoa.cost.max_weight_cycle.html",
      "context": "                                         qml.qaoa.cost.max_weight_cycle — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cost.maxcut",
      "name": "qml.qaoa.cost.maxcut",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.maxcut. Found in pennylane.qaoa.cost.maxcut.html",
      "source_file": "pennylane.qaoa.cost.maxcut.html",
      "context": "                                         qml.qaoa.cost.maxcut — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cost.min_vertex_cover",
      "name": "qml.qaoa.cost.min_vertex_cover",
      "type": "function",
      "description": "PennyLane API: qaoa.cost.min_vertex_cover. Found in pennylane.qaoa.cost.min_vertex_cover.html",
      "source_file": "pennylane.qaoa.cost.min_vertex_cover.html",
      "context": "                                         qml.qaoa.cost.min_vertex_cover — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cycle.cycle_mixer",
      "name": "qml.qaoa.cycle.cycle_mixer",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle.cycle_mixer. Found in pennylane.qaoa.cycle.cycle_mixer.html",
      "source_file": "pennylane.qaoa.cycle.cycle_mixer.html",
      "context": "                                         qml.qaoa.cycle.cycle_mixer — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cycle.edges_to_wires",
      "name": "qml.qaoa.cycle.edges_to_wires",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle.edges_to_wires. Found in pennylane.qaoa.cycle.edges_to_wires.html",
      "source_file": "pennylane.qaoa.cycle.edges_to_wires.html",
      "context": "                                         qml.qaoa.cycle.edges_to_wires — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qaoa.cycle.loss_hamiltonian",
      "name": "qml.qaoa.cycle.loss_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle.loss_hamiltonian. Found in pennylane.qaoa.cycle.loss_hamiltonian.html",
      "source_file": "pennylane.qaoa.cycle.loss_hamiltonian.html",
      "context": "                                         qml.qaoa.cycle.loss_hamiltonian — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cycle.net_flow_constraint",
      "name": "qml.qaoa.cycle.net_flow_constraint",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle.net_flow_constraint. Found in pennylane.qaoa.cycle.net_flow_constraint.html",
      "source_file": "pennylane.qaoa.cycle.net_flow_constraint.html",
      "context": "                                         qml.qaoa.cycle.net_flow_constraint — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cycle.out_flow_constraint",
      "name": "qml.qaoa.cycle.out_flow_constraint",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle.out_flow_constraint. Found in pennylane.qaoa.cycle.out_flow_constraint.html",
      "source_file": "pennylane.qaoa.cycle.out_flow_constraint.html",
      "context": "                                         qml.qaoa.cycle.out_flow_constraint — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.cycle.wires_to_edges",
      "name": "qml.qaoa.cycle.wires_to_edges",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle.wires_to_edges. Found in pennylane.qaoa.cycle.wires_to_edges.html",
      "source_file": "pennylane.qaoa.cycle.wires_to_edges.html",
      "context": "                                         qml.qaoa.cycle.wires_to_edges — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qaoa.layers.cost_layer",
      "name": "qml.qaoa.layers.cost_layer",
      "type": "function",
      "description": "PennyLane API: qaoa.layers.cost_layer. Found in pennylane.qaoa.layers.cost_layer.html",
      "source_file": "pennylane.qaoa.layers.cost_layer.html",
      "context": "                                         qml.qaoa.layers.cost_layer — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.layers.mixer_layer",
      "name": "qml.qaoa.layers.mixer_layer",
      "type": "function",
      "description": "PennyLane API: qaoa.layers.mixer_layer. Found in pennylane.qaoa.layers.mixer_layer.html",
      "source_file": "pennylane.qaoa.layers.mixer_layer.html",
      "context": "                                         qml.qaoa.layers.mixer_layer — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.mixers.bit_flip_mixer",
      "name": "qml.qaoa.mixers.bit_flip_mixer",
      "type": "function",
      "description": "PennyLane API: qaoa.mixers.bit_flip_mixer. Found in pennylane.qaoa.mixers.bit_flip_mixer.html",
      "source_file": "pennylane.qaoa.mixers.bit_flip_mixer.html",
      "context": "                                         qml.qaoa.mixers.bit_flip_mixer — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.mixers.x_mixer",
      "name": "qml.qaoa.mixers.x_mixer",
      "type": "function",
      "description": "PennyLane API: qaoa.mixers.x_mixer. Found in pennylane.qaoa.mixers.x_mixer.html",
      "source_file": "pennylane.qaoa.mixers.x_mixer.html",
      "context": "                                         qml.qaoa.mixers.x_mixer — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qaoa.mixers.xy_mixer",
      "name": "qml.qaoa.mixers.xy_mixer",
      "type": "function",
      "description": "PennyLane API: qaoa.mixers.xy_mixer. Found in pennylane.qaoa.mixers.xy_mixer.html",
      "source_file": "pennylane.qaoa.mixers.xy_mixer.html",
      "context": "                                         qml.qaoa.mixers.xy_mixer — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.BasisFunction",
      "name": "qml.qchem.BasisFunction",
      "type": "function",
      "description": "PennyLane API: qchem.BasisFunction. Found in pennylane.qchem.BasisFunction.html",
      "source_file": "pennylane.qchem.BasisFunction.html",
      "context": "                                         qml.qchem.BasisFunction — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.atom_basis_data",
      "name": "qml.qchem.atom_basis_data",
      "type": "function",
      "description": "PennyLane API: qchem.atom_basis_data. Found in pennylane.qchem.atom_basis_data.html",
      "source_file": "pennylane.qchem.atom_basis_data.html",
      "context": "                                         qml.qchem.atom_basis_data — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.attraction_integral",
      "name": "qml.qchem.attraction_integral",
      "type": "function",
      "description": "PennyLane API: qchem.attraction_integral. Found in pennylane.qchem.attraction_integral.html",
      "source_file": "pennylane.qchem.attraction_integral.html",
      "context": "                                         qml.qchem.attraction_integral — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.attraction_matrix",
      "name": "qml.qchem.attraction_matrix",
      "type": "function",
      "description": "PennyLane API: qchem.attraction_matrix. Found in pennylane.qchem.attraction_matrix.html",
      "source_file": "pennylane.qchem.attraction_matrix.html",
      "context": "                                         qml.qchem.attraction_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.basis_rotation",
      "name": "qml.qchem.basis_rotation",
      "type": "function",
      "description": "PennyLane API: qchem.basis_rotation. Found in pennylane.qchem.basis_rotation.html",
      "source_file": "pennylane.qchem.basis_rotation.html",
      "context": "                                         qml.qchem.basis_rotation — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.christiansen_dipole",
      "name": "qml.qchem.christiansen_dipole",
      "type": "function",
      "description": "PennyLane API: qchem.christiansen_dipole. Found in pennylane.qchem.christiansen_dipole.html",
      "source_file": "pennylane.qchem.christiansen_dipole.html",
      "context": "                                         qml.qchem.christiansen_dipole — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.christiansen_hamiltonian",
      "name": "qml.qchem.christiansen_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.christiansen_hamiltonian. Found in pennylane.qchem.christiansen_hamiltonian.html",
      "source_file": "pennylane.qchem.christiansen_hamiltonian.html",
      "context": "                                         qml.qchem.christiansen_hamiltonian — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.christiansen_integrals",
      "name": "qml.qchem.christiansen_integrals",
      "type": "function",
      "description": "PennyLane API: qchem.christiansen_integrals. Found in pennylane.qchem.christiansen_integrals.html",
      "source_file": "pennylane.qchem.christiansen_integrals.html",
      "context": "                                         qml.qchem.christiansen_integrals — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.christiansen_integrals_dipole",
      "name": "qml.qchem.christiansen_integrals_dipole",
      "type": "function",
      "description": "PennyLane API: qchem.christiansen_integrals_dipole. Found in pennylane.qchem.christiansen_integrals_dipole.html",
      "source_file": "pennylane.qchem.christiansen_integrals_dipole.html",
      "context": "                                         qml.qchem.christiansen_integrals_dipole — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.clifford",
      "name": "qml.qchem.clifford",
      "type": "function",
      "description": "PennyLane API: qchem.clifford. Found in pennylane.qchem.clifford.html",
      "source_file": "pennylane.qchem.clifford.html",
      "context": "                                         qml.qchem.clifford — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.contracted_norm",
      "name": "qml.qchem.contracted_norm",
      "type": "function",
      "description": "PennyLane API: qchem.contracted_norm. Found in pennylane.qchem.contracted_norm.html",
      "source_file": "pennylane.qchem.contracted_norm.html",
      "context": "                                         qml.qchem.contracted_norm — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.core_matrix",
      "name": "qml.qchem.core_matrix",
      "type": "function",
      "description": "PennyLane API: qchem.core_matrix. Found in pennylane.qchem.core_matrix.html",
      "source_file": "pennylane.qchem.core_matrix.html",
      "context": "                                         qml.qchem.core_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.decompose",
      "name": "qml.qchem.decompose",
      "type": "function",
      "description": "PennyLane API: qchem.decompose. Found in pennylane.qchem.decompose.html",
      "source_file": "pennylane.qchem.decompose.html",
      "context": "                                         qml.qchem.decompose — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.dipole_integrals",
      "name": "qml.qchem.dipole_integrals",
      "type": "function",
      "description": "PennyLane API: qchem.dipole_integrals. Found in pennylane.qchem.dipole_integrals.html",
      "source_file": "pennylane.qchem.dipole_integrals.html",
      "context": "                                         qml.qchem.dipole_integrals — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.electron_repulsion",
      "name": "qml.qchem.electron_repulsion",
      "type": "function",
      "description": "PennyLane API: qchem.electron_repulsion. Found in pennylane.qchem.electron_repulsion.html",
      "source_file": "pennylane.qchem.electron_repulsion.html",
      "context": "                                         qml.qchem.electron_repulsion — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.expansion",
      "name": "qml.qchem.expansion",
      "type": "function",
      "description": "PennyLane API: qchem.expansion. Found in pennylane.qchem.expansion.html",
      "source_file": "pennylane.qchem.expansion.html",
      "context": "                                         qml.qchem.expansion — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.fermionic_dipole",
      "name": "qml.qchem.fermionic_dipole",
      "type": "function",
      "description": "PennyLane API: qchem.fermionic_dipole. Found in pennylane.qchem.fermionic_dipole.html",
      "source_file": "pennylane.qchem.fermionic_dipole.html",
      "context": "                                         qml.qchem.fermionic_dipole — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.fermionic_hamiltonian",
      "name": "qml.qchem.fermionic_hamiltonian",
      "type": "function",
      "description": "PennyLane API: qchem.fermionic_hamiltonian. Found in pennylane.qchem.fermionic_hamiltonian.html",
      "source_file": "pennylane.qchem.fermionic_hamiltonian.html",
      "context": "                                         qml.qchem.fermionic_hamiltonian — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.from_openfermion",
      "name": "qml.qchem.from_openfermion",
      "type": "function",
      "description": "PennyLane API: qchem.from_openfermion. Found in pennylane.qchem.from_openfermion.html",
      "source_file": "pennylane.qchem.from_openfermion.html",
      "context": "                                         qml.qchem.from_openfermion — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.gaussian_kinetic",
      "name": "qml.qchem.gaussian_kinetic",
      "type": "function",
      "description": "PennyLane API: qchem.gaussian_kinetic. Found in pennylane.qchem.gaussian_kinetic.html",
      "source_file": "pennylane.qchem.gaussian_kinetic.html",
      "context": "                                         qml.qchem.gaussian_kinetic — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.gaussian_moment",
      "name": "qml.qchem.gaussian_moment",
      "type": "function",
      "description": "PennyLane API: qchem.gaussian_moment. Found in pennylane.qchem.gaussian_moment.html",
      "source_file": "pennylane.qchem.gaussian_moment.html",
      "context": "                                         qml.qchem.gaussian_moment — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.gaussian_overlap",
      "name": "qml.qchem.gaussian_overlap",
      "type": "function",
      "description": "PennyLane API: qchem.gaussian_overlap. Found in pennylane.qchem.gaussian_overlap.html",
      "source_file": "pennylane.qchem.gaussian_overlap.html",
      "context": "                                         qml.qchem.gaussian_overlap — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.hermite_moment",
      "name": "qml.qchem.hermite_moment",
      "type": "function",
      "description": "PennyLane API: qchem.hermite_moment. Found in pennylane.qchem.hermite_moment.html",
      "source_file": "pennylane.qchem.hermite_moment.html",
      "context": "                                         qml.qchem.hermite_moment — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.hf_energy",
      "name": "qml.qchem.hf_energy",
      "type": "function",
      "description": "PennyLane API: qchem.hf_energy. Found in pennylane.qchem.hf_energy.html",
      "source_file": "pennylane.qchem.hf_energy.html",
      "context": "                                         qml.qchem.hf_energy — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.kinetic_integral",
      "name": "qml.qchem.kinetic_integral",
      "type": "function",
      "description": "PennyLane API: qchem.kinetic_integral. Found in pennylane.qchem.kinetic_integral.html",
      "source_file": "pennylane.qchem.kinetic_integral.html",
      "context": "                                         qml.qchem.kinetic_integral — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.kinetic_matrix",
      "name": "qml.qchem.kinetic_matrix",
      "type": "function",
      "description": "PennyLane API: qchem.kinetic_matrix. Found in pennylane.qchem.kinetic_matrix.html",
      "source_file": "pennylane.qchem.kinetic_matrix.html",
      "context": "                                         qml.qchem.kinetic_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.mol_basis_data",
      "name": "qml.qchem.mol_basis_data",
      "type": "function",
      "description": "PennyLane API: qchem.mol_basis_data. Found in pennylane.qchem.mol_basis_data.html",
      "source_file": "pennylane.qchem.mol_basis_data.html",
      "context": "                                         qml.qchem.mol_basis_data — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.mol_data",
      "name": "qml.qchem.mol_data",
      "type": "function",
      "description": "PennyLane API: qchem.mol_data. Found in pennylane.qchem.mol_data.html",
      "source_file": "pennylane.qchem.mol_data.html",
      "context": "                                         qml.qchem.mol_data — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.mol_density_matrix",
      "name": "qml.qchem.mol_density_matrix",
      "type": "function",
      "description": "PennyLane API: qchem.mol_density_matrix. Found in pennylane.qchem.mol_density_matrix.html",
      "source_file": "pennylane.qchem.mol_density_matrix.html",
      "context": "                                         qml.qchem.mol_density_matrix — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.moment_integral",
      "name": "qml.qchem.moment_integral",
      "type": "function",
      "description": "PennyLane API: qchem.moment_integral. Found in pennylane.qchem.moment_integral.html",
      "source_file": "pennylane.qchem.moment_integral.html",
      "context": "                                         qml.qchem.moment_integral — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.moment_matrix",
      "name": "qml.qchem.moment_matrix",
      "type": "function",
      "description": "PennyLane API: qchem.moment_matrix. Found in pennylane.qchem.moment_matrix.html",
      "source_file": "pennylane.qchem.moment_matrix.html",
      "context": "                                         qml.qchem.moment_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.nuclear_attraction",
      "name": "qml.qchem.nuclear_attraction",
      "type": "function",
      "description": "PennyLane API: qchem.nuclear_attraction. Found in pennylane.qchem.nuclear_attraction.html",
      "source_file": "pennylane.qchem.nuclear_attraction.html",
      "context": "                                         qml.qchem.nuclear_attraction — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.nuclear_energy",
      "name": "qml.qchem.nuclear_energy",
      "type": "function",
      "description": "PennyLane API: qchem.nuclear_energy. Found in pennylane.qchem.nuclear_energy.html",
      "source_file": "pennylane.qchem.nuclear_energy.html",
      "context": "                                         qml.qchem.nuclear_energy — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.observable",
      "name": "qml.qchem.observable",
      "type": "function",
      "description": "PennyLane API: qchem.observable. Found in pennylane.qchem.observable.html",
      "source_file": "pennylane.qchem.observable.html",
      "context": "                                         qml.qchem.observable — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.one_particle",
      "name": "qml.qchem.one_particle",
      "type": "function",
      "description": "PennyLane API: qchem.one_particle. Found in pennylane.qchem.one_particle.html",
      "source_file": "pennylane.qchem.one_particle.html",
      "context": "                                         qml.qchem.one_particle — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.overlap_integral",
      "name": "qml.qchem.overlap_integral",
      "type": "function",
      "description": "PennyLane API: qchem.overlap_integral. Found in pennylane.qchem.overlap_integral.html",
      "source_file": "pennylane.qchem.overlap_integral.html",
      "context": "                                         qml.qchem.overlap_integral — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.overlap_matrix",
      "name": "qml.qchem.overlap_matrix",
      "type": "function",
      "description": "PennyLane API: qchem.overlap_matrix. Found in pennylane.qchem.overlap_matrix.html",
      "source_file": "pennylane.qchem.overlap_matrix.html",
      "context": "                                         qml.qchem.overlap_matrix — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.particle_number",
      "name": "qml.qchem.particle_number",
      "type": "function",
      "description": "PennyLane API: qchem.particle_number. Found in pennylane.qchem.particle_number.html",
      "source_file": "pennylane.qchem.particle_number.html",
      "context": "                                         qml.qchem.particle_number — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.primitive_norm",
      "name": "qml.qchem.primitive_norm",
      "type": "function",
      "description": "PennyLane API: qchem.primitive_norm. Found in pennylane.qchem.primitive_norm.html",
      "source_file": "pennylane.qchem.primitive_norm.html",
      "context": "                                         qml.qchem.primitive_norm — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.qubit_observable",
      "name": "qml.qchem.qubit_observable",
      "type": "function",
      "description": "PennyLane API: qchem.qubit_observable. Found in pennylane.qchem.qubit_observable.html",
      "source_file": "pennylane.qchem.qubit_observable.html",
      "context": "                                         qml.qchem.qubit_observable — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.read_structure",
      "name": "qml.qchem.read_structure",
      "type": "function",
      "description": "PennyLane API: qchem.read_structure. Found in pennylane.qchem.read_structure.html",
      "source_file": "pennylane.qchem.read_structure.html",
      "context": "                                         qml.qchem.read_structure — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.repulsion_integral",
      "name": "qml.qchem.repulsion_integral",
      "type": "function",
      "description": "PennyLane API: qchem.repulsion_integral. Found in pennylane.qchem.repulsion_integral.html",
      "source_file": "pennylane.qchem.repulsion_integral.html",
      "context": "                                         qml.qchem.repulsion_integral — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.repulsion_tensor",
      "name": "qml.qchem.repulsion_tensor",
      "type": "function",
      "description": "PennyLane API: qchem.repulsion_tensor. Found in pennylane.qchem.repulsion_tensor.html",
      "source_file": "pennylane.qchem.repulsion_tensor.html",
      "context": "                                         qml.qchem.repulsion_tensor — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.spin2",
      "name": "qml.qchem.spin2",
      "type": "function",
      "description": "PennyLane API: qchem.spin2. Found in pennylane.qchem.spin2.html",
      "source_file": "pennylane.qchem.spin2.html",
      "context": "                                         qml.qchem.spin2 — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.spinz",
      "name": "qml.qchem.spinz",
      "type": "function",
      "description": "PennyLane API: qchem.spinz. Found in pennylane.qchem.spinz.html",
      "source_file": "pennylane.qchem.spinz.html",
      "context": "                                         qml.qchem.spinz — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.symmetry_shift",
      "name": "qml.qchem.symmetry_shift",
      "type": "function",
      "description": "PennyLane API: qchem.symmetry_shift. Found in pennylane.qchem.symmetry_shift.html",
      "source_file": "pennylane.qchem.symmetry_shift.html",
      "context": "                                         qml.qchem.symmetry_shift — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.taper_hf",
      "name": "qml.qchem.taper_hf",
      "type": "function",
      "description": "PennyLane API: qchem.taper_hf. Found in pennylane.qchem.taper_hf.html",
      "source_file": "pennylane.qchem.taper_hf.html",
      "context": "                                         qml.qchem.taper_hf — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.taper_operation",
      "name": "qml.qchem.taper_operation",
      "type": "function",
      "description": "PennyLane API: qchem.taper_operation. Found in pennylane.qchem.taper_operation.html",
      "source_file": "pennylane.qchem.taper_operation.html",
      "context": "                                         qml.qchem.taper_operation — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.qchem.to_openfermion",
      "name": "qml.qchem.to_openfermion",
      "type": "function",
      "description": "PennyLane API: qchem.to_openfermion. Found in pennylane.qchem.to_openfermion.html",
      "source_file": "pennylane.qchem.to_openfermion.html",
      "context": "                                         qml.qchem.to_openfermion — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.qchem.two_particle",
      "name": "qml.qchem.two_particle",
      "type": "function",
      "description": "PennyLane API: qchem.two_particle. Found in pennylane.qchem.two_particle.html",
      "source_file": "pennylane.qchem.two_particle.html",
      "context": "                                         qml.qchem.two_particle — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.queuing.QueuingManager",
      "name": "qml.queuing.QueuingManager",
      "type": "function",
      "description": "PennyLane API: queuing.QueuingManager. Found in pennylane.queuing.QueuingManager.html",
      "source_file": "pennylane.queuing.QueuingManager.html",
      "context": "                                         qml.queuing.QueuingManager — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.queuing.WrappedObj",
      "name": "qml.queuing.WrappedObj",
      "type": "function",
      "description": "PennyLane API: queuing.WrappedObj. Found in pennylane.queuing.WrappedObj.html",
      "source_file": "pennylane.queuing.WrappedObj.html",
      "context": "                                         qml.queuing.WrappedObj — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.queuing.apply",
      "name": "qml.queuing.apply",
      "type": "function",
      "description": "PennyLane API: queuing.apply. Found in pennylane.queuing.apply.html",
      "source_file": "pennylane.queuing.apply.html",
      "context": "                                         qml.queuing.apply — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.resource.AlgorithmicError",
      "name": "qml.resource.AlgorithmicError",
      "type": "function",
      "description": "PennyLane API: resource.AlgorithmicError. Found in pennylane.resource.AlgorithmicError.html",
      "source_file": "pennylane.resource.AlgorithmicError.html",
      "context": "                                         qml.resource.AlgorithmicError — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.resource.SpecsResources",
      "name": "qml.resource.SpecsResources",
      "type": "function",
      "description": "PennyLane API: resource.SpecsResources. Found in pennylane.resource.CircuitSpecs.html",
      "source_file": "pennylane.resource.CircuitSpecs.html",
      "context": "it Specifications (specs) Circuit Specification Classes and Utilities qml.resource.CircuitSpecs qml.resource.SpecsResources qml.resource.resources_from_tape   Error Tracking Resource Classes Tracking "
    },
    {
      "id": "qml.resource.CircuitSpecs",
      "name": "qml.resource.CircuitSpecs",
      "type": "function",
      "description": "PennyLane API: resource.CircuitSpecs. Found in pennylane.resource.CircuitSpecs.html",
      "source_file": "pennylane.resource.CircuitSpecs.html",
      "context": "                                         qml.resource.CircuitSpecs — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.resource.resources_from_tape",
      "name": "qml.resource.resources_from_tape",
      "type": "function",
      "description": "PennyLane API: resource.resources_from_tape. Found in pennylane.resource.CircuitSpecs.html",
      "source_file": "pennylane.resource.CircuitSpecs.html",
      "context": "rcuit Specification Classes and Utilities qml.resource.CircuitSpecs qml.resource.SpecsResources qml.resource.resources_from_tape   Error Tracking Resource Classes Tracking Resources for Custom Operati"
    },
    {
      "id": "qml.resource.Resources",
      "name": "qml.resource.Resources",
      "type": "function",
      "description": "PennyLane API: resource.Resources. Found in pennylane.resource.Resources.html",
      "source_file": "pennylane.resource.Resources.html",
      "context": "                                         qml.resource.Resources — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.resource.ResourcesOperation",
      "name": "qml.resource.ResourcesOperation",
      "type": "function",
      "description": "PennyLane API: resource.ResourcesOperation. Found in pennylane.resource.Resources.html",
      "source_file": "pennylane.resource.Resources.html",
      "context": "cuit Specification Classes and Utilities Error Tracking Resource Classes qml.resource.Resources qml.resource.ResourcesOperation Resource Functions   Tracking Resources for Custom Operations   qml.shad"
    },
    {
      "id": "qml.tape.OperationRecorder",
      "name": "qml.tape.OperationRecorder",
      "type": "function",
      "description": "PennyLane API: tape.OperationRecorder. Found in pennylane.tape.OperationRecorder.html",
      "source_file": "pennylane.tape.OperationRecorder.html",
      "context": "                                         qml.tape.OperationRecorder — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.tape.QuantumScriptOrBatch",
      "name": "qml.tape.QuantumScriptOrBatch",
      "type": "function",
      "description": "PennyLane API: tape.QuantumScriptOrBatch. Found in pennylane.tape.QuantumScriptOrBatch.html",
      "source_file": "pennylane.tape.QuantumScriptOrBatch.html",
      "context": "                                         qml.tape.QuantumScriptOrBatch — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.CommutationDAG",
      "name": "qml.transforms.CommutationDAG",
      "type": "function",
      "description": "PennyLane API: transforms.CommutationDAG. Found in pennylane.transforms.CommutationDAG.html",
      "source_file": "pennylane.transforms.CommutationDAG.html",
      "context": "                                         qml.transforms.CommutationDAG — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.commutation_dag.",
      "name": "qml.transforms.commutation_dag.",
      "type": "function",
      "description": "PennyLane API: transforms.commutation_dag.. Found in pennylane.transforms.CommutationDAG.html",
      "source_file": "pennylane.transforms.CommutationDAG.html",
      "context": "d set up all nodes attributes. The construction of the DAG should be used through the transform qml.transforms.commutation_dag.  Parameters: tape (.QuantumTape) – PennyLane quantum tape representing a"
    },
    {
      "id": "qml.transforms.CommutationDAGNode",
      "name": "qml.transforms.CommutationDAGNode",
      "type": "function",
      "description": "PennyLane API: transforms.CommutationDAGNode. Found in pennylane.transforms.CommutationDAGNode.html",
      "source_file": "pennylane.transforms.CommutationDAGNode.html",
      "context": "                                         qml.transforms.CommutationDAGNode — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.commute_ppr",
      "name": "qml.transforms.commute_ppr",
      "type": "function",
      "description": "PennyLane API: transforms.commute_ppr. Found in pennylane.transforms.commute_ppr.html",
      "source_file": "pennylane.transforms.commute_ppr.html",
      "context": "                                         qml.transforms.commute_ppr — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.ops.__all__.",
      "name": "qml.ops.__all__.",
      "type": "function",
      "description": "PennyLane API: ops.__all__.. Found in pennylane.transforms.decompose.html",
      "source_file": "pennylane.transforms.decompose.html",
      "context": "d decomposition system is enabled). If None, the gate set is considered to be all operations in qml.ops.__all__.  See quantum operators for this list. stopping_condition (Callable, optional) – a funct"
    },
    {
      "id": "qml.Identity.",
      "name": "qml.Identity.",
      "type": "class",
      "description": "PennyLane API: Identity.. Found in pennylane.transforms.diagonalize_measurements.html",
      "source_file": "pennylane.transforms.diagonalize_measurements.html",
      "context": "upported base observable classes. Allowed observables are qml.X, qml.Y, qml.Z, qml.Hadamard and qml.Identity. Z and Identity are always treated as supported, regardless of input. If no list is provide"
    },
    {
      "id": "qml.transforms.diagonalize_measurements",
      "name": "qml.transforms.diagonalize_measurements",
      "type": "function",
      "description": "PennyLane API: transforms.diagonalize_measurements. Found in pennylane.transforms.diagonalize_measurements.html",
      "source_file": "pennylane.transforms.diagonalize_measurements.html",
      "context": "                                         qml.transforms.diagonalize_measurements — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.merge_ppr_ppm",
      "name": "qml.transforms.merge_ppr_ppm",
      "type": "function",
      "description": "PennyLane API: transforms.merge_ppr_ppm. Found in pennylane.transforms.merge_ppr_ppm.html",
      "source_file": "pennylane.transforms.merge_ppr_ppm.html",
      "context": "                                         qml.transforms.merge_ppr_ppm — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transforms.parity_matrix",
      "name": "qml.transforms.parity_matrix",
      "type": "function",
      "description": "PennyLane API: transforms.parity_matrix. Found in pennylane.transforms.parity_matrix.html",
      "source_file": "pennylane.transforms.parity_matrix.html",
      "context": "                                         qml.transforms.parity_matrix — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transforms.pattern_matching",
      "name": "qml.transforms.pattern_matching",
      "type": "function",
      "description": "PennyLane API: transforms.pattern_matching. Found in pennylane.transforms.pattern_matching.html",
      "source_file": "pennylane.transforms.pattern_matching.html",
      "context": "                                         qml.transforms.pattern_matching — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.pattern_matching_optimization",
      "name": "qml.transforms.pattern_matching_optimization",
      "type": "function",
      "description": "PennyLane API: transforms.pattern_matching_optimization. Found in pennylane.transforms.pattern_matching_optimization.html",
      "source_file": "pennylane.transforms.pattern_matching_optimization.html",
      "context": "                                         qml.transforms.pattern_matching_optimization — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.phase_polynomial",
      "name": "qml.transforms.phase_polynomial",
      "type": "function",
      "description": "PennyLane API: transforms.phase_polynomial. Found in pennylane.transforms.phase_polynomial.html",
      "source_file": "pennylane.transforms.phase_polynomial.html",
      "context": "                                         qml.transforms.phase_polynomial — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transforms.ppm_compilation",
      "name": "qml.transforms.ppm_compilation",
      "type": "function",
      "description": "PennyLane API: transforms.ppm_compilation. Found in pennylane.transforms.ppm_compilation.html",
      "source_file": "pennylane.transforms.ppm_compilation.html",
      "context": "                                         qml.transforms.ppm_compilation — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.ppr_to_ppm",
      "name": "qml.transforms.ppr_to_ppm",
      "type": "function",
      "description": "PennyLane API: transforms.ppr_to_ppm. Found in pennylane.transforms.ppr_to_ppm.html",
      "source_file": "pennylane.transforms.ppr_to_ppm.html",
      "context": "                                         qml.transforms.ppr_to_ppm — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transforms.reduce_t_depth",
      "name": "qml.transforms.reduce_t_depth",
      "type": "function",
      "description": "PennyLane API: transforms.reduce_t_depth. Found in pennylane.transforms.reduce_t_depth.html",
      "source_file": "pennylane.transforms.reduce_t_depth.html",
      "context": "                                         qml.transforms.reduce_t_depth — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transforms.rz_phase_gradient",
      "name": "qml.transforms.rz_phase_gradient",
      "type": "function",
      "description": "PennyLane API: transforms.rz_phase_gradient. Found in pennylane.transforms.rz_phase_gradient.html",
      "source_file": "pennylane.transforms.rz_phase_gradient.html",
      "context": "                                         qml.transforms.rz_phase_gradient — PennyLane 0.45.0-dev3 documentation                          About     Research                  "
    },
    {
      "id": "qml.transforms.to_ppr",
      "name": "qml.transforms.to_ppr",
      "type": "function",
      "description": "PennyLane API: transforms.to_ppr. Found in pennylane.transforms.to_ppr.html",
      "source_file": "pennylane.transforms.to_ppr.html",
      "context": "                                         qml.transforms.to_ppr — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.zx.optimize_t_count",
      "name": "qml.transforms.zx.optimize_t_count",
      "type": "function",
      "description": "PennyLane API: transforms.zx.optimize_t_count. Found in pennylane.transforms.zx.optimize_t_count.html",
      "source_file": "pennylane.transforms.zx.optimize_t_count.html",
      "context": "                                         qml.transforms.zx.optimize_t_count — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.zx.push_hadamards",
      "name": "qml.transforms.zx.push_hadamards",
      "type": "function",
      "description": "PennyLane API: transforms.zx.push_hadamards. Found in pennylane.transforms.zx.push_hadamards.html",
      "source_file": "pennylane.transforms.zx.push_hadamards.html",
      "context": "                                         qml.transforms.zx.push_hadamards — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.zx.reduce_non_clifford",
      "name": "qml.transforms.zx.reduce_non_clifford",
      "type": "function",
      "description": "PennyLane API: transforms.zx.reduce_non_clifford. Found in pennylane.transforms.zx.reduce_non_clifford.html",
      "source_file": "pennylane.transforms.zx.reduce_non_clifford.html",
      "context": "                                         qml.transforms.zx.reduce_non_clifford — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.transforms.zx.todd",
      "name": "qml.transforms.zx.todd",
      "type": "function",
      "description": "PennyLane API: transforms.zx.todd. Found in pennylane.transforms.zx.todd.html",
      "source_file": "pennylane.transforms.zx.todd.html",
      "context": "                                         qml.transforms.zx.todd — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.wires.DynamicWire",
      "name": "qml.wires.DynamicWire",
      "type": "function",
      "description": "PennyLane API: wires.DynamicWire. Found in pennylane.wires.DynamicWire.html",
      "source_file": "pennylane.wires.DynamicWire.html",
      "context": "                                         qml.wires.DynamicWire — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.workflow.jacobian_products.JacobianProductCalculator",
      "name": "qml.workflow.jacobian_products.JacobianProductCalculator",
      "type": "function",
      "description": "PennyLane API: workflow.jacobian_products.JacobianProductCalculator. Found in pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "source_file": "pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "context": " qml.tape qml.wires qml.workflow Execution functions and utilities Jacobian Product Calculation qml.workflow.jacobian_products.JacobianProductCalculator qml.workflow.jacobian_products.TransformJacobia"
    },
    {
      "id": "qml.workflow.jacobian_products.DeviceDerivatives",
      "name": "qml.workflow.jacobian_products.DeviceDerivatives",
      "type": "function",
      "description": "PennyLane API: workflow.jacobian_products.DeviceDerivatives. Found in pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "source_file": "pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "context": "                                         qml.workflow.jacobian_products.DeviceDerivatives — PennyLane 0.45.0-dev3 documentation                         About     Research                  F"
    },
    {
      "id": "qml.workflow.jacobian_products.TransformJacobianProducts",
      "name": "qml.workflow.jacobian_products.TransformJacobianProducts",
      "type": "function",
      "description": "PennyLane API: workflow.jacobian_products.TransformJacobianProducts. Found in pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "source_file": "pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "context": "utilities Jacobian Product Calculation qml.workflow.jacobian_products.JacobianProductCalculator qml.workflow.jacobian_products.TransformJacobianProducts qml.workflow.jacobian_products.DeviceDerivative"
    },
    {
      "id": "qml.devices.Device.compute_derivatives.",
      "name": "qml.devices.Device.compute_derivatives.",
      "type": "function",
      "description": "PennyLane API: devices.Device.compute_derivatives.. Found in pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "source_file": "pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "context": "uctCalculator Calculate jacobian products via a device provided jacobian.  This class relies on qml.devices.Device.compute_derivatives.  Parameters:  device (pennylane.devices.Device) – the device for"
    },
    {
      "id": "qml.workflow.jacobian_products.DeviceJacobianProducts",
      "name": "qml.workflow.jacobian_products.DeviceJacobianProducts",
      "type": "function",
      "description": "PennyLane API: workflow.jacobian_products.DeviceJacobianProducts. Found in pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "source_file": "pennylane.workflow.jacobian_products.DeviceDerivatives.html",
      "context": "ow.jacobian_products.TransformJacobianProducts qml.workflow.jacobian_products.DeviceDerivatives qml.workflow.jacobian_products.DeviceJacobianProducts   Return Type Specification           Navigation  "
    },
    {
      "id": "qml.capture.enabled.",
      "name": "qml.capture.enabled.",
      "type": "function",
      "description": "PennyLane API: capture.enabled.. Found in qml_capture.html",
      "source_file": "qml_capture.html",
      "context": "ure.disable. Whether or not the capturing mechanism is currently being used can be queried with qml.capture.enabled. By default, the mechanism is disabled: >>> import pennylane as qml >>> qml.capture."
    },
    {
      "id": "qml.capture.disable.",
      "name": "qml.capture.disable.",
      "type": "function",
      "description": "PennyLane API: capture.disable.. Found in qml_capture.html",
      "source_file": "qml_capture.html",
      "context": "activate the new PennyLane program capturing mechanism, use the switches qml.capture.enable and qml.capture.disable. Whether or not the capturing mechanism is currently being used can be queried with "
    },
    {
      "id": "qml.draw_mpl.",
      "name": "qml.draw_mpl.",
      "type": "function",
      "description": "PennyLane API: draw_mpl.. Found in qml_drawer.html",
      "source_file": "qml_drawer.html",
      "context": "ovides two functions for modifying the style of matplotlib graphics, such as those generated by qml.draw_mpl. The qml.drawer.use_style function modifies the plt.rcParams global styling variable.  Any "
    },
    {
      "id": "qml.gradients.param_shift.",
      "name": "qml.gradients.param_shift.",
      "type": "function",
      "description": "PennyLane API: gradients.param_shift.. Found in qml_gradients.html",
      "source_file": "qml_gradients.html",
      "context": "r derivatives. Also, passing diff_method=\"parameter-shift\" is equivalent to passing diff_method=qml.gradients.param_shift.   Transforming tapes¶ Gradient transforms can be applied to low-level Quantum"
    },
    {
      "id": "qml.numpy.stack",
      "name": "qml.numpy.stack",
      "type": "function",
      "description": "PennyLane API: numpy.stack. Found in qml_gradients.html",
      "source_file": "qml_gradients.html",
      "context": " -0.18884787, -0.28818254], requires_grad=True) >>> def stacked_output(weights): ...     return qml.numpy.stack(qml.gradients.param_shift(circuit)(weights)) >>> qml.jacobian(stacked_output)(weights)  "
    },
    {
      "id": "qml.capture.autograph.autograph_source",
      "name": "qml.capture.autograph.autograph_source",
      "type": "function",
      "description": "PennyLane API: capture.autograph.autograph_source. Found in autograph.html",
      "source_file": "autograph.html",
      "context": "ge(1, n + 1): ...         x = x + 1 / k ...     return x >>> plxpr = make_plxpr(f)(0) >>> print(qml.capture.autograph.autograph_source(f)) def ag__f(n):     with ag__.FunctionScope('f', 'fscope', ag__"
    },
    {
      "id": "qml.op_sum",
      "name": "qml.op_sum",
      "type": "function",
      "description": "PennyLane API: op_sum. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ved in v0.31   The collections module has been removed.  Deprecated in v0.29 Removed in v0.31   qml.op_sum has been removed. Users should use qml.sum instead.  Deprecated in v0.29. Removed in v0.31.  "
    },
    {
      "id": "qml.transforms.sum_expand",
      "name": "qml.transforms.sum_expand",
      "type": "function",
      "description": "PennyLane API: transforms.sum_expand. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ransform_program argument of qml.execute.  Deprecated in v0.38 Removed in v0.39   The functions qml.transforms.sum_expand and qml.transforms.hamiltonian_expand are removed. Instead, qml.transforms.spl"
    },
    {
      "id": "qml.resources.estimate_error",
      "name": "qml.resources.estimate_error",
      "type": "function",
      "description": "PennyLane API: resources.estimate_error. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "stimate_shots in favor of qml.resources.estimate_shots qml.estimator.estimate_error in favor of qml.resources.estimate_error qml.estimator.FirstQuantization in favor of qml.resources.FirstQuantization"
    },
    {
      "id": "qml.execute.",
      "name": "qml.execute.",
      "type": "function",
      "description": "PennyLane API: execute.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ransformProgram with the desired preprocessing and pass it to the transform_program argument of qml.execute.  Deprecated in v0.38 Removed in v0.39   The max_expansion argument in qml.execute is remove"
    },
    {
      "id": "qml.resources.FirstQuantization",
      "name": "qml.resources.FirstQuantization",
      "type": "function",
      "description": "PennyLane API: resources.FirstQuantization. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "mate_error in favor of qml.resources.estimate_error qml.estimator.FirstQuantization in favor of qml.resources.FirstQuantization qml.estimator.DoubleFactorization in favor of qml.resources.DoubleFactor"
    },
    {
      "id": "qml.tape.get_active_tape",
      "name": "qml.tape.get_active_tape",
      "type": "function",
      "description": "PennyLane API: tape.get_active_tape. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "hod is removed. Please use qml.pauli_decompose().  Still accessible in v0.27 Removed in v0.28   qml.tape.get_active_tape is deprecated. Please use qml.QueuingManager.active_context() instead.  Depreca"
    },
    {
      "id": "qml.gradients.hamiltonian_grad",
      "name": "qml.gradients.hamiltonian_grad",
      "type": "function",
      "description": "PennyLane API: gradients.hamiltonian_grad. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "nt machine learning framework, like PyTorch or JAX.  Deprecated in v0.41 Removed in v0.42   The qml.gradients.hamiltonian_grad function has been removed because this gradient recipe is no longer requi"
    },
    {
      "id": "qml.workflow.",
      "name": "qml.workflow.",
      "type": "function",
      "description": "PennyLane API: workflow.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "v0.44   The value None has been removed as a valid argument to the level parameter in the pennylane.workflow.get_transform_program(), pennylane.workflow.construct_batch(), pennylane.draw(), pennylane."
    },
    {
      "id": "qml.utils.sparse_hamiltonian",
      "name": "qml.utils.sparse_hamiltonian",
      "type": "function",
      "description": "PennyLane API: utils.sparse_hamiltonian. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "bit_decomposition with a rotations keyword instead.  Deprecated in v0.31 Removed in v0.32   The qml.utils.sparse_hamiltonian function has been removed. ~.Hamiltonian.sparse_matrix should be used inste"
    },
    {
      "id": "qml.devices.QubitDevice",
      "name": "qml.devices.QubitDevice",
      "type": "function",
      "description": "PennyLane API: devices.QubitDevice. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "e, and QutritDevice have been removed. Instead, they are available as qml.devices.LegacyDevice, qml.devices.QubitDevice, and qml.devices.QutritDevice respectively.  Deprecated in v0.39 Removed in v0.4"
    },
    {
      "id": "qml.resources.DoubleFactorization",
      "name": "qml.resources.DoubleFactorization",
      "type": "function",
      "description": "PennyLane API: resources.DoubleFactorization. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ation in favor of qml.resources.FirstQuantization qml.estimator.DoubleFactorization in favor of qml.resources.DoubleFactorization    Deprecated in v0.44 Removed in v0.45   argnum has been renamed argn"
    },
    {
      "id": "qml.P",
      "name": "qml.P",
      "type": "class",
      "description": "PennyLane API: P. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "                                           Deprecations — PennyLane 0.45.0-dev3 documentation                          About     Research                  Feat"
    },
    {
      "id": "qml.utils.expand",
      "name": "qml.utils.expand",
      "type": "function",
      "description": "PennyLane API: utils.expand. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "idMeasure are moved to measurements from operation.  Deprecated in v0.23 Removed in v0.27   The qml.utils.expand function is deprecated. qml.math.expand_matrix should be used instead.  Deprecated in v"
    },
    {
      "id": "qml.ops.two_qubit_decomposition.",
      "name": "qml.ops.two_qubit_decomposition.",
      "type": "function",
      "description": "PennyLane API: ops.two_qubit_decomposition.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "wo_qubit_decomposition are removed. Instead, you should use qml.ops.one_qubit_decomposition and qml.ops.two_qubit_decomposition.  Deprecated in v0.34 Removed in v0.35   Passing additional arguments to"
    },
    {
      "id": "qml.QubitStateVector",
      "name": "qml.QubitStateVector",
      "type": "class",
      "description": "PennyLane API: QubitStateVector. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "template has been removed. Instead, use BasisState.  Deprecated in v0.39 Removed in v0.40   The qml.QubitStateVector template has been removed. Instead, use StatePrep.  Deprecated in v0.39 Removed in "
    },
    {
      "id": "qml.qchem.jordan_wigner",
      "name": "qml.qchem.jordan_wigner",
      "type": "function",
      "description": "PennyLane API: qchem.jordan_wigner. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "auliZ(0)} {PauliZ(wires=[0]), PauliZ(wires=[0])}    Added in v0.32 Behaviour changed in v0.33   qml.qchem.jordan_wigner had been removed. Use qml.jordan_wigner instead. List input to define the fermio"
    },
    {
      "id": "qml.from_qasm.",
      "name": "qml.from_qasm.",
      "type": "function",
      "description": "PennyLane API: from_qasm.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "qasm_file has been removed. Instead, the user can open the file and then load its content using qml.from_qasm. >>> with open(\"test.qasm\", \"r\") as f: ...     circuit = qml.from_qasm(f.read())    Deprec"
    },
    {
      "id": "qml.transforms.measurement_grouping",
      "name": "qml.transforms.measurement_grouping",
      "type": "function",
      "description": "PennyLane API: transforms.measurement_grouping. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ients module for general parameter-shift rules instead.  Deprecated in v0.22 Removed in v0.28   qml.transforms.measurement_grouping has been removed. Please use qml.transforms.hamiltonian_expand inste"
    },
    {
      "id": "qml.devices.QutritDevice",
      "name": "qml.devices.QutritDevice",
      "type": "function",
      "description": "PennyLane API: devices.QutritDevice. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " removed. Instead, they are available as qml.devices.LegacyDevice, qml.devices.QubitDevice, and qml.devices.QutritDevice respectively.  Deprecated in v0.39 Removed in v0.40   The BasisStatePreparation"
    },
    {
      "id": "qml.qinfo.classical_fisher",
      "name": "qml.qinfo.classical_fisher",
      "type": "function",
      "description": "PennyLane API: qinfo.classical_fisher. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "_depth argument in qml.device is removed.  Deprecated in v0.38 Removed in v0.39   The functions qml.qinfo.classical_fisher and qml.qinfo.quantum_fisher have been removed and migrated to the qml.gradie"
    },
    {
      "id": "qml.operation.AllWires",
      "name": "qml.operation.AllWires",
      "type": "function",
      "description": "PennyLane API: operation.AllWires. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " be used to compare instances.  Deprecated in v0.42 Removed in v0.43   qml.operation.WiresEnum, qml.operation.AllWires, and qml.operation.AnyWires have been removed. If an operation can act on any num"
    },
    {
      "id": "qml.disable_return",
      "name": "qml.disable_return",
      "type": "function",
      "description": "PennyLane API: disable_return. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ipt.get_parameters() numpy_params = unwrapped_qscript.get_parameters()    qml.enable_return and qml.disable_return have been removed. The old return types are no longer available.  Deprecated in v0.32"
    },
    {
      "id": "qml.tape.stop_recording",
      "name": "qml.tape.stop_recording",
      "type": "function",
      "description": "PennyLane API: tape.stop_recording. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "eturns a new tape instead of modifying itself in-place.  Deprecated in v0.27 Removed in v0.28   qml.tape.stop_recording and QuantumTape.stop_recording are moved to qml.QueuingManager.stop_recording  D"
    },
    {
      "id": "qml.transforms.qcut.remap_tape_wires",
      "name": "qml.transforms.qcut.remap_tape_wires",
      "type": "function",
      "description": "PennyLane API: transforms.qcut.remap_tape_wires. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "Please use qml.QueuingManager.active_context() instead.  Deprecated in v0.27 Removed in v0.28   qml.transforms.qcut.remap_tape_wires is deprecated. Please use qml.map_wires instead.  Deprecated in v0."
    },
    {
      "id": "qml.pauli.pauli_mult",
      "name": "qml.pauli.pauli_mult",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_mult. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "t does not provide wires, or quantum functions.  Deprecated in v0.35 Raises an error in v0.36   qml.pauli.pauli_mult and qml.pauli.pauli_mult_with_phase are now removed. Instead, you should use qml.si"
    },
    {
      "id": "qml.VQECost",
      "name": "qml.VQECost",
      "type": "class",
      "description": "PennyLane API: VQECost. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "uli/utils.py. The remaining functions have been consolidated in the pauli/grouping/ directory.  qml.VQECost is removed.   Deprecated in 0.13 Removed in 0.29    In-place inversion — op.inv() and op.inv"
    },
    {
      "id": "qml.pauli.",
      "name": "qml.pauli.",
      "type": "function",
      "description": "PennyLane API: pauli.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "e to dispatch to pennylane.ops.LinearCombination.  Deprecated in v0.39 Removed in v0.40   pennylane.pauli.PauliSentence.hamiltonian() and pennylane.pauli.PauliWord.hamiltonian() have been removed. Ins"
    },
    {
      "id": "qml.qnn.keras",
      "name": "qml.qnn.keras",
      "type": "function",
      "description": "PennyLane API: qnn.keras. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " please use isinstance instead.  Deprecated in v0.41 Removed in v0.42   The KerasLayer class in qml.qnn.keras has been removed because Keras 2 is no longer actively maintained. Please consider using a"
    },
    {
      "id": "qml.Operation.get_parameter_shift",
      "name": "qml.Operation.get_parameter_shift",
      "type": "class",
      "description": "PennyLane API: Operation.get_parameter_shift. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ted. qml.math.expand_matrix should be used instead.  Deprecated in v0.24 Removed in v0.27   The qml.Operation.get_parameter_shift method is removed. Use the methods of the gradients module for general"
    },
    {
      "id": "qml.operation.Observable",
      "name": "qml.operation.Observable",
      "type": "function",
      "description": "PennyLane API: operation.Observable. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "iealg import lie_closure, structure_constants, center    Deprecated in v0.40 Removed in v0.43   qml.operation.Observable has been removed. To indicate that an operator is an observable, operator devel"
    },
    {
      "id": "qml.gradients.pulse_generator",
      "name": "qml.gradients.pulse_generator",
      "type": "function",
      "description": "PennyLane API: gradients.pulse_generator. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " passed to qml.ctrl as a string is no longer supported.  Deprecated in v0.25 Removed in v0.34   qml.gradients.pulse_generator has become qml.gradients.pulse_odegen to adhere to paper naming convention"
    },
    {
      "id": "qml.qsvt.",
      "name": "qml.qsvt.",
      "type": "function",
      "description": "PennyLane API: qsvt.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "recated in v0.40 Removed in v0.41   The qml.qsvt_legacy function has been removed. Instead, use qml.qsvt. The new functionality takes an input polynomial instead of angles.  Deprecated in v0.40 Remove"
    },
    {
      "id": "qml.qnn.cost.SquaredErrorLoss",
      "name": "qml.qnn.cost.SquaredErrorLoss",
      "type": "function",
      "description": "PennyLane API: qnn.cost.SquaredErrorLoss. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "0]), PauliRot(-0.6, XY, wires=[0, 1]), RX(0.5, wires=[0]), PauliRot(-0.6, XY, wires=[0, 1])]    qml.qnn.cost.SquaredErrorLoss has been removed. Instead, this hybrid workflow can be accomplished with a"
    },
    {
      "id": "qml.load",
      "name": "qml.load",
      "type": "function",
      "description": "PennyLane API: load. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "emoved in v0.38   qml.from_qasm_file has been removed. Instead, the user can open the file and then load its content using qml.from_qasm. >>> with open(\"test.qasm\", \"r\") as f: ...     circuit = qml.fr"
    },
    {
      "id": "qml.workflow.run",
      "name": "qml.workflow.run",
      "type": "function",
      "description": "PennyLane API: workflow.run. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " in qml.execute have been removed. If more detailed control over the execution is required, use qml.workflow.run with these arguments instead.  Deprecated in v0.41 Removed in v0.42   op.ops and op.coe"
    },
    {
      "id": "qml.qsvt_legacy",
      "name": "qml.qsvt_legacy",
      "type": "function",
      "description": "PennyLane API: qsvt_legacy. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " or MeasurementProcess to get the same information.  Deprecated in v0.40 Removed in v0.41   The qml.qsvt_legacy function has been removed. Instead, use qml.qsvt. The new functionality takes an input p"
    },
    {
      "id": "qml.transforms.core.TransformProgram",
      "name": "qml.transforms.core.TransformProgram",
      "type": "function",
      "description": "PennyLane API: transforms.core.TransformProgram. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "8 Removed in v0.39   The expand_fn argument in qml.execute is removed. Instead, please create a qml.transforms.core.TransformProgram with the desired preprocessing and pass it to the transform_program"
    },
    {
      "id": "qml.shadows.shadow_expval",
      "name": "qml.shadows.shadow_expval",
      "type": "function",
      "description": "PennyLane API: shadows.shadow_expval. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ent_fn can also be used to process the diff method.  Deprecated in v0.39 Removed in v0.40   The qml.shadows.shadow_expval transform has been removed. Instead, please use the qml.shadow_expval measurem"
    },
    {
      "id": "qml.transforms.map_batch_transform",
      "name": "qml.transforms.map_batch_transform",
      "type": "function",
      "description": "PennyLane API: transforms.map_batch_transform. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "asurements from the original circuit.  Deprecated in v0.37 Default behaviour changed in v0.38   qml.transforms.map_batch_transform has been removed, since transforms can be applied directly to a batch"
    },
    {
      "id": "qml.transforms.hamiltonian_expand",
      "name": "qml.transforms.hamiltonian_expand",
      "type": "function",
      "description": "PennyLane API: transforms.hamiltonian_expand. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ml.execute.  Deprecated in v0.38 Removed in v0.39   The functions qml.transforms.sum_expand and qml.transforms.hamiltonian_expand are removed. Instead, qml.transforms.split_non_commuting can be used f"
    },
    {
      "id": "qml.transforms.two_qubit_decomposition",
      "name": "qml.transforms.two_qubit_decomposition",
      "type": "function",
      "description": "PennyLane API: transforms.two_qubit_decomposition. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "rator class.  Deprecated in v0.35 Removed in v0.36   qml.transforms.one_qubit_decomposition and qml.transforms.two_qubit_decomposition are removed. Instead, you should use qml.ops.one_qubit_decomposit"
    },
    {
      "id": "qml.operation.AnyWires",
      "name": "qml.operation.AnyWires",
      "type": "function",
      "description": "PennyLane API: operation.AnyWires. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "s.  Deprecated in v0.42 Removed in v0.43   qml.operation.WiresEnum, qml.operation.AllWires, and qml.operation.AnyWires have been removed. If an operation can act on any number of wires, Operator.num_w"
    },
    {
      "id": "qml.ops.qutrit.parametric_ops",
      "name": "qml.ops.qutrit.parametric_ops",
      "type": "function",
      "description": "PennyLane API: ops.qutrit.parametric_ops. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ce(subspace), only employed under a specific set of qutrit operators, has been relocated to the qml.ops.qutrit.parametric_ops module and has been removed from the Operator class.  Deprecated in v0.35 "
    },
    {
      "id": "qml.QNode.add_transform",
      "name": "qml.QNode.add_transform",
      "type": "class",
      "description": "PennyLane API: QNode.add_transform. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "rder(obj) in favor of descendants(obj, sort=True)    Deprecated in v0.43 Removed in v0.44   The qml.QNode.add_transform method is removed. Instead, please use QNode.transform_program.push_back(transfo"
    },
    {
      "id": "qml.from_qasm_file",
      "name": "qml.from_qasm_file",
      "type": "function",
      "description": "PennyLane API: from_qasm_file. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "a batch of tapes. See transform() for more information.  Deprecated in v0.37 Removed in v0.38   qml.from_qasm_file has been removed. Instead, the user can open the file and then load its content using"
    },
    {
      "id": "qml.resources.estimate_shots",
      "name": "qml.resources.estimate_shots",
      "type": "function",
      "description": "PennyLane API: resources.estimate_shots. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "st be imported from the ~pennylane.estimator module.   qml.estimator.estimate_shots in favor of qml.resources.estimate_shots qml.estimator.estimate_error in favor of qml.resources.estimate_error qml.e"
    },
    {
      "id": "qml.exceptions.PennyLaneDeprecationWarning.",
      "name": "qml.exceptions.PennyLaneDeprecationWarning.",
      "type": "function",
      "description": "PennyLane API: exceptions.PennyLaneDeprecationWarning.. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "l.workflow          Docs Deprecations     Deprecations¶ All PennyLane deprecations will raise a qml.exceptions.PennyLaneDeprecationWarning. Pending and completed deprecations are listed below.  Pendin"
    },
    {
      "id": "qml.operation.WiresEnum",
      "name": "qml.operation.WiresEnum",
      "type": "function",
      "description": "PennyLane API: operation.WiresEnum. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ual and op1 == op2 should be used to compare instances.  Deprecated in v0.42 Removed in v0.43   qml.operation.WiresEnum, qml.operation.AllWires, and qml.operation.AnyWires have been removed. If an ope"
    },
    {
      "id": "qml.broadcast",
      "name": "qml.broadcast",
      "type": "function",
      "description": "PennyLane API: broadcast. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ctor template has been removed. Instead, use StatePrep.  Deprecated in v0.39 Removed in v0.40   qml.broadcast has been removed. Users should use for loops instead.  Deprecated in v0.39 Removed in v0.4"
    },
    {
      "id": "qml.ExpvalCost",
      "name": "qml.ExpvalCost",
      "type": "class",
      "description": "PennyLane API: ExpvalCost. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "any(is_sample_type) all_sampled = all(is_sample_type)    Deprecated in v0.34 Removed in v0.35   qml.ExpvalCost has been removed. Users should use qml.expval() instead. @qml.qnode(dev) def cost_functio"
    },
    {
      "id": "qml.interfaces",
      "name": "qml.interfaces",
      "type": "function",
      "description": "PennyLane API: interfaces. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "dummy values that are no longer needed.  Deprecated in v0.35 Removed in v0.36   The contents of qml.interfaces is moved inside qml.workflow.  Contents moved in v0.35 Old import path removed in v0.36  "
    },
    {
      "id": "qml.QNode.get_gradient_fn",
      "name": "qml.QNode.get_gradient_fn",
      "type": "class",
      "description": "PennyLane API: QNode.get_gradient_fn. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "alidate that the correct number of wires is passed.  Deprecated in v0.42 Removed in v0.43   The qml.QNode.get_gradient_fn method has been removed. Instead, use get_best_diff_method() to obtain the dif"
    },
    {
      "id": "qml.pauli.pauli_mult_with_phase",
      "name": "qml.pauli.pauli_mult_with_phase",
      "type": "function",
      "description": "PennyLane API: pauli.pauli_mult_with_phase. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": " or quantum functions.  Deprecated in v0.35 Raises an error in v0.36   qml.pauli.pauli_mult and qml.pauli.pauli_mult_with_phase are now removed. Instead, you should use qml.simplify(qml.prod(pauli_1, "
    },
    {
      "id": "qml.qinfo.quantum_fisher",
      "name": "qml.qinfo.quantum_fisher",
      "type": "function",
      "description": "PennyLane API: qinfo.quantum_fisher. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "s removed.  Deprecated in v0.38 Removed in v0.39   The functions qml.qinfo.classical_fisher and qml.qinfo.quantum_fisher have been removed and migrated to the qml.gradients module. Therefore, qml.grad"
    },
    {
      "id": "qml.transforms.make_tape",
      "name": "qml.transforms.make_tape",
      "type": "function",
      "description": "PennyLane API: transforms.make_tape. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": ". Please use qml.transforms.hamiltonian_expand instead.  Deprecated in v0.28 Removed in v0.29   qml.transforms.make_tape was previously deprecated, but there is no longer a plan to remove it. It no lo"
    },
    {
      "id": "qml.transforms.one_qubit_decomposition",
      "name": "qml.transforms.one_qubit_decomposition",
      "type": "function",
      "description": "PennyLane API: transforms.one_qubit_decomposition. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "ps module and has been removed from the Operator class.  Deprecated in v0.35 Removed in v0.36   qml.transforms.one_qubit_decomposition and qml.transforms.two_qubit_decomposition are removed. Instead, "
    },
    {
      "id": "qml.qinfo",
      "name": "qml.qinfo",
      "type": "function",
      "description": "PennyLane API: qinfo. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "nality takes an input polynomial instead of angles.  Deprecated in v0.40 Removed in v0.41   The qml.qinfo module has been removed. Please see the respective functions in the qml.math and qml.measureme"
    },
    {
      "id": "qml.enable_return",
      "name": "qml.enable_return",
      "type": "function",
      "description": "PennyLane API: enable_return. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": ")  torch_params = qscript.get_parameters() numpy_params = unwrapped_qscript.get_parameters()    qml.enable_return and qml.disable_return have been removed. The old return types are no longer available"
    },
    {
      "id": "qml.utils.decompose_hamiltonian",
      "name": "qml.utils.decompose_hamiltonian",
      "type": "function",
      "description": "PennyLane API: utils.decompose_hamiltonian. Found in deprecations.html",
      "source_file": "deprecations.html",
      "context": "uliX(0), -1, lazy=False) PauliX(wires=[0]) >>> qml.PauliX(0) ** -1 PauliX(wires=[0])**-1    The qml.utils.decompose_hamiltonian() method is removed. Please use qml.pauli_decompose().  Still accessible"
    },
    {
      "id": "qml.package_name",
      "name": "qml.package_name",
      "type": "function",
      "description": "PennyLane API: package_name. Found in documentation.html",
      "source_file": "documentation.html",
      "context": "g, add an autosummary table that contains all modules in your package: .. currentmodule:: pennylane.package_name .. autosummary::    :toctree: api     module1    module2   All modules should also cont"
    },
    {
      "id": "qml.module_name",
      "name": "qml.module_name",
      "type": "function",
      "description": "PennyLane API: module_name. Found in documentation.html",
      "source_file": "documentation.html",
      "context": "ocstring, that summarizes what the module purpose is, and what it contains. Add a file doc/code/qml_module_name.rst, that contains the following: qml.module_name ===============  .. currentmodule:: pe"
    },
    {
      "id": "qml.ops.op_math.Controlled.map_wires",
      "name": "qml.ops.op_math.Controlled.map_wires",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Controlled.map_wires. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "01) QPE can now accept a target operator instead of a matrix and target wires pair. (#3373) The qml.ops.op_math.Controlled.map_wires method now uses base.map_wires internally instead of the private _w"
    },
    {
      "id": "qml.QubitStateVector.state_vector",
      "name": "qml.QubitStateVector.state_vector",
      "type": "class",
      "description": "PennyLane API: QubitStateVector.state_vector. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ser-defined QNode arguments. (#3765) Operators now use TensorLike types dunder methods. (#3749) qml.QubitStateVector.state_vector now supports broadcasting. (#3852) qml.SparseHamiltonian can now be ap"
    },
    {
      "id": "qml.gradients.classical_jacobian.",
      "name": "qml.gradients.classical_jacobian.",
      "type": "function",
      "description": "PennyLane API: gradients.classical_jacobian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "l.transforms.classical_jacobian has been moved to the gradients module and is now accessible as qml.gradients.classical_jacobian. (#4900) The transforms submodule qml.transforms.qcut is now its own mo"
    },
    {
      "id": "qml.gradients.eigvals_to_frequencies.",
      "name": "qml.gradients.eigvals_to_frequencies.",
      "type": "function",
      "description": "PennyLane API: gradients.eigvals_to_frequencies.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", we can compute the frequencies (the unique positive differences of any two eigenvalues) using qml.gradients.eigvals_to_frequencies. qml.gradients.generate_shift_rule can then be used to compute the "
    },
    {
      "id": "qml.StronglyEntanglingLayers.",
      "name": "qml.StronglyEntanglingLayers.",
      "type": "class",
      "description": "PennyLane API: StronglyEntanglingLayers.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " a 50-qubit circuit: n_wires = 50 dev = qml.device(\"null.qubit\", wires=n_wires)  weight_shape = qml.StronglyEntanglingLayers.shape(2, n_wires) weights = np.random.random(weight_shape, requires_grad=Tr"
    },
    {
      "id": "qml.ftqc.utils",
      "name": "qml.ftqc.utils",
      "type": "function",
      "description": "PennyLane API: ftqc.utils. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tatePrep, has been added for the Graph state construction. (#6985) (#7092) A new utility module qml.ftqc.utils is provided, with support for functionality such as dynamic qubit recycling. (#7075) A ne"
    },
    {
      "id": "qml.prod.",
      "name": "qml.prod.",
      "type": "function",
      "description": "PennyLane API: prod.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nge(3))   Here, U is a quantum operation that is created by decorating a quantum function with @qml.prod. This could alternatively be done by creating a user-defined custom operation with a decomposit"
    },
    {
      "id": "qml.templates.ArbitraryUnitary",
      "name": "qml.templates.ArbitraryUnitary",
      "type": "function",
      "description": "PennyLane API: templates.ArbitraryUnitary. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "hts1, weights2):       qml.templates.ArbitraryStatePreparation(weights1, wires=[0, 1, 2])       qml.templates.ArbitraryUnitary(weights2, wires=[0, 1, 2])       return qml.probs(wires=[0, 1, 2])    Add"
    },
    {
      "id": "qml.operation.convert_to_legacy_H.",
      "name": "qml.operation.convert_to_legacy_H.",
      "type": "function",
      "description": "PennyLane API: operation.convert_to_legacy_H.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n, qml.operation.Tensor, qml.operation.enable_new_opmath, qml.operation.disable_new_opmath, and qml.operation.convert_to_legacy_H. Note that qml.Hamiltonian will continue to dispatch to qml.ops.Linear"
    },
    {
      "id": "qml.liealg.check_commutation_relation.",
      "name": "qml.liealg.check_commutation_relation.",
      "type": "function",
      "description": "PennyLane API: liealg.check_commutation_relation.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".labs.khaneja_glaser_involution has been removed, pennylane.labs.check_commutation has moved to qml.liealg.check_commutation_relation. pennylane.labs.check_cartan_decomp has moved to qml.liealg.check_"
    },
    {
      "id": "qml.liealg.AIII.",
      "name": "qml.liealg.AIII.",
      "type": "function",
      "description": "PennyLane API: liealg.AIII.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e device will be responsible for all MCM handling. (#7243) Fixed coverage of qml.liealg.CII and qml.liealg.AIII. (#7291) Fixed a bug where the phase is used as the wire label for a qml.GlobalPhase whe"
    },
    {
      "id": "qml.templates.QFT",
      "name": "qml.templates.QFT",
      "type": "function",
      "description": "PennyLane API: templates.QFT. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ts. (#1591)  Breaking changes The QFT operation has been moved, and is now accessible via pennylane.templates.QFT. (#1548) Specifying shots=None with qml.sample was previously deprecated. From this re"
    },
    {
      "id": "qml.ops.ops_math.",
      "name": "qml.ops.ops_math.",
      "type": "function",
      "description": "PennyLane API: ops.ops_math.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ocumentation for unitaries and operations’ decompositions has been moved from qml.transforms to qml.ops.ops_math. (#4906) Documentation for qml.metric_tensor and qml.adjoint_metric_tensor and qml.tran"
    },
    {
      "id": "qml.QueuingContext.update_info",
      "name": "qml.QueuingContext.update_info",
      "type": "class",
      "description": "PennyLane API: QueuingContext.update_info. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "6) A new method safe_update_info is added to qml.QueuingContext. This method is substituted for qml.QueuingContext.update_info in a variety of places. (#2612) (#2675) BasisEmbedding can accept an int "
    },
    {
      "id": "qml.PauliWord",
      "name": "qml.PauliWord",
      "type": "class",
      "description": "PennyLane API: PauliWord. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " when there are complicated target ops. (#8133) Fixed a bug that made the queueing behaviour of qml.PauliWord.operation and qmle.PauliSentence.operation depndent on the global state of a program due t"
    },
    {
      "id": "qml.qnn.TorchLayer.",
      "name": "qml.qnn.TorchLayer.",
      "type": "function",
      "description": "PennyLane API: qnn.TorchLayer.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "computing the expectation. (#4590) The torch.nn.Module properties are now accessible on a pennylane.qnn.TorchLayer. (#4611) qml.math.take with Pytorch now returns tensor[..., indices] when the user re"
    },
    {
      "id": "qml.lie_closure.",
      "name": "qml.lie_closure.",
      "type": "function",
      "description": "PennyLane API: lie_closure.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " of Lie algebra functionality:  Compute the dynamical Lie algebra from a set of generators with qml.lie_closure. This function accepts and outputs matrices when matrix=True. import pennylane as qml fr"
    },
    {
      "id": "qml.CircuitGraph.greedy_layers",
      "name": "qml.CircuitGraph.greedy_layers",
      "type": "class",
      "description": "PennyLane API: CircuitGraph.greedy_layers. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "by list of sets of operators or measurements. qml.transforms.draw_old was replaced by qml.draw. qml.CircuitGraph.greedy_layers was deleted, as it was no longer needed by the circuit drawer and did not"
    },
    {
      "id": "qml.ResourceSemiAdder",
      "name": "qml.ResourceSemiAdder",
      "type": "class",
      "description": "PennyLane API: ResourceSemiAdder. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "been added: qml.ResourceOutOfPlaceSquare, qml.ResourcePhaseGradient, qml.ResourceOutMultiplier, qml.ResourceSemiAdder, qml.ResourceBasisRotation, qml.ResourceSelect, and qml.ResourceQROM. (#7725) A ne"
    },
    {
      "id": "qml.transpile",
      "name": "qml.transpile",
      "type": "function",
      "description": "PennyLane API: transpile. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "(#5804) The qml.Tracker examples have been updated. (#5803) The input types for coupling_map in qml.transpile have been updated to reflect all the allowed input types by nx.to_networkx_graph. (#5864) "
    },
    {
      "id": "qml.is_commuting.",
      "name": "qml.is_commuting.",
      "type": "function",
      "description": "PennyLane API: is_commuting.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "on is eliminated in preparation for its deprecation. (#2965) Controlled operators now work with qml.is_commuting. (#2994) qml.prod and qml.op_sum now support the sparse_matrix() method. (#3006) >>> xy"
    },
    {
      "id": "qml.optimize.AdamOptimizer",
      "name": "qml.optimize.AdamOptimizer",
      "type": "function",
      "description": "PennyLane API: optimize.AdamOptimizer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "y batch transforms to execute transformed QNodes. (#1708) To standardize across all optimizers, qml.optimize.AdamOptimizer now also uses accumulation (in form of collections.namedtuple) to keep track "
    },
    {
      "id": "qml.numpy.pi",
      "name": "qml.numpy.pi",
      "type": "function",
      "description": "PennyLane API: numpy.pi. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "asureMP}) @qml.qnode(dev) def circuit():     m0 = qml.measure(0)     qml.cond(m0 == 0, qml.Rot)(qml.numpy.pi / 2, qml.numpy.pi / 2, qml.numpy.pi / 2, wires=1)     return qml.expval(qml.X(0))   >>> pri"
    },
    {
      "id": "qml.Sum",
      "name": "qml.Sum",
      "type": "class",
      "description": "PennyLane API: Sum. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " (#7301) The inner_transform and config keyword arguments in qml.execute have been removed. (#7300) Sum.ops, Sum.coeffs, Prod.ops and Prod.coeffs have been removed. (#7304) Specifying pipeline=None wi"
    },
    {
      "id": "qml.devices.qubit_mixed",
      "name": "qml.devices.qubit_mixed",
      "type": "function",
      "description": "PennyLane API: devices.qubit_mixed. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ed in favour of the existing transform in a device’s preprocessing transform program. (#6701) A qml.devices.qubit_mixed module has been added for mixed-state qubit device support. This module introduc"
    },
    {
      "id": "qml.labs.dla.lie_closure_dense.",
      "name": "qml.labs.dla.lie_closure_dense.",
      "type": "function",
      "description": "PennyLane API: labs.dla.lie_closure_dense.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d to include examples that can be copied. (#6834) A typo has been fixed in the code example for qml.labs.dla.lie_closure_dense. (#6858) The code example in the docstring for qml.BasisRotation was corr"
    },
    {
      "id": "qml.wires._process",
      "name": "qml.wires._process",
      "type": "function",
      "description": "PennyLane API: wires._process. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", 2]) >>> w[1] >>> 1    The check for uniqueness of wires moved from Wires instantiation to the qml.wires._process function in order to reduce overhead from repeated creation of Wires instances. Calls"
    },
    {
      "id": "qml.qaoa.xy_mixer",
      "name": "qml.qaoa.xy_mixer",
      "type": "function",
      "description": "PennyLane API: qaoa.xy_mixer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "le. (#712) (#718) (#741) (#720) This includes the following features:  New qml.qaoa.x_mixer and qml.qaoa.xy_mixer functions for defining Pauli-X and XY mixer Hamiltonians. MaxCut: The qml.qaoa.maxcut "
    },
    {
      "id": "qml.wires.Wires.",
      "name": "qml.wires.Wires.",
      "type": "function",
      "description": "PennyLane API: wires.Wires.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "more, a FutureWarning is no longer raised in JAX 0.4.30+ when providing JAX tracers as input to qml.wires.Wires. (#6312) A new function called qml.capture.make_plxpr has been added to take a function "
    },
    {
      "id": "qml.transforms.cut_circuit",
      "name": "qml.transforms.cut_circuit",
      "type": "function",
      "description": "PennyLane API: transforms.cut_circuit. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ms.batch_params and qml.transforms.batch_input to support the new return types. (#3431) Updated qml.transforms.cut_circuit and qml.transforms.cut_circuit_mc to support the new return types. (#3346) Li"
    },
    {
      "id": "qml.transforms.mitigate_with_zne.",
      "name": "qml.transforms.mitigate_with_zne.",
      "type": "function",
      "description": "PennyLane API: transforms.mitigate_with_zne.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "5884) New functionality has been added to natively support exponential extrapolation when using qml.transforms.mitigate_with_zne. This allows users to have more control over the error mitigation proto"
    },
    {
      "id": "qml.grouping.utils.is_commuting",
      "name": "qml.grouping.utils.is_commuting",
      "type": "function",
      "description": "PennyLane API: grouping.utils.is_commuting. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "_matrix() has been moved from pennylane.operation to pennylane.math.matrix_manipulation (#3008) qml.grouping.utils.is_commuting has been removed, and its Pauli word logic is now part of qml.is_commuti"
    },
    {
      "id": "qml.PennyLaneDeprecationWarning",
      "name": "qml.PennyLaneDeprecationWarning",
      "type": "class",
      "description": "PennyLane API: PennyLaneDeprecationWarning. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "t_best_diff_method() to obtain the differentiation method. (#7907) Top-level access to DeviceError, PennyLaneDeprecationWarning, QuantumFunctionError and ExperimentalWarning has been removed. Please i"
    },
    {
      "id": "qml.tape.Unwrap",
      "name": "qml.tape.Unwrap",
      "type": "function",
      "description": "PennyLane API: tape.Unwrap. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ce-specific parameters to one with only numpy parameters. This transform is designed to replace qml.tape.Unwrap. (#3899) qml.operation.WiresEnum.AllWires is now -2 instead of 0 to avoid the ambiguity "
    },
    {
      "id": "qml.gradients.gradient_transform.choose_trainable_params",
      "name": "qml.gradients.gradient_transform.choose_trainable_params",
      "type": "function",
      "description": "PennyLane API: gradients.gradient_transform.choose_trainable_params. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " is extremely expensive, and the definition is ambiguous for non-commuting observables. (#7047) qml.gradients.gradient_transform.choose_trainable_params has been renamed to choose_trainable_param_indi"
    },
    {
      "id": "qml.operation.defines_diagonalizing_gates",
      "name": "qml.operation.defines_diagonalizing_gates",
      "type": "function",
      "description": "PennyLane API: operation.defines_diagonalizing_gates. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d to the highest-level Operator class and is therefore available to all subclasses. A condition qml.operation.defines_diagonalizing_gates has been added, which can be used in tape contexts without que"
    },
    {
      "id": "qml.specs.",
      "name": "qml.specs.",
      "type": "function",
      "description": "PennyLane API: specs.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nth_circuit)()[\"resources\"] >>> sk_specs = qml.specs(sk_circuit)()[\"resources\"] >>> print(gridsynth_specs.num_gates, sk_specs.num_gates) 239 47942 >>> print(gridsynth_specs.gate_types['T'], sk_specs.g"
    },
    {
      "id": "qml.ops.one_qubit_transform",
      "name": "qml.ops.one_qubit_transform",
      "type": "function",
      "description": "PennyLane API: ops.one_qubit_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "of QSVT has been updated to include examples for different block encodings. (#6673) The link to qml.ops.one_qubit_transform was fixed in the QubitUnitary docstring. (#6745)  Bug fixes 🐛 Validation has"
    },
    {
      "id": "qml.operation.StatePrep",
      "name": "qml.operation.StatePrep",
      "type": "function",
      "description": "PennyLane API: operation.StatePrep. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "s been renamed to qml.StatePrepBase and qml.QubitStateVector has been renamed to qml.StatePrep. qml.operation.StatePrep and qml.QubitStateVector are still accessible. (#4450) Support for Python 3.8 ha"
    },
    {
      "id": "qml.transforms.metric_tensor",
      "name": "qml.transforms.metric_tensor",
      "type": "function",
      "description": "PennyLane API: transforms.metric_tensor. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".devices.DefaultQubit. (#4456) Auxiliary wires and device wires are now treated the same way in qml.transforms.metric_tensor as in qml.gradients.hadamard_grad. All valid wire input formats for aux_wir"
    },
    {
      "id": "qml.Evolution",
      "name": "qml.Evolution",
      "type": "class",
      "description": "PennyLane API: Evolution. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e Generalized Quantum Signal Processing (GQSP) algorithm using estimator.GQSP and estimator.GQSPTimeEvolution. (#8675) Users can now easily generate the LCU representation of a qml.estimator.PauliHami"
    },
    {
      "id": "qml.ops.op_math.Pow.__new__",
      "name": "qml.ops.op_math.Pow.__new__",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Pow.__new__. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "to construct QuantumTape upon initialization instead of with queuing. (#4243) The docstring for qml.ops.op_math.Pow.__new__ is now complete and it has been updated along with qml.ops.op_math.Adjoint._"
    },
    {
      "id": "qml.qchem.molecular_hamiltonian.",
      "name": "qml.qchem.molecular_hamiltonian.",
      "type": "function",
      "description": "PennyLane API: qchem.molecular_hamiltonian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "operations correctly into account. (#8429) Promoting NumPy data to autograd no longer occurs in qml.qchem.molecular_hamiltonian. (#8410) Fixed compatibility with JAX and PyTorch input parameters in Sp"
    },
    {
      "id": "qml.math.decomposition.",
      "name": "qml.math.decomposition.",
      "type": "function",
      "description": "PennyLane API: math.decomposition.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ulate rotation angles for unitary decompositions have been moved into an internal module called qml.math.decomposition. (#7211) Fixed a failing integration test for qml.QDrift which multiplied the ope"
    },
    {
      "id": "qml.pauli.simplify",
      "name": "qml.pauli.simplify",
      "type": "function",
      "description": "PennyLane API: pauli.simplify. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " use qml.pauli.PauliSentence.operation and qml.pauli.PauliWord.operation, respectively. (#6287) qml.pauli.simplify() has been deprecated. Instead, please use qml.simplify(op) or op.simplify(). (#6287)"
    },
    {
      "id": "qml.from_qiskit_op.",
      "name": "qml.from_qiskit_op.",
      "type": "function",
      "description": "PennyLane API: from_qiskit_op.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "s, it is also possible to convert operators from Qiskit to PennyLane with a new function called qml.from_qiskit_op. (#5251) A Qiskit SparsePauliOp can be converted to a PennyLane operator using qml.fr"
    },
    {
      "id": "qml.ops.Exp",
      "name": "qml.ops.Exp",
      "type": "function",
      "description": "PennyLane API: ops.Exp. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " Providing num_steps to pennylane.evolve(), pennylane.exp(), pennylane.ops.Evolution, and pennylane.ops.Exp has been disallowed. Instead, use TrotterProduct for approximate methods, providing the n pa"
    },
    {
      "id": "qml.ops.qubit.BasisStateProjector",
      "name": "qml.ops.qubit.BasisStateProjector",
      "type": "function",
      "description": "PennyLane API: ops.qubit.BasisStateProjector. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "g longer measurements. The trit flip error represents misclassification during readout. (#5842) qml.ops.qubit.BasisStateProjector now has a compute_sparse_matrix method that computes the sparse CSR ma"
    },
    {
      "id": "qml.fourier.spectrum",
      "name": "qml.fourier.spectrum",
      "type": "function",
      "description": "PennyLane API: fourier.spectrum. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e linked page for examples); The default.tensor and default.tensor.tf experimental devices; The qml.fourier.spectrum function (use the qml.fourier.circuit_spectrum or qml.fourier.qnode_spectrum functi"
    },
    {
      "id": "qml.math.quantum._denman_beavers_iterations",
      "name": "qml.math.quantum._denman_beavers_iterations",
      "type": "function",
      "description": "PennyLane API: math.quantum._denman_beavers_iterations. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nabled is more clear. (#7130) Logic in _capture_qnode.py has been cleaned. (#7115) The test for qml.math.quantum._denman_beavers_iterations has been improved such that tested random matrices are guara"
    },
    {
      "id": "qml.DoubleExcitation.",
      "name": "qml.DoubleExcitation.",
      "type": "class",
      "description": "PennyLane API: DoubleExcitation.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "interface documentation (#1312) Fixed typos in the mathematical expressions in documentation of qml.DoubleExcitation. (#1278) Remove unsupported None option from the qml.QNode docstrings. (#1271) Upda"
    },
    {
      "id": "qml.compiler.python_compiler.transforms.IterativeCancelInversesPass",
      "name": "qml.compiler.python_compiler.transforms.IterativeCancelInversesPass",
      "type": "function",
      "description": "PennyLane API: compiler.python_compiler.transforms.IterativeCancelInversesPass. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " the experimental xDSL Python compiler integration. (#7364) (#7595) (#7664) An xDSL pass called qml.compiler.python_compiler.transforms.IterativeCancelInversesPass has been added for applying cancel_i"
    },
    {
      "id": "qml.transforms.map_wires",
      "name": "qml.transforms.map_wires",
      "type": "function",
      "description": "PennyLane API: transforms.map_wires. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "om PennyLane. It has been migrated to Catalyst, available as catalyst.python_interface. (#8662) qml.transforms.map_wires no longer supports plxpr transforms. (#8683) QuantumScript.to_openqasm has been"
    },
    {
      "id": "qml.transforms.get_unitary_matrix",
      "name": "qml.transforms.get_unitary_matrix",
      "type": "function",
      "description": "PennyLane API: transforms.get_unitary_matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e a standard QuantumTape, and apply gradient transforms using the qml.gradients module. (#2306) qml.transforms.get_unitary_matrix() has been deprecated and will be removed in a future release. For ext"
    },
    {
      "id": "qml.device.preprocess.decompose.",
      "name": "qml.device.preprocess.decompose.",
      "type": "function",
      "description": "PennyLane API: device.preprocess.decompose.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ompose, decomposing operators in PennyLane had to be done by specifying a stopping_condition in qml.device.preprocess.decompose. With qml.transforms.decompose, the user-interface for specifying decomp"
    },
    {
      "id": "qml.devices.qubit",
      "name": "qml.devices.qubit",
      "type": "function",
      "description": "PennyLane API: devices.qubit. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "re. MidMeasureMP is now renamed to MidMeasure. qml.measurements.find_post_processed_mcms is now qml.devices.qubit.simulate._find_post_processed_mcms, and is being made private, as it is an utility for"
    },
    {
      "id": "qml.devices.experimental.DefaultQubit2",
      "name": "qml.devices.experimental.DefaultQubit2",
      "type": "function",
      "description": "PennyLane API: devices.experimental.DefaultQubit2. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ations, tape.measurements, shots=new_shots)     return (new_tape, ), null_postprocessing  dev = qml.devices.experimental.DefaultQubit2()  @partial(scale_shots, shot_scaling=2) @qml.qnode(dev, interfac"
    },
    {
      "id": "qml.LieAlgebraOptimizer",
      "name": "qml.LieAlgebraOptimizer",
      "type": "class",
      "description": "PennyLane API: LieAlgebraOptimizer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "decomposition and xyx_decomposition have been removed. Use one_qubit_decomposition instead. (#4301) LieAlgebraOptimizer has been removed. Use RiemannianGradientOptimizer instead. (#4301) Operation.bas"
    },
    {
      "id": "qml.operation.has_multipar",
      "name": "qml.operation.has_multipar",
      "type": "function",
      "description": "PennyLane API: operation.has_multipar. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n expansion function that decomposes all trainable, multi-parameter operations: >>> stop_at = ~(qml.operation.has_multipar & qml.operation.is_trainable) >>> expand_fn = qml.transforms.create_expand_fn"
    },
    {
      "id": "qml.map",
      "name": "qml.map",
      "type": "function",
      "description": "PennyLane API: map. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "osition'. (#8390) # New default behaviour (estimator mode) >>> qml.to_bloq(qml.QFT(wires=range(5)), map_ops=False).call_graph()[1] {Hadamard(): 5, CNOT(): 26, TGate(is_adjoint=False): 1320}  # Previou"
    },
    {
      "id": "qml.measurements.MeasurementValue",
      "name": "qml.measurements.MeasurementValue",
      "type": "function",
      "description": "PennyLane API: measurements.MeasurementValue. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rces. See pennylane.decomposition for more details. qml.measure, qml.measurements.MidMeasureMP, qml.measurements.MeasurementValue, and qml.measurements.get_mcm_predicates are now located in qml.ops.mi"
    },
    {
      "id": "qml.ops.Conditional.",
      "name": "qml.ops.Conditional.",
      "type": "function",
      "description": "PennyLane API: ops.Conditional.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ransforms folder to the ops/op_math folder. qml.transforms.Conditional will now be available as qml.ops.Conditional. (#4860) The prep keyword argument has been removed from QuantumScript and QuantumTa"
    },
    {
      "id": "qml.ControlledQutritUnitary.",
      "name": "qml.ControlledQutritUnitary.",
      "type": "class",
      "description": "PennyLane API: ControlledQutritUnitary.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "   >>> circuit() -0.42264973081037416    Controlled qutrit operations can now be performed with qml.ControlledQutritUnitary. (#2844) The control wires and values that define the operation are defined "
    },
    {
      "id": "qml.sample.",
      "name": "qml.sample.",
      "type": "function",
      "description": "PennyLane API: sample.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "r the default.tensor device has been added. (#5719) A small typo was fixed in the docstring for qml.sample. (#5685) Typesetting for some of the documentation was fixed, (use of left/right delimiters, "
    },
    {
      "id": "qml.operation.WiresEnum.AllWires",
      "name": "qml.operation.WiresEnum.AllWires",
      "type": "function",
      "description": "PennyLane API: operation.WiresEnum.AllWires. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " one with only numpy parameters. This transform is designed to replace qml.tape.Unwrap. (#3899) qml.operation.WiresEnum.AllWires is now -2 instead of 0 to avoid the ambiguity between op.num_wires = 0 "
    },
    {
      "id": "qml.ops.ctrl_decomp_bisect",
      "name": "qml.ops.ctrl_decomp_bisect",
      "type": "function",
      "description": "PennyLane API: ops.ctrl_decomp_bisect. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " # the decomposition does not un-queue the target         target = qml.RX(np.pi/2, wires=0)     qml.ops.ctrl_decomp_bisect(target, (1, 2, 3, 4, 5))     return qml.state()  print(qml.draw(circuit, expa"
    },
    {
      "id": "qml.liealg.op_to_adjvec.",
      "name": "qml.liealg.op_to_adjvec.",
      "type": "function",
      "description": "PennyLane API: liealg.op_to_adjvec.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "abs.adjvec_to_op has moved to qml.liealg.adjvec_to_op. pennylane.labs.op_to_adjvec has moved to qml.liealg.op_to_adjvec. pennylane.labs.change_basis_ad_rep has moved to qml.liealg.change_basis_ad_rep."
    },
    {
      "id": "qml.PauliSentence",
      "name": "qml.PauliSentence",
      "type": "class",
      "description": "PennyLane API: PauliSentence. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "arget ops. (#8133) Fixed a bug that made the queueing behaviour of qml.PauliWord.operation and qmle.PauliSentence.operation depndent on the global state of a program due to a caching issue. (#8135) A "
    },
    {
      "id": "qml.QFT.",
      "name": "qml.QFT.",
      "type": "class",
      "description": "PennyLane API: QFT.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ich can be found in the estimator module. For example, the lightweight representation of QFT is qre.QFT. By simply specifying the number of wires it acts on, we can obtain resource estimates: >>> qft "
    },
    {
      "id": "qml.qchem.vibrational",
      "name": "qml.qchem.vibrational",
      "type": "function",
      "description": "PennyLane API: qchem.vibrational. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", 0.0, -0.40277116], [0.0, 0.0, 1.40277116]]) mol = qml.qchem.Molecule(symbols, geometry) pes = qml.qchem.vibrational_pes(mol, optimize=False) ham = qml.qchem.vibrational.christiansen_hamiltonian(pes,"
    },
    {
      "id": "qml.liealg.adjvec_to_op.",
      "name": "qml.liealg.adjvec_to_op.",
      "type": "function",
      "description": "PennyLane API: liealg.adjvec_to_op.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ll involution functions have been moved to qml.liealg. pennylane.labs.adjvec_to_op has moved to qml.liealg.adjvec_to_op. pennylane.labs.op_to_adjvec has moved to qml.liealg.op_to_adjvec. pennylane.lab"
    },
    {
      "id": "qml.tape.QuantumTape.stop_recording",
      "name": "qml.tape.QuantumTape.stop_recording",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape.stop_recording. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "pe.adjoint() instead qml.tape.stop_recording(): Use qml.QueuingManager.stop_recording() instead qml.tape.QuantumTape.stop_recording(): Use qml.QueuingManager.stop_recording() instead qml.QueuingContex"
    },
    {
      "id": "qml.collections",
      "name": "qml.collections",
      "type": "function",
      "description": "PennyLane API: collections. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " it is easier to build large algorithms and circuits by applying gates and operations to predefined collections of wires. With qml.registers, you can create registers of wires by providing a dictionar"
    },
    {
      "id": "qml.fermi.FermiWord",
      "name": "qml.fermi.FermiWord",
      "type": "function",
      "description": "PennyLane API: fermi.FermiWord. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "w unit tested to ensure jit compatibility. (#6309)  Various improvements to fermionic operators qml.fermi.FermiWord and qml.fermi.FermiSentence are now compatible with JAX arrays. (#6324) Fermionic op"
    },
    {
      "id": "qml.TTN.",
      "name": "qml.TTN.",
      "type": "class",
      "description": "PennyLane API: TTN.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "res[0])     qml.RY(weights[1], wires=wires[1])  n_block_wires = 2 n_params_block = 2 n_blocks = qml.TTN.get_n_blocks(range(n_wires), n_block_wires) template_weights = [[0.1, -0.3]] * n_blocks  @qml.qn"
    },
    {
      "id": "qml.qnodes.PassthruQNode.",
      "name": "qml.qnodes.PassthruQNode.",
      "type": "function",
      "description": "PennyLane API: qnodes.PassthruQNode.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " = tf.keras.models.Sequential([qlayer, tf.keras.layers.Dense(2)])    Added a new type of QNode, qml.qnodes.PassthruQNode. For simulators which are coded in an external library which supports automatic"
    },
    {
      "id": "qml.devices.experimental.Device",
      "name": "qml.devices.experimental.Device",
      "type": "function",
      "description": "PennyLane API: devices.experimental.Device. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e any issue, say using JAX, TensorFlow, Torch, try setting max_workers to None. (#4319) (#4425) qml.devices.experimental.Device now accepts a shots keyword argument and has a shots property. This prop"
    },
    {
      "id": "qml.PauliErrors.",
      "name": "qml.PauliErrors.",
      "type": "class",
      "description": "PennyLane API: PauliErrors.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "correct Wires object as for all other operations in PennyLane. (#7647) qml.equal now works with qml.PauliErrors. (#7618) The qml.transforms.cancel_inverses transform can now be used with jax.jit. (#74"
    },
    {
      "id": "qml.ops.LinearCombination.",
      "name": "qml.ops.LinearCombination.",
      "type": "function",
      "description": "PennyLane API: ops.LinearCombination.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", and qml.operation.convert_to_legacy_H. Note that qml.Hamiltonian will continue to dispatch to qml.ops.LinearCombination. For more information, check out the updated operator troubleshooting page. (#"
    },
    {
      "id": "qml.utils._inv_dict",
      "name": "qml.utils._inv_dict",
      "type": "function",
      "description": "PennyLane API: utils._inv_dict. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ed and renamed to qml.optimize.qng._flatten_np and qml.optimize.qng._unflatten_np respectively. qml.utils._inv_dict and qml._get_default_args have been removed. qml.utils.pauli_eigs has been moved to "
    },
    {
      "id": "qml.from_qiskit.",
      "name": "qml.from_qiskit.",
      "type": "function",
      "description": "PennyLane API: from_qiskit.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "argument to specify a list of measurements to be performed at the end of the circuit, just like qml.from_qiskit. (#5818) Four new operators have been added for simulating noise on the default.qutrit.m"
    },
    {
      "id": "qml.qinfo.mutual_info",
      "name": "qml.qinfo.mutual_info",
      "type": "function",
      "description": "PennyLane API: qinfo.mutual_info. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "(np.pi/2) [[0.5+0.j 0.+0.j]   [0.+0.j 0.5+0.j]]    Similar transforms, qml.qinfo.vn_entropy and qml.qinfo.mutual_info exist for transforming QNodes.  Currently, all quantum information measurements an"
    },
    {
      "id": "qml.labs.Resources",
      "name": "qml.labs.Resources",
      "type": "function",
      "description": "PennyLane API: labs.Resources. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "een added to map PennyLane Operations to their resource equivalents. (#7434) A new class called qml.labs.Resources has been added to store and track the quantum resources from a circuit. (#7406) A new"
    },
    {
      "id": "qml.grouping",
      "name": "qml.grouping",
      "type": "function",
      "description": "PennyLane API: grouping. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ltonian of a product formula.   The perturbation_error has been optimized for better performance by grouping commutators by linearity and by using a task-based executor to parallelize the computationa"
    },
    {
      "id": "qml.proc.ones_like",
      "name": "qml.proc.ones_like",
      "type": "function",
      "description": "PennyLane API: proc.ones_like. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rk, allowing for end-to-end differentiation to be preserved. >>> x = torch.tensor([1., 2.]) >>> qml.proc.ones_like(x) tensor([1, 1]) >>> y = tf.Variable([[0], [5]]) >>> qml.proc.ones_like(y, dtype=np."
    },
    {
      "id": "qml.labs.zxopt.basic_optimization",
      "name": "qml.labs.zxopt.basic_optimization",
      "type": "function",
      "description": "PennyLane API: labs.zxopt.basic_optimization. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "pt.full_reduce, use reduce_non_clifford() Instead of qml.labs.zxopt.todd, use todd() Instead of qml.labs.zxopt.basic_optimization, use push_hadamards() (#8177)    Breaking changes 💔 autoray  has been "
    },
    {
      "id": "qml.grouping.is_pauli_word",
      "name": "qml.grouping.is_pauli_word",
      "type": "function",
      "description": "PennyLane API: grouping.is_pauli_word. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "atrix and sparse matrix are computed using a kronecker product for improved efficiency. (#3040) qml.grouping.is_pauli_word now returns False for operators that don’t inherit from qml.Observable instea"
    },
    {
      "id": "qml.math.fft.",
      "name": "qml.math.fft.",
      "type": "function",
      "description": "PennyLane API: math.fft.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "y and interfaces The qml.math module now also contains a submodule for fast Fourier transforms, qml.math.fft. (#1440) The submodule in particular provides differentiable versions of the following func"
    },
    {
      "id": "qml.iterative_qpe.",
      "name": "qml.iterative_qpe.",
      "type": "function",
      "description": "PennyLane API: iterative_qpe.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "pproach for quantum phase estimation 🔄 Iterative Quantum Phase Estimation is now available with qml.iterative_qpe. (#4804) The subroutine can be used similarly to mid-circuit measurements: import penn"
    },
    {
      "id": "qml.samples",
      "name": "qml.samples",
      "type": "function",
      "description": "PennyLane API: samples. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ple() function can now receive an optional dtype parameter which sets the type and precision of the samples returned by this measurement process. (#8189) (#8271) DefaultQubit will now default to the t"
    },
    {
      "id": "qml.transforms.core.transform",
      "name": "qml.transforms.core.transform",
      "type": "function",
      "description": "PennyLane API: transforms.core.transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " have been updated to “compile pipeline” across the codebase. Correspondingly, the module pennylane.transforms.core.transform_program has been renamed to pennylane.transforms.core.compile_pipeline, an"
    },
    {
      "id": "qml.PauliWord.operation",
      "name": "qml.PauliWord.operation",
      "type": "class",
      "description": "PennyLane API: PauliWord.operation. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " when there are complicated target ops. (#8133) Fixed a bug that made the queueing behaviour of qml.PauliWord.operation and qmle.PauliSentence.operation depndent on the global state of a program due t"
    },
    {
      "id": "qml.operation.expand_matrix.",
      "name": "qml.operation.expand_matrix.",
      "type": "function",
      "description": "PennyLane API: operation.expand_matrix.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "sity_matrix measurements now support custom wire labels. (#2779) Add trivial behaviour logic to qml.operation.expand_matrix. (#2785) Added an are_pauli_words_qwc function which checks if certain Pauli"
    },
    {
      "id": "qml.T._matrix",
      "name": "qml.T._matrix",
      "type": "class",
      "description": "PennyLane API: T._matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ed operation). (#1069) (#1104) For example, we can  create a multi-controlled T gate using: T = qml.T._matrix() qml.ControlledQubitUnitary(T, control_wires=[0, 1, 3], wires=2, control_values=\"110\")   "
    },
    {
      "id": "qml.OutAdder.",
      "name": "qml.OutAdder.",
      "type": "class",
      "description": "PennyLane API: OutAdder.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " (#6278) (#6310) Fixed a bug where None was added to the wires in qml.PhaseAdder, qml.Adder and qml.OutAdder. (#6360) Fixed a test after updating to the nightly version of Catalyst. (#6362) Fixed a bu"
    },
    {
      "id": "qml.QueuingContext.",
      "name": "qml.QueuingContext.",
      "type": "class",
      "description": "PennyLane API: QueuingContext.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nager. Recording queues should start and stop recording via the QueuingManager.add_active_queue and QueuingContext.remove_active_queue class methods instead of directly manipulating the _active_contex"
    },
    {
      "id": "qml.labs.estimate_resources",
      "name": "qml.labs.estimate_resources",
      "type": "function",
      "description": "PennyLane API: labs.estimate_resources. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " for resource estimation. (#7399) (#7526) (#7540) (#7541) (#7584) (#7549) A new function called qml.labs.estimate_resources has been added which will be used to perform resource estimation on circuits"
    },
    {
      "id": "qml.map_wires.",
      "name": "qml.map_wires.",
      "type": "function",
      "description": "PennyLane API: map_wires.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "put. (#8080) Unnecessary execution tests along with accuracy validation in tests/ops/functions/test_map_wires.py were removed due to stochastic failures. (#8032) A new all-tests-passed gatekeeper job "
    },
    {
      "id": "qml.estimator.Resources",
      "name": "qml.estimator.Resources",
      "type": "function",
      "description": "PennyLane API: estimator.Resources. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "5)  Resource estimation Added Resources.total_wires and Resources.total_gates properties to the qml.estimator.Resources class. Users can more easily access these quantities from the Resources object d"
    },
    {
      "id": "qml.is_unitary.",
      "name": "qml.is_unitary.",
      "type": "function",
      "description": "PennyLane API: is_unitary.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "with v0.26.  Check whether or not an operator is hermitian or unitary with qml.is_hermitian and qml.is_unitary. (#2960) >>> op1 = qml.PauliX(wires=0) >>> qml.is_hermitian(op1) True >>> op2 = qml.Pauli"
    },
    {
      "id": "qml.qchem.taper",
      "name": "qml.qchem.taper",
      "type": "function",
      "description": "PennyLane API: qchem.taper. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rs when there is a Pauli representation. (#6871) qml.pauli.PauliVSpace is now iterable. (#7054) qml.qchem.taper now handles wire ordering for the tapered observables more robustly. (#6954) A RuntimeWa"
    },
    {
      "id": "qml.devices.DefaultQubit.",
      "name": "qml.devices.DefaultQubit.",
      "type": "function",
      "description": "PennyLane API: devices.DefaultQubit.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "_metric_tensor now uses the simulation tools in qml.devices.qubit instead of private methods of qml.devices.DefaultQubit. (#4456) Auxiliary wires and device wires are now treated the same way in qml.t"
    },
    {
      "id": "qml.BasisStatePreparation",
      "name": "qml.BasisStatePreparation",
      "type": "class",
      "description": "PennyLane API: BasisStatePreparation. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ument for qml.iterative_qpe has been removed. Instead, use the 'aux_wire' argument. (#6532) The qml.BasisStatePreparation template has been removed. Instead, use qml.BasisState. (#6528) The qml.workfl"
    },
    {
      "id": "qml.pauli.PauliSentence.hamiltonian",
      "name": "qml.pauli.PauliSentence.hamiltonian",
      "type": "function",
      "description": "PennyLane API: pauli.PauliSentence.hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ted. For more information, check out the updated operator troubleshooting page. (#6287) (#6365) qml.pauli.PauliSentence.hamiltonian and qml.pauli.PauliWord.hamiltonian have been deprecated. Instead, p"
    },
    {
      "id": "qml.GlobalPhase.sparse_matrix",
      "name": "qml.GlobalPhase.sparse_matrix",
      "type": "class",
      "description": "PennyLane API: GlobalPhase.sparse_matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ". (#7025) qml.capture.PlxprInterpreter now flattens pytree arguments before evaluation. (#6975) qml.GlobalPhase.sparse_matrix now correctly returns a sparse matrix of the same shape as matrix. (#6940)"
    },
    {
      "id": "qml.eigvals.",
      "name": "qml.eigvals.",
      "type": "function",
      "description": "PennyLane API: eigvals.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "dded. (#5083) A note about the eigenspectrum of second-quantized Hamiltonians has been added to qml.eigvals. (#5095) A warning about two mathematically equivalent Hamiltonians undergoing different tim"
    },
    {
      "id": "qml.ops.qubit.non_parametric_ops",
      "name": "qml.ops.qubit.non_parametric_ops",
      "type": "function",
      "description": "PennyLane API: ops.qubit.non_parametric_ops. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "w parameters without mutating the original operator. (#4113) (#4256) qml.CY has been moved from qml.ops.qubit.non_parametric_ops to qml.ops.op_math.controlled_ops and now inherits from qml.ops.op_math"
    },
    {
      "id": "qml.devices.qubit.preprocess",
      "name": "qml.devices.qubit.preprocess",
      "type": "function",
      "description": "PennyLane API: devices.qubit.preprocess. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "l.draw_mpl uses the current style set from qml.drawer.use_style instead of black_white. (#4357) qml.devices.qubit.preprocess.validate_and_expand_adjoint no longer sets the trainable parameters of the "
    },
    {
      "id": "qml.ResourcePhaseGradient",
      "name": "qml.ResourcePhaseGradient",
      "type": "class",
      "description": "PennyLane API: ResourcePhaseGradient. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " Hamiltonian development and resource estimation have been added: qml.ResourceOutOfPlaceSquare, qml.ResourcePhaseGradient, qml.ResourceOutMultiplier, qml.ResourceSemiAdder, qml.ResourceBasisRotation, "
    },
    {
      "id": "qml.Wires.select_random",
      "name": "qml.Wires.select_random",
      "type": "class",
      "description": "PennyLane API: Wires.select_random. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "metadata to have an \"owner\". (#3282) qml.qchem.scf, qml.RandomLayers.compute_decomposition, and qml.Wires.select_random now use local random number generators instead of global random number generator"
    },
    {
      "id": "qml.templates.Interferometer.",
      "name": "qml.templates.Interferometer.",
      "type": "function",
      "description": "PennyLane API: templates.Interferometer.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rometer has been renamed qml.InterferometerUnitary in order to distinguish it from the template qml.templates.Interferometer. (#1714) The qml.transforms.invisible decorator has been replaced with qml."
    },
    {
      "id": "qml.workflow.construct_batch.expand_fn_transform",
      "name": "qml.workflow.construct_batch.expand_fn_transform",
      "type": "function",
      "description": "PennyLane API: workflow.construct_batch.expand_fn_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "produces incorrect results where the correlation between measurements is not preserved. (#8411) qml.workflow.construct_batch.expand_fn_transform has been deleted as it was no longer getting used. (#83"
    },
    {
      "id": "qml.transforms.decompositions.clifford_t_decomposition",
      "name": "qml.transforms.decompositions.clifford_t_decomposition",
      "type": "function",
      "description": "PennyLane API: transforms.decompositions.clifford_t_decomposition. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "20)  Deprecations 👋 The expand_depth and max_expansion arguments for qml.transforms.compile and qml.transforms.decompositions.clifford_t_decomposition respectively have been deprecated. (#6404) Legacy"
    },
    {
      "id": "qml.ResourceQROM.",
      "name": "qml.ResourceQROM.",
      "type": "class",
      "description": "PennyLane API: ResourceQROM.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "esourceOutMultiplier, qml.ResourceSemiAdder, qml.ResourceBasisRotation, qml.ResourceSelect, and qml.ResourceQROM. (#7725) A new module called qml.labs.zxopt has been added to provide access to the bas"
    },
    {
      "id": "qml.transforms.insert",
      "name": "qml.transforms.insert",
      "type": "function",
      "description": "PennyLane API: transforms.insert. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ance of qml.qchem.Molecule is now more concise and informational. (#3364) The error message for qml.transforms.insert when it fails to diagonalize non-qubit-wise-commuting observables is now more deta"
    },
    {
      "id": "qml.Reflection.",
      "name": "qml.Reflection.",
      "type": "class",
      "description": "PennyLane API: Reflection.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ify the \\(\\vert 2 \\rangle\\) state.  Reflecting about a given quantum state is now available via qml.Reflection. This operation is very useful in the amplitude amplification algorithm and offers a gene"
    },
    {
      "id": "qml.ApproxTimeEvolution.",
      "name": "qml.ApproxTimeEvolution.",
      "type": "class",
      "description": "PennyLane API: ApproxTimeEvolution.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "lent Hamiltonians undergoing different time evolutions has been added to qml.TrotterProduct and qml.ApproxTimeEvolution. (#5137) A reference to the paper that provides the image of the qml.QAOAEmbeddi"
    },
    {
      "id": "qml.qaoa.cycle",
      "name": "qml.qaoa.cycle",
      "type": "function",
      "description": "PennyLane API: qaoa.cycle. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " 2), 2: (1, 0), 3: (1, 2), 4: (2, 0), 5: (2, 1)}   Additional functionality can be found in the qml.qaoa.cycle module.   Extended operations and templates Added functionality to compute the sparse mat"
    },
    {
      "id": "qml.ops.qutrit.validate_subspace",
      "name": "qml.ops.qutrit.validate_subspace",
      "type": "function",
      "description": "PennyLane API: ops.qutrit.validate_subspace. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "s.obs.data instead. (#5321) Operator.validate_subspace(subspace) has been removed. Instead, use qml.ops.qutrit.validate_subspace(subspace). (#5311) The contents of qml.interfaces has been moved inside"
    },
    {
      "id": "qml.hf",
      "name": "qml.hf",
      "type": "function",
      "description": "PennyLane API: hf. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " qml.qchem.molecular_dipole function has been added for calculating the dipole operator using the \"dhf\" and \"openfermion\" backends. (#5764) The qchem module now has dedicated functions for calling the"
    },
    {
      "id": "qml.qaoa.x_mixer",
      "name": "qml.qaoa.x_mixer",
      "type": "function",
      "description": "PennyLane API: qaoa.x_mixer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "the new qml.qaoa module. (#712) (#718) (#741) (#720) This includes the following features:  New qml.qaoa.x_mixer and qml.qaoa.xy_mixer functions for defining Pauli-X and XY mixer Hamiltonians. MaxCut:"
    },
    {
      "id": "qml.devices.DefaultQubitLegacy.",
      "name": "qml.devices.DefaultQubitLegacy.",
      "type": "function",
      "description": "PennyLane API: devices.DefaultQubitLegacy.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rsion of the device is still accessible by the short name default.qubit.legacy, or directly via qml.devices.DefaultQubitLegacy. (#4594) (#4436) (#4620) (#4632) This changeover has a number of benefits"
    },
    {
      "id": "qml.ResourceOutMultiplier",
      "name": "qml.ResourceOutMultiplier",
      "type": "class",
      "description": "PennyLane API: ResourceOutMultiplier. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d resource estimation have been added: qml.ResourceOutOfPlaceSquare, qml.ResourcePhaseGradient, qml.ResourceOutMultiplier, qml.ResourceSemiAdder, qml.ResourceBasisRotation, qml.ResourceSelect, and qml"
    },
    {
      "id": "qml.math.vn_entropy.",
      "name": "qml.math.vn_entropy.",
      "type": "function",
      "description": "PennyLane API: math.vn_entropy.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " URL in the qml.qchem.mol_data docstring. (#3644) A typo was corrected in the documentation for qml.math.vn_entropy. (#3740)  Bug fixes 🐛 Fixed a bug where measuring qml.probs in the computational bas"
    },
    {
      "id": "qml.labs.vibrational.christiansen_hamiltonian",
      "name": "qml.labs.vibrational.christiansen_hamiltonian",
      "type": "function",
      "description": "PennyLane API: labs.vibrational.christiansen_hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".0]]) >>> mol = qml.qchem.Molecule(symbols, geometry) >>> pes = vibrational_pes(mol)    Use the qml.labs.vibrational.christiansen_hamiltonian function and potential energy surfaces to generate Hamilto"
    },
    {
      "id": "qml.split_non_commuting",
      "name": "qml.split_non_commuting",
      "type": "function",
      "description": "PennyLane API: split_non_commuting. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "other discretization schemes. (#8213) A new keyword argument called shot_dist has been added to the split_non_commuting() transform. This allows for more customization and efficiency when calculating "
    },
    {
      "id": "qml.shadow_expval.",
      "name": "qml.shadow_expval.",
      "type": "function",
      "description": "PennyLane API: shadow_expval.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "471) The default.qubit device now supports parameter broadcasting with qml.classical_shadow and qml.shadow_expval. (#6301) Fixed unnecessary call of eigvals in qml.ops.op_math.decompositions.two_qubit"
    },
    {
      "id": "qml.expval.",
      "name": "qml.expval.",
      "type": "function",
      "description": "PennyLane API: expval.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e default.qubit device now supports parameter broadcasting with qml.classical_shadow and qml.shadow_expval. (#6301) Fixed unnecessary call of eigvals in qml.ops.op_math.decompositions.two_qubit_unitar"
    },
    {
      "id": "qml.liealg.check_cartan_decomp.",
      "name": "qml.liealg.check_cartan_decomp.",
      "type": "function",
      "description": "PennyLane API: liealg.check_cartan_decomp.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", m] ⊆ k that make them a proper Cartan decomposition. These can be verified using the function qml.liealg.check_cartan_decomp. >>> qml.liealg.check_cartan_decomp(k, m) True    The horizontal Cartan s"
    },
    {
      "id": "qml.circuit_drawer.tape_mpl",
      "name": "qml.circuit_drawer.tape_mpl",
      "type": "function",
      "description": "PennyLane API: circuit_drawer.tape_mpl. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tions. (#1873) >>> op = qml.PhaseShift(0.3, wires=0) >>> op.decompose() [RZ(0.3, wires=[0])]    qml.circuit_drawer.tape_mpl produces a matplotlib figure and axes given a tape. (#1787) The AngleEmbeddi"
    },
    {
      "id": "qml.devices.qubit.preprocess.validate_and_expand_adjoint",
      "name": "qml.devices.qubit.preprocess.validate_and_expand_adjoint",
      "type": "function",
      "description": "PennyLane API: devices.qubit.preprocess.validate_and_expand_adjoint. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "l.draw_mpl uses the current style set from qml.drawer.use_style instead of black_white. (#4357) qml.devices.qubit.preprocess.validate_and_expand_adjoint no longer sets the trainable parameters of the "
    },
    {
      "id": "qml.pauli.utils.",
      "name": "qml.pauli.utils.",
      "type": "function",
      "description": "PennyLane API: pauli.utils.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "s._inv_dict and qml._get_default_args have been removed. qml.utils.pauli_eigs has been moved to qml.pauli.utils. qml.utils.expand_vector has been moved to qml.math.expand_vector.   The qml.qinfo modul"
    },
    {
      "id": "qml.H.",
      "name": "qml.H.",
      "type": "class",
      "description": "PennyLane API: H.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".operation.enable_new_opmath, qml.operation.disable_new_opmath, and qml.operation.convert_to_legacy_H. Note that qml.Hamiltonian will continue to dispatch to qml.ops.LinearCombination. For more inform"
    },
    {
      "id": "qml.ResourceBasisRotation",
      "name": "qml.ResourceBasisRotation",
      "type": "class",
      "description": "PennyLane API: ResourceBasisRotation. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "eOutOfPlaceSquare, qml.ResourcePhaseGradient, qml.ResourceOutMultiplier, qml.ResourceSemiAdder, qml.ResourceBasisRotation, qml.ResourceSelect, and qml.ResourceQROM. (#7725) A new module called qml.lab"
    },
    {
      "id": "qml.ops.Controlled.has_sparse_matrix",
      "name": "qml.ops.Controlled.has_sparse_matrix",
      "type": "function",
      "description": "PennyLane API: ops.Controlled.has_sparse_matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "w correctly extracts the \"scipy\" interface if provided a list/array of sparse matrices. (#7015) qml.ops.Controlled.has_sparse_matrix now provides the correct information by checking if the target oper"
    },
    {
      "id": "qml.templates.BasicEntanglerLayers.shape",
      "name": "qml.templates.BasicEntanglerLayers.shape",
      "type": "function",
      "description": "PennyLane API: templates.BasicEntanglerLayers.shape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ")     return qml.expval(qml.PauliZ(0) @ qml.PauliY(1) @ qml.PauliX(2) @ qml.PauliZ(3))  shape = qml.templates.BasicEntanglerLayers.shape(5, n_wires) params = np.random.random(shape)   >>> expval_circu"
    },
    {
      "id": "qml.templates.TwoLocalSwapNetwork.shape",
      "name": "qml.templates.TwoLocalSwapNetwork.shape",
      "type": "function",
      "description": "PennyLane API: templates.TwoLocalSwapNetwork.shape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ":1905.05118. (#3447) dev = qml.device('default.qubit', wires=5) weights = np.random.random(size=qml.templates.TwoLocalSwapNetwork.shape(len(dev.wires))) acquaintances = lambda index, wires, param: (qm"
    },
    {
      "id": "qml.qinfo.purity",
      "name": "qml.qinfo.purity",
      "type": "function",
      "description": "PennyLane API: qinfo.purity. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "328) A warning is now raised if control indicators are hidden when calling qml.draw_mpl (#4295) qml.qinfo.purity now produces correct results with custom wire labels. (#4331) default.qutrit now suppor"
    },
    {
      "id": "qml.operator.active_new_opmath",
      "name": "qml.operator.active_new_opmath",
      "type": "function",
      "description": "PennyLane API: operator.active_new_opmath. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " where op is an Operator instance, now returns operators consistent with the global setting for qml.operator.active_new_opmath() wherever possible. Sum, SProd and Prod instances will be returned even "
    },
    {
      "id": "qml.QubitStateVector.",
      "name": "qml.QubitStateVector.",
      "type": "class",
      "description": "PennyLane API: QubitStateVector.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ser-defined QNode arguments. (#3765) Operators now use TensorLike types dunder methods. (#3749) qml.QubitStateVector.state_vector now supports broadcasting. (#3852) qml.SparseHamiltonian can now be ap"
    },
    {
      "id": "qml.Hermitian.",
      "name": "qml.Hermitian.",
      "type": "class",
      "description": "PennyLane API: Hermitian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "perty can instead be used to check whether or not it is highly likely that the operator instance is Hermitian. (#7927) qml.operation.WiresEnum, qml.operation.AllWires, and qml.operation.AnyWires have "
    },
    {
      "id": "qml.resource.FirstQuantization.qubit_cost",
      "name": "qml.resource.FirstQuantization.qubit_cost",
      "type": "function",
      "description": "PennyLane API: resource.FirstQuantization.qubit_cost. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "bits) and gate_cost (number of non-Clifford gates), can be also accessed as static methods: >>> qml.resource.FirstQuantization.qubit_cost(100000, 156, 169.69608, 0.01) 4377 >>> qml.resource.FirstQuant"
    },
    {
      "id": "qml.Operator",
      "name": "qml.Operator",
      "type": "class",
      "description": "PennyLane API: Operator. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "kflows Quantum Chemistry Quantum Datasets Logging  Release news  Release notes Deprecations Updated Operators Program capture sharp bits  Development  Development guide Building a plugin Adding new op"
    },
    {
      "id": "qml.queuing.Queue",
      "name": "qml.queuing.Queue",
      "type": "function",
      "description": "PennyLane API: queuing.Queue. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "eating empty Tensor objects. (#2678) PennyLane no longer supports TensorFlow <=2.3. (#2683) The qml.queuing.Queue class has been removed. (#2599) The qml.utils.expand function is now removed; qml.oper"
    },
    {
      "id": "qml.fermi.FermiSentence",
      "name": "qml.fermi.FermiSentence",
      "type": "function",
      "description": "PennyLane API: fermi.FermiSentence. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "jit compatibility. (#6309)  Various improvements to fermionic operators qml.fermi.FermiWord and qml.fermi.FermiSentence are now compatible with JAX arrays. (#6324) Fermionic operators interacting, in "
    },
    {
      "id": "qml.qnn.KerasLayer",
      "name": "qml.qnn.KerasLayer",
      "type": "function",
      "description": "PennyLane API: qnn.KerasLayer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "thod, along with its private helper _qsp_to_qsvt, has been removed. (#6827)  Deprecations 👋 The qml.qnn.KerasLayer class has been deprecated because Keras 2 is no longer actively maintained. Please co"
    },
    {
      "id": "qml.ops.Sum.",
      "name": "qml.ops.Sum.",
      "type": "function",
      "description": "PennyLane API: ops.Sum.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "uring construction using the grouping_type and method keyword arguments of qml.dot, qml.sum, or qml.ops.Sum. The grouping indices are stored in Sum.grouping_indices. (#5179) a = qml.X(0) b = qml.prod("
    },
    {
      "id": "qml.transforms.poly_extrapolate",
      "name": "qml.transforms.poly_extrapolate",
      "type": "function",
      "description": "PennyLane API: transforms.poly_extrapolate. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "our QNode and provide the PennyLane proprietary qml.transforms.fold_global folding function and qml.transforms.poly_extrapolate extrapolation function. Here is an example for a noisy simulation device"
    },
    {
      "id": "qml.PyTrees",
      "name": "qml.PyTrees",
      "type": "class",
      "description": "PennyLane API: PyTrees. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "     Capturing and representing hybrid programs A number of templates have been updated to be valid PyTrees and PennyLane operations. (#5698) PennyLane operators, measurements, and QNodes can now auto"
    },
    {
      "id": "qml.templates.GateFabric",
      "name": "qml.templates.GateFabric",
      "type": "function",
      "description": "PennyLane API: templates.GateFabric. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "its)  dev = qml.device('default.qubit', wires=qubits)  @qml.qnode(dev) def ansatz(weights):     qml.templates.GateFabric(weights, wires=[0,1,2,3],                                 init_state=ref_state,"
    },
    {
      "id": "qml.qfunc_transform",
      "name": "qml.qfunc_transform",
      "type": "function",
      "description": "PennyLane API: qfunc_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d PauliSentences with more than one wire. (#5328) (#5359)   single_tape_transform, batch_transform, qfunc_transform, op_transform, gradient_transform and hessian_transform have been removed. Instead, "
    },
    {
      "id": "qml.tape.QuantumTape.shape",
      "name": "qml.tape.QuantumTape.shape",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape.shape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e Hamiltonian involved some wires that are not present on the device. (#3266) Fixed a bug where qml.tape.QuantumTape.shape() did not account for the batch dimension of the tape (#3269)  ContributorsTh"
    },
    {
      "id": "qml.transforms.batch_params",
      "name": "qml.transforms.batch_params",
      "type": "function",
      "description": "PennyLane API: transforms.batch_params. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "classical_fisher, and qml.qinfo.quantum_fisher to support the new return types. (#3449) Updated qml.transforms.batch_params and qml.transforms.batch_input to support the new return types. (#3431) Upda"
    },
    {
      "id": "qml.gradients.vjp.compute_vjp_single.",
      "name": "qml.gradients.vjp.compute_vjp_single.",
      "type": "function",
      "description": "PennyLane API: gradients.vjp.compute_vjp_single.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "correct decomposition. (#6021) Jacobian shape has been fixed for measurements with dimension in qml.gradients.vjp.compute_vjp_single. (5986) qml.lie_closure now works with sums of Paulis. (#6023) Work"
    },
    {
      "id": "qml.gradients.param_shift_hessian.",
      "name": "qml.gradients.param_shift_hessian.",
      "type": "function",
      "description": "PennyLane API: gradients.param_shift_hessian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ms are inconsistent with the QNode output shape. (#2215) Fixed a bug caused by the squeezing in qml.gradients.param_shift_hessian. (#2215) Fixed a bug in which the expval/var of a Tensor(Observable) w"
    },
    {
      "id": "qml.init.strong_ent_layers_uniform",
      "name": "qml.init.strong_ent_layers_uniform",
      "type": "function",
      "description": "PennyLane API: init.strong_ent_layers_uniform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " wires=2) H = qml.Hamiltonian([1., 2., 3.],  [qml.PauliZ(0), qml.PauliY(0), qml.PauliZ(1)]) w = qml.init.strong_ent_layers_uniform(1, 2, seed=1967)  @qml.qnode(dev) def circuit(w):     qml.templates.S"
    },
    {
      "id": "qml.tape.QuantumTape.inv",
      "name": "qml.tape.QuantumTape.inv",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape.inv. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "anager.active_context() instead qml.transforms.qcut.remap_tape_wires: Use qml.map_wires instead qml.tape.QuantumTape.inv(): Use qml.tape.QuantumTape.adjoint() instead qml.tape.stop_recording(): Use qm"
    },
    {
      "id": "qml.HilberSchmidt",
      "name": "qml.HilberSchmidt",
      "type": "class",
      "description": "PennyLane API: HilberSchmidt. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "plates to be used for computing distance measures between unitaries. (#2364) Given a unitary U, qml.HilberSchmidt can be used to measure the distance between unitaries and to define a cost function (c"
    },
    {
      "id": "qml.capture.transforms.CancelInterpreter",
      "name": "qml.capture.transforms.CancelInterpreter",
      "type": "function",
      "description": "PennyLane API: capture.transforms.CancelInterpreter. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ame API as the corresponding existing transforms in PennyLane when program capture is enabled:  qml.capture.transforms.CancelInterpreter:this class cancels operators appearing consecutively that are a"
    },
    {
      "id": "qml.CommutingEvolution.",
      "name": "qml.CommutingEvolution.",
      "type": "class",
      "description": "PennyLane API: CommutingEvolution.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "with operators whose generator was a Hamiltonian. (#2524) Fixed a bug with the decomposition of qml.CommutingEvolution. (#2542) Fixed a bug enabling PennyLane to work with the latest version of Autora"
    },
    {
      "id": "qml.transforms.invisible",
      "name": "qml.transforms.invisible",
      "type": "function",
      "description": "PennyLane API: transforms.invisible. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rUnitary in order to distinguish it from the template qml.templates.Interferometer. (#1714) The qml.transforms.invisible decorator has been replaced with qml.tape.stop_recording, which may act as a co"
    },
    {
      "id": "qml.labs.QubitManager",
      "name": "qml.labs.QubitManager",
      "type": "function",
      "description": "PennyLane API: labs.QubitManager. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "thesizes a possible implementation of the parity matrix that respects the connectivity. (#7394) qml.labs.QubitManager, qml.labs.AllocWires, and qml.labs.FreeWires classes have been added to track and "
    },
    {
      "id": "qml.compiler.python_compiler",
      "name": "qml.compiler.python_compiler",
      "type": "function",
      "description": "PennyLane API: compiler.python_compiler. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n has been removed from the new output format. (#8713) The unified compiler, implemented in the qml.compiler.python_compiler submodule, has been removed from PennyLane. It has been migrated to Catalys"
    },
    {
      "id": "qml.BasisState.",
      "name": "qml.BasisState.",
      "type": "class",
      "description": "PennyLane API: BasisState.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "x_wire' argument. (#6532) The qml.BasisStatePreparation template has been removed. Instead, use qml.BasisState. (#6528) The qml.workflow.set_shots helper function has been removed. We no longer intera"
    },
    {
      "id": "qml.QROM.",
      "name": "qml.QROM.",
      "type": "class",
      "description": "PennyLane API: QROM.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "utMultiplier, qml.ResourceSemiAdder, qml.ResourceBasisRotation, qml.ResourceSelect, and qml.ResourceQROM. (#7725) A new module called qml.labs.zxopt has been added to provide access to the basic optim"
    },
    {
      "id": "qml.math.reduce_statevector.",
      "name": "qml.math.reduce_statevector.",
      "type": "function",
      "description": "PennyLane API: math.reduce_statevector.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " (#4109) (#4187) Reduced density matrix functionality has been added via qml.math.reduce_dm and qml.math.reduce_statevector. Both functions have broadcasting support. (#4173) The following functions i"
    },
    {
      "id": "qml.transforms.zyz_decomposition",
      "name": "qml.transforms.zyz_decomposition",
      "type": "function",
      "description": "PennyLane API: transforms.zyz_decomposition. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e to functions qml.s_prod, qml.prod and qml.op_sum to allow simplification. (#3483) Updated the qml.transforms.zyz_decomposition function such that it now supports broadcast operators. This means that"
    },
    {
      "id": "qml.hf.transform_hf",
      "name": "qml.hf.transform_hf",
      "type": "function",
      "description": "PennyLane API: hf.transform_hf. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "1) >>> print(circ(op1), circ(op2)) -0.8636111153905662 -0.8636111153905662    Fixed a bug where qml.hf.transform_hf() would fail due to missing wires in the qubit operator that is prepared for taperin"
    },
    {
      "id": "qml.liealg.horizontal_cartan_subalgebra.",
      "name": "qml.liealg.horizontal_cartan_subalgebra.",
      "type": "function",
      "description": "PennyLane API: liealg.horizontal_cartan_subalgebra.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".check_cartan_decomp(k, m) True    The horizontal Cartan subalgebra a of m can be computed with qml.liealg.horizontal_cartan_subalgebra. from pennylane.liealg import horizontal_cartan_subalgebra newg,"
    },
    {
      "id": "qml.fermi.parity_transform",
      "name": "qml.fermi.parity_transform",
      "type": "function",
      "description": "PennyLane API: fermi.parity_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "prove performance for large workflows. (#5108)  Community contributions 🥳 A new function called qml.fermi.parity_transform has been added for parity mapping of a fermionic Hamiltonian. (#4928) It is n"
    },
    {
      "id": "qml.draw.",
      "name": "qml.draw.",
      "type": "function",
      "description": "PennyLane API: draw.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "it from PennyLane’s Catalyst library for just-in-time hybrid compilation is now compatible with qml.draw. (#4609) import catalyst  @catalyst.qjit @qml.qnode(qml.device(\"lightning.qubit\", wires=3)) def"
    },
    {
      "id": "qml.expval.Observable",
      "name": "qml.expval.Observable",
      "type": "function",
      "description": "PennyLane API: expval.Observable. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "icient for symmetric matrices than the previously used scipy.linalg.pinv. (#331) The deprecated qml.expval.Observable syntax has been removed. (#267) Remainder of the unittest-style tests were ported "
    },
    {
      "id": "qml.PrepSelPrep.",
      "name": "qml.PrepSelPrep.",
      "type": "class",
      "description": "PennyLane API: PrepSelPrep.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nnecessary controlled operations. The templates include Adder, Multiplier, OutAdder, OutMultiplier, PrepSelPrep. (#8207) Here, the optimization is demonstrated when Adder is controlled: qml.decomposit"
    },
    {
      "id": "qml.enable_tape",
      "name": "qml.enable_tape",
      "type": "function",
      "description": "PennyLane API: enable_tape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "This has no affect on import location. In addition,  All tape-mode functions have been removed (qml.enable_tape(), qml.tape_mode_active()), All tape fixtures have been deleted, Tests specifically for "
    },
    {
      "id": "qml.measurements.MidMeasureMP",
      "name": "qml.measurements.MidMeasureMP",
      "type": "function",
      "description": "PennyLane API: measurements.MidMeasureMP. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "functions with registered resources. See pennylane.decomposition for more details. qml.measure, qml.measurements.MidMeasureMP, qml.measurements.MeasurementValue, and qml.measurements.get_mcm_predicate"
    },
    {
      "id": "qml.OutPoly.",
      "name": "qml.OutPoly.",
      "type": "class",
      "description": "PennyLane API: OutPoly.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ulating Polynomials 🔢 Polynomial functions can now be easily encoded into quantum circuits with qml.OutPoly. (#6320) A new template called qml.OutPoly is available, which provides the ability to encod"
    },
    {
      "id": "qml.QutritBasisState.",
      "name": "qml.QutritBasisState.",
      "type": "class",
      "description": "PennyLane API: QutritBasisState.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nce(rho, sigma) 0.19999999999999998      It is now possible to prepare qutrit basis states with qml.QutritBasisState. (#4185) wires = range(2) dev = qml.device(\"default.qutrit\", wires=wires)  @qml.qno"
    },
    {
      "id": "qml._get_default_args",
      "name": "qml._get_default_args",
      "type": "function",
      "description": "PennyLane API: _get_default_args. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "timize.qng._flatten_np and qml.optimize.qng._unflatten_np respectively. qml.utils._inv_dict and qml._get_default_args have been removed. qml.utils.pauli_eigs has been moved to qml.pauli.utils. qml.uti"
    },
    {
      "id": "qml.structure_constants.",
      "name": "qml.structure_constants.",
      "type": "function",
      "description": "PennyLane API: structure_constants.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " Compute the structure constants that make up the adjoint representation of a Lie algebra using qml.structure_constants. This function accepts and outputs matrices when matrix=True. >>> adjoint_rep = "
    },
    {
      "id": "qml.qchem.symmetry_shift.",
      "name": "qml.qchem.symmetry_shift.",
      "type": "function",
      "description": "PennyLane API: qchem.symmetry_shift.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n for performing the block-invariant symmetry shift on electronic integrals has been added with qml.qchem.symmetry_shift. (#6574) The differentiable Hartree-Fock workflow is now compatible with JAX. ("
    },
    {
      "id": "qml.devices.qubit.",
      "name": "qml.devices.qubit.",
      "type": "function",
      "description": "PennyLane API: devices.qubit.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "re. MidMeasureMP is now renamed to MidMeasure. qml.measurements.find_post_processed_mcms is now qml.devices.qubit.simulate._find_post_processed_mcms, and is being made private, as it is an utility for"
    },
    {
      "id": "qml.qinfo.relative_entropy",
      "name": "qml.qinfo.relative_entropy",
      "type": "function",
      "description": "PennyLane API: qinfo.relative_entropy. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "y. (#2772) We’ve enabled two cases for calculating the relative entropy:  A QNode transform via qml.qinfo.relative_entropy: dev = qml.device('default.qubit', wires=2)  @qml.qnode(dev) def circuit(para"
    },
    {
      "id": "qml.ops.op_math.Adjoint.__new__.",
      "name": "qml.ops.op_math.Adjoint.__new__.",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Adjoint.__new__.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "he docstring for qml.ops.op_math.Pow.__new__ is now complete and it has been updated along with qml.ops.op_math.Adjoint.__new__. (#4231) The docstring for qml.grad now states that it should be used wi"
    },
    {
      "id": "qml.dynamic_one_shot.",
      "name": "qml.dynamic_one_shot.",
      "type": "function",
      "description": "PennyLane API: dynamic_one_shot.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "al control, collecting statistics, and post-selection, along with all measurements enabled with qml.dynamic_one_shot. More information about this new mid-circuit measurement method can be found on our"
    },
    {
      "id": "qml.jacobian.",
      "name": "qml.jacobian.",
      "type": "function",
      "description": "PennyLane API: jacobian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e documentation of a few optimizers. (#6303) (#6315) Corrected examples in the documentation of qml.jacobian. (#6283) (#6315) Fixed spelling in a number of places across the documentation. (#6280) Add"
    },
    {
      "id": "qml.template",
      "name": "qml.template",
      "type": "function",
      "description": "PennyLane API: template. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "RAM. (#8825) Bucket Brigade QRAM, a Hybrid QRAM and a Select-Only QRAM variant are implemented as a template BBQRAM, HybridQRAM and SelectOnlyQRAM to allow for selection of bitstrings in superposition"
    },
    {
      "id": "qml.qnode_old.qnode",
      "name": "qml.qnode_old.qnode",
      "type": "function",
      "description": "PennyLane API: qnode_old.qnode. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ew QNode, refer to the Breaking Changes section. Note that the old QNode remains accessible at @qml.qnode_old.qnode, however this will be removed in the next release.  Custom decompositions can now be"
    },
    {
      "id": "qml.operation.enable_new_opmath",
      "name": "qml.operation.enable_new_opmath",
      "type": "function",
      "description": "PennyLane API: operation.enable_new_opmath. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " operator arithmetic has been removed. This includes qml.ops.Hamiltonian, qml.operation.Tensor, qml.operation.enable_new_opmath, qml.operation.disable_new_opmath, and qml.operation.convert_to_legacy_H"
    },
    {
      "id": "qml.hf.generate_symmetries",
      "name": "qml.hf.generate_symmetries",
      "type": "function",
      "description": "PennyLane API: hf.generate_symmetries. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "enerate_hamiltonian(mol)(geometry)  # determine Hamiltonian symmetries generators, paulix_ops = qml.hf.generate_symmetries(H, len(H.wires)) opt_sector = qml.hf.optimal_sector(H, generators, mol.n_elec"
    },
    {
      "id": "qml.transforms.adjoint_metric_tensor",
      "name": "qml.transforms.adjoint_metric_tensor",
      "type": "function",
      "description": "PennyLane API: transforms.adjoint_metric_tensor. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "m QNode transforms. (#4466) QNode transforms in qml.qinfo now support custom wire labels. #4331 qml.transforms.adjoint_metric_tensor now uses the simulation tools in qml.devices.qubit instead of priva"
    },
    {
      "id": "qml.templates.AmplitudeEmbedding",
      "name": "qml.templates.AmplitudeEmbedding",
      "type": "function",
      "description": "PennyLane API: templates.AmplitudeEmbedding. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rray([1, 0, 1, 1], requires_grad=False)     qml.BasisState(basis_state, wires=[0, 1, 2, 3])     qml.templates.AmplitudeEmbedding(data, wires=[0, 1, 2, 3])     qml.templates.BasicEntanglerLayers(weight"
    },
    {
      "id": "qml.qsvt_legacy.",
      "name": "qml.qsvt_legacy.",
      "type": "function",
      "description": "PennyLane API: qsvt_legacy.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " 0.    ]  [ 0.      0.3793  0.      0.1625]]   The old functionality can still be accessed with qml.qsvt_legacy.  A new qml.GQSP template has been added to perform Generalized Quantum Signal Processin"
    },
    {
      "id": "qml.ops.mid_measure.",
      "name": "qml.ops.mid_measure.",
      "type": "function",
      "description": "PennyLane API: ops.mid_measure.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", qml.measurements.MeasurementValue, and qml.measurements.get_mcm_predicates are now located in qml.ops.mid_measure. MidMeasureMP is now renamed to MidMeasure. qml.measurements.find_post_processed_mcm"
    },
    {
      "id": "qml.ftqc.ParametricMidMeasureMP",
      "name": "qml.ftqc.ParametricMidMeasureMP",
      "type": "function",
      "description": "PennyLane API: ftqc.ParametricMidMeasureMP. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "trainable and an intermediate transform does not preserve trainability information. (#7345) The qml.ftqc.ParametricMidMeasureMP class was unable to accept data from jax.numpy.array inputs when specify"
    },
    {
      "id": "qml.DecompositionUndefinedError.",
      "name": "qml.DecompositionUndefinedError.",
      "type": "class",
      "description": "PennyLane API: DecompositionUndefinedError.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ion times. (#5876) The qml.CNOT operator no longer decomposes into itself. Instead, it raises a qml.DecompositionUndefinedError. (#6039)  Mid-circuit measurements The qml.dynamic_one_shot transform no"
    },
    {
      "id": "qml.labs.intermediate_reps",
      "name": "qml.labs.intermediate_reps",
      "type": "function",
      "description": "PennyLane API: labs.intermediate_reps. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "les, and even functions within the same submodule, from each other. (#7650) A new module called qml.labs.intermediate_reps has been added to provide functionality to compute intermediate representatio"
    },
    {
      "id": "qml.pulse.ParametrizedHamiltonian.",
      "name": "qml.pulse.ParametrizedHamiltonian.",
      "type": "function",
      "description": "PennyLane API: pulse.ParametrizedHamiltonian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ing A new function called qml.pulse.pwc has been added as a convenience function for defining a qml.pulse.ParametrizedHamiltonian. This function can be used to create a callable coefficient by setting"
    },
    {
      "id": "qml.adjoint.",
      "name": "qml.adjoint.",
      "type": "function",
      "description": "PennyLane API: adjoint.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ions can now be used with the qml.qjit decorator: qml.grad, qml.jacobian, qml.vjp, qml.jvp, and qml.adjoint. (#4709) (#4724) (#4725) (#4726) When qml.grad or qml.jacobian are used with @qml.qjit, they"
    },
    {
      "id": "qml.ops.op_math.Adjoint.",
      "name": "qml.ops.op_math.Adjoint.",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Adjoint.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "he docstring for qml.ops.op_math.Pow.__new__ is now complete and it has been updated along with qml.ops.op_math.Adjoint.__new__. (#4231) The docstring for qml.grad now states that it should be used wi"
    },
    {
      "id": "qml.capture.custom_primitives",
      "name": "qml.capture.custom_primitives",
      "type": "function",
      "description": "PennyLane API: capture.custom_primitives. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " objects. (#6877) A QmlPrimitive class has been added that inherits jax.core.Primitive to a new qml.capture.custom_primitives module. This class contains a prim_type property so that we can differenti"
    },
    {
      "id": "qml.operation.disable_new_opmath",
      "name": "qml.operation.disable_new_opmath",
      "type": "function",
      "description": "PennyLane API: operation.disable_new_opmath. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "oved. This includes qml.ops.Hamiltonian, qml.operation.Tensor, qml.operation.enable_new_opmath, qml.operation.disable_new_opmath, and qml.operation.convert_to_legacy_H. Note that qml.Hamiltonian will "
    },
    {
      "id": "qml.hf.Molecule",
      "name": "qml.hf.Molecule",
      "type": "function",
      "description": "PennyLane API: hf.Molecule. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ry symbols = [\"He\", \"H\"] geometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.4588684632]]) mol = qml.hf.Molecule(symbols, geometry, charge=1)  # generate the qubit Hamiltonian H = qml.hf.generate_hamil"
    },
    {
      "id": "qml.simplify.",
      "name": "qml.simplify.",
      "type": "function",
      "description": "PennyLane API: simplify.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tions. (#3024) Jax gradients now work with a QNode when the quantum function was transformed by qml.simplify. (#3017) Operators that have num_wires = AnyWires or num_wires = AnyWires now raise an erro"
    },
    {
      "id": "qml.MultiControlledX.",
      "name": "qml.MultiControlledX.",
      "type": "class",
      "description": "PennyLane API: MultiControlledX.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tionPlus and qml.SingleExcitationMinus (#1278) qml.DoubleExcitation (#1303) qml.Toffoli (#1320) qml.MultiControlledX. (#1287) When controlling on three or more wires, an ancilla register of worker wir"
    },
    {
      "id": "qml.QNGOptimizer.step_and_cost",
      "name": "qml.QNGOptimizer.step_and_cost",
      "type": "class",
      "description": "PennyLane API: QNGOptimizer.step_and_cost. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " the Device class to avoid any edge cases leading to failures with plugins. (#1838) Updated the qml.QNGOptimizer.step_and_cost method to avoid the use of deprecated functionality. (#1834) Added a cust"
    },
    {
      "id": "qml.math._multi_dispatch",
      "name": "qml.math._multi_dispatch",
      "type": "function",
      "description": "PennyLane API: math._multi_dispatch. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ch previously had only one argument which contained a list of the tensors to be dispatched: >>> qml.math._multi_dispatch([torch_scalar, torch_tensor, numpy_tensor]) 'torch'   To differentiate whether "
    },
    {
      "id": "qml.QubitUnitary.",
      "name": "qml.QubitUnitary.",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "sition'. (#8390) Added a new decomposition, _decompose_2_cnots, for the two-qubit decomposition for QubitUnitary. It supports the analytical decomposition a two-qubit unitary known to require exactly "
    },
    {
      "id": "qml.templates.kUpCCGSD",
      "name": "qml.templates.kUpCCGSD",
      "type": "function",
      "description": "PennyLane API: templates.kUpCCGSD. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "its)  dev = qml.device('default.qubit', wires=qubits)  @qml.qnode(dev) def ansatz(weights):     qml.templates.kUpCCGSD(weights, wires=[0,1,2,3], k=0, delta_sz=0,                                 init_s"
    },
    {
      "id": "qml.transforms.classical_jacobian",
      "name": "qml.transforms.classical_jacobian",
      "type": "function",
      "description": "PennyLane API: transforms.classical_jacobian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "roving compatibility with machine learning interfaces. (#4995)  Breaking changes 💔 The function qml.transforms.classical_jacobian has been moved to the gradients module and is now accessible as qml.gr"
    },
    {
      "id": "qml.qchem.taper_operation.",
      "name": "qml.qchem.taper_operation.",
      "type": "function",
      "description": "PennyLane API: qchem.taper_operation.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "emistry. (#3844) Usage Details and Theory sections have been separated in the documentation for qml.qchem.taper_operation. (3977)  Bug fixes 🐛 ctrl_decomp_bisect and ctrl_decomp_zyz are no longer used"
    },
    {
      "id": "qml.beta.qnode.",
      "name": "qml.beta.qnode.",
      "type": "function",
      "description": "PennyLane API: beta.qnode.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ient support, and arbitrary order derivatives. This QNode is available via qml.beta.QNode, and @qml.beta.qnode. (#1642) (#1646) (#1651) (#1804) It differs from the standard QNode in several ways:  Cus"
    },
    {
      "id": "qml.labs.map_to_resource_op",
      "name": "qml.labs.map_to_resource_op",
      "type": "function",
      "description": "PennyLane API: labs.map_to_resource_op. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "res classes have been added to track and manage auxiliary qubits. (#7404) A new function called qml.labs.map_to_resource_op has been added to map PennyLane Operations to their resource equivalents. (#"
    },
    {
      "id": "qml.QueuingManager.stop_recording.",
      "name": "qml.QueuingManager.stop_recording.",
      "type": "class",
      "description": "PennyLane API: QueuingManager.stop_recording.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "in the queue. (#3085) qml.tape.stop_recording and QuantumTape.stop_recording have been moved to qml.QueuingManager.stop_recording. The old functions will still be available until v0.29. (#3068) qml.ta"
    },
    {
      "id": "qml.QubitUnitary.pow",
      "name": "qml.QubitUnitary.pow",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.pow. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "longer depends on queuing, allowing it to work as expected with QNodes. (#4831) qml.pow(op) and qml.QubitUnitary.pow() now also work with Tensorflow data raised to an integer power. (#4827) The text d"
    },
    {
      "id": "qml.devices.qubit.simulate._find_post_processed_mcms",
      "name": "qml.devices.qubit.simulate._find_post_processed_mcms",
      "type": "function",
      "description": "PennyLane API: devices.qubit.simulate._find_post_processed_mcms. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "re. MidMeasureMP is now renamed to MidMeasure. qml.measurements.find_post_processed_mcms is now qml.devices.qubit.simulate._find_post_processed_mcms, and is being made private, as it is an utility for"
    },
    {
      "id": "qml.grouping.group_observables",
      "name": "qml.grouping.group_observables",
      "type": "function",
      "description": "PennyLane API: grouping.group_observables. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "bug where the custom implementation of the states_to_binary device method was not used. (#2809) qml.grouping.group_observables now works when individual wire labels are iterable. (#2752) The adjoint o"
    },
    {
      "id": "qml.compiler.python_compiler.transforms.MeasurementsFromSamplesPass",
      "name": "qml.compiler.python_compiler.transforms.MeasurementsFromSamplesPass",
      "type": "function",
      "description": "PennyLane API: compiler.python_compiler.transforms.MeasurementsFromSamplesPass. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "Op: allocates and deallocates qubits, respectively. (#7915)   A compilation pass written called qml.compiler.python_compiler.transforms.MeasurementsFromSamplesPass has been added for integration with "
    },
    {
      "id": "qml.optimize.qng._flatten_np",
      "name": "qml.optimize.qng._flatten_np",
      "type": "function",
      "description": "PennyLane API: optimize.qng._flatten_np. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "either moved or removed:  qml.utils._flatten, qml.utils.unflatten has been moved and renamed to qml.optimize.qng._flatten_np and qml.optimize.qng._unflatten_np respectively. qml.utils._inv_dict and qm"
    },
    {
      "id": "qml.qnode_old.QNode",
      "name": "qml.qnode_old.QNode",
      "type": "function",
      "description": "PennyLane API: qnode_old.QNode. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", and the decimals and show_matrices keywords were added.   The deprecated QNode, available via qml.qnode_old.QNode, has been removed. Please transition to using the standard qml.QNode. (#2336) (#2337"
    },
    {
      "id": "qml.BoseSentence.",
      "name": "qml.BoseSentence.",
      "type": "class",
      "description": "PennyLane API: BoseSentence.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rators analogous to qml.FermiWord and qml.FermiSentence are now available with qml.BoseWord and qml.BoseSentence. (#6518) qml.BoseWord and qml.BoseSentence operate similarly to their fermionic counter"
    },
    {
      "id": "qml.PauliSentences",
      "name": "qml.PauliSentences",
      "type": "class",
      "description": "PennyLane API: PauliSentences. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "T, SX, SWAP, ISWAP, ECR, SISWAP} have been added, and a shape error in the matrix conversion of qml.PauliSentences with list or array inputs has been fixed. (#6562) (#6587) qml.QNode and qml.execute n"
    },
    {
      "id": "qml.drawer.CHARSETS",
      "name": "qml.drawer.CHARSETS",
      "type": "function",
      "description": "PennyLane API: drawer.CHARSETS. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ed by the Operator.label method. qml.drawer.CircuitDrawer was replaced by qml.drawer.tape_text. qml.drawer.CHARSETS was removed because unicode is assumed to be accessible. Grid and qml.drawer.drawabl"
    },
    {
      "id": "qml.Exp",
      "name": "qml.Exp",
      "type": "class",
      "description": "PennyLane API: Exp. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "viding num_steps to pennylane.evolve(), pennylane.exp(), pennylane.ops.Evolution, and pennylane.ops.Exp has been disallowed. Instead, use TrotterProduct for approximate methods, providing the n parame"
    },
    {
      "id": "qml.finite_diff",
      "name": "qml.finite_diff",
      "type": "function",
      "description": "PennyLane API: finite_diff. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ive error is now raised when a QNode with diff_method=None is differentiated. (#6770) qml.gradients.finite_diff_jvp has been added to compute the jvp of an arbitrary numeric function. (#6853) The qche"
    },
    {
      "id": "qml.gradient.stoch_pulse_grad",
      "name": "qml.gradient.stoch_pulse_grad",
      "type": "function",
      "description": "PennyLane API: gradient.stoch_pulse_grad. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "fferentiated using a stochastic parameter-shift method. (#3780) (#3900) (#4000) (#4004) The new qml.gradient.stoch_pulse_grad differentiation method unlocks stochastic-parameter-shift differentiation "
    },
    {
      "id": "qml.capture.transforms.MapWiresInterpreter",
      "name": "qml.capture.transforms.MapWiresInterpreter",
      "type": "function",
      "description": "PennyLane API: capture.transforms.MapWiresInterpreter. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "lass decomposes pennylane operators following the same API as qml.transforms.decompose. (#6691) qml.capture.transforms.MapWiresInterpreter: this class maps wires to new values following the same API a"
    },
    {
      "id": "qml.ResourceOutOfPlaceSquare",
      "name": "qml.ResourceOutOfPlaceSquare",
      "type": "class",
      "description": "PennyLane API: ResourceOutOfPlaceSquare. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "equired for supporting compact Hamiltonian development and resource estimation have been added: qml.ResourceOutOfPlaceSquare, qml.ResourcePhaseGradient, qml.ResourceOutMultiplier, qml.ResourceSemiAdde"
    },
    {
      "id": "qml.gradients.hessian_transform",
      "name": "qml.gradients.hessian_transform",
      "type": "function",
      "description": "PennyLane API: gradients.hessian_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ct (JVP) computation Gradient transforms (qml.gradients.param_shift, qml.gradients.finite_diff, qml.gradients.hessian_transform, qml.gradients.param_shift_hessian). Interfaces (Autograd, TensorFlow, a"
    },
    {
      "id": "qml.tape.JacobianTape",
      "name": "qml.tape.JacobianTape",
      "type": "function",
      "description": "PennyLane API: tape.JacobianTape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "terfaces.batch module: from pennylane.interfaces.batch import execute  def cost_fn(x):     with qml.tape.JacobianTape() as tape1:         qml.RX(x[0], wires=[0])         qml.RY(x[1], wires=[1])       "
    },
    {
      "id": "qml.labs.zxopt.todd",
      "name": "qml.labs.zxopt.todd",
      "type": "function",
      "description": "PennyLane API: labs.zxopt.todd. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " optimize_t_count() Instead of qml.labs.zxopt.full_reduce, use reduce_non_clifford() Instead of qml.labs.zxopt.todd, use todd() Instead of qml.labs.zxopt.basic_optimization, use push_hadamards() (#817"
    },
    {
      "id": "qml.transforms.cut_circuit_mc",
      "name": "qml.transforms.cut_circuit_mc",
      "type": "function",
      "description": "PennyLane API: transforms.cut_circuit_mc. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rms.batch_input to support the new return types. (#3431) Updated qml.transforms.cut_circuit and qml.transforms.cut_circuit_mc to support the new return types. (#3346) Limit NumPy version to <1.24. (#3"
    },
    {
      "id": "qml.templates.ArbitraryStatePreparation",
      "name": "qml.templates.ArbitraryStatePreparation",
      "type": "function",
      "description": "PennyLane API: templates.ArbitraryStatePreparation. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " = qml.device('default.qubit', wires=3)  @qml.qnode(dev) def circuit(weights1, weights2):       qml.templates.ArbitraryStatePreparation(weights1, wires=[0, 1, 2])       qml.templates.ArbitraryUnitary("
    },
    {
      "id": "qml.pulse.drive",
      "name": "qml.pulse.drive",
      "type": "function",
      "description": "PennyLane API: pulse.drive. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tributors follow current standards and avoid compatibility issues. (#7479) The documentation of qml.pulse.drive has been updated and corrected. (#7459) The API list in the documentation has been alpha"
    },
    {
      "id": "qml.HilbertSchmidt.",
      "name": "qml.HilbertSchmidt.",
      "type": "class",
      "description": "PennyLane API: HilbertSchmidt.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " Jax jit now works when a probability measurement is broadcasted onto all wires. (#4742) Fixed LocalHilbertSchmidt.compute_decomposition so that the template can be used in a QNode. (#4719) Fixes tran"
    },
    {
      "id": "qml.from_qiskit_noise.",
      "name": "qml.from_qiskit_noise.",
      "type": "function",
      "description": "PennyLane API: from_qiskit_noise.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "erting noise models from Qiskit ♻️ Convert Qiskit noise models into a PennyLane NoiseModel with qml.from_qiskit_noise. (#5996) In the last few releases, we’ve added substantial improvements and new fe"
    },
    {
      "id": "qml.ops.Pow.matrix",
      "name": "qml.ops.Pow.matrix",
      "type": "function",
      "description": "PennyLane API: ops.Pow.matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "y all applied transforms before drawing. (#5277) ctrl_decomp_zyz is now differentiable. (#5198) qml.ops.Pow.matrix() is now differentiable with TensorFlow with integer exponents. (#5178) The qml.Motto"
    },
    {
      "id": "qml.proc",
      "name": "qml.proc",
      "type": "function",
      "description": "PennyLane API: proc. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "cated in qml.ops.mid_measure. MidMeasureMP is now renamed to MidMeasure. qml.measurements.find_post_processed_mcms is now qml.devices.qubit.simulate._find_post_processed_mcms, and is being made privat"
    },
    {
      "id": "qml.AdaptiveOptimizer.",
      "name": "qml.AdaptiveOptimizer.",
      "type": "class",
      "description": "PennyLane API: AdaptiveOptimizer.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "eases.   Adaptive optimization 🏃🏋️🏊 Optimizing quantum circuits can now be done adaptively with qml.AdaptiveOptimizer. (#3192) The qml.AdaptiveOptimizer takes an initial circuit and a collection of op"
    },
    {
      "id": "qml.pulse.ParametrizedEvolution.",
      "name": "qml.pulse.ParametrizedEvolution.",
      "type": "function",
      "description": "PennyLane API: pulse.ParametrizedEvolution.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ing when used with Tensorflow. (#4818) default.qubit can now evolve already batched states with qml.pulse.ParametrizedEvolution. (#4863) qml.ArbitraryUnitary now supports batching. (#4745) Operator an"
    },
    {
      "id": "qml.resource.",
      "name": "qml.resource.",
      "type": "function",
      "description": "PennyLane API: resource.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "es. (#8787) import pennylane as qml from pennylane.resource import SpectralNormError from pennylane.resource.error import ErrorOperation  class ApproximateRX(ErrorOperation):     def __init__(self, ph"
    },
    {
      "id": "qml.LinearCombination.compute_grouping",
      "name": "qml.LinearCombination.compute_grouping",
      "type": "class",
      "description": "PennyLane API: LinearCombination.compute_grouping. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "dices from the partitioned observables more efficiently. These changes improve the wall time of qml.LinearCombination.compute_grouping and the grouping_type='qwc' by orders of magnitude.  qml.counts m"
    },
    {
      "id": "qml.ResourceSelect",
      "name": "qml.ResourceSelect",
      "type": "class",
      "description": "PennyLane API: ResourceSelect. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "Labs Resource Estimation State-of-the-art resource estimates have been added to existing templates: ResourceSelectPauliRot, ResourceQubitUnitary, ResourceSingleQubitComparator, ResourceTwoQubitCompara"
    },
    {
      "id": "qml.utils.unflatten",
      "name": "qml.utils.unflatten",
      "type": "function",
      "description": "PennyLane API: utils.unflatten. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ally, the following 4 sets of functions have been either moved or removed:  qml.utils._flatten, qml.utils.unflatten has been moved and renamed to qml.optimize.qng._flatten_np and qml.optimize.qng._unf"
    },
    {
      "id": "qml.tape.tape.expand_tape",
      "name": "qml.tape.tape.expand_tape",
      "type": "function",
      "description": "PennyLane API: tape.tape.expand_tape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "required auxiliary wires, has been improved. (#6074) The docstring for QuantumScript.expand and qml.tape.tape.expand_tape has been improved. (#5974)  Bug fixes 🐛 The sparse matrix can now be computed "
    },
    {
      "id": "qml.transforms.batch_transform",
      "name": "qml.transforms.batch_transform",
      "type": "function",
      "description": "PennyLane API: transforms.batch_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rcuit_drawer.drawable_grid process a list of operations to layer positions for drawing. (#1639) qml.transforms.batch_transform now accepts expand_fns that take additional arguments and keyword argumen"
    },
    {
      "id": "qml.THermitian.",
      "name": "qml.THermitian.",
      "type": "class",
      "description": "PennyLane API: THermitian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "qml.state and qml.probs measurements. Measuring user-specified Hermitian matrix observables via qml.THermitian.  A comprehensive example of these features is given below: dev = qml.device(\"default.qut"
    },
    {
      "id": "qml.grouping.pauli_group",
      "name": "qml.grouping.pauli_group",
      "type": "function",
      "description": "PennyLane API: grouping.pauli_group. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "oup Added functionality for constructing and manipulating the Pauli group (#1181). The function qml.grouping.pauli_group provides a generator to easily loop over the group, or construct and store it i"
    },
    {
      "id": "qml.MottonenStatePreparation.",
      "name": "qml.MottonenStatePreparation.",
      "type": "class",
      "description": "PennyLane API: MottonenStatePreparation.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "wires. (#6060) Fixed jax.grad and jax.jit to work for qml.AmplitudeEmbedding, qml.StatePrep and qml.MottonenStatePreparation. (#5620) Fixed a bug in qml.center that omitted elements from the center if"
    },
    {
      "id": "qml.pauli_sentence",
      "name": "qml.pauli_sentence",
      "type": "function",
      "description": "PennyLane API: pauli_sentence. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " Identity terms on Hamiltonians with non-standard wire orders are no longer eliminated. (#4161) qml.pauli_sentence() is now compatible with empty Hamiltonians qml.Hamiltonian([], []). (#4171) Fixed a "
    },
    {
      "id": "qml.snapshots.",
      "name": "qml.snapshots.",
      "type": "function",
      "description": "PennyLane API: snapshots.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " (#5805) Fixed a bug where default.qutrit was falsely determined to be natively compatible with qml.snapshots. (#5805) Fixed a bug where the measurement of a qml.Snapshot instance was not passed on du"
    },
    {
      "id": "qml.grad.",
      "name": "qml.grad.",
      "type": "function",
      "description": "PennyLane API: grad.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "─╭●─────│───T─╰X──T†─╰X─┤ 2: ──H─╰X──T†─╰X──T─╰X──T†─╰X──T──H────────┤     Internal changes ⚙️ The _grad.py file in split into a folder for improved source code organization. (#8800) Updated pyproject"
    },
    {
      "id": "qml.ops.",
      "name": "qml.ops.",
      "type": "function",
      "description": "PennyLane API: ops.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "r qml.gradients qml.io qml.kernels qml.labs qml.liealg qml.logging qml.math qml.noise qml.numpy qml.ops.op_math qml.pauli qml.pulse qml.qaoa qml.qchem qml.qcut qml.qnn qml.resource qml.shadows qml.spi"
    },
    {
      "id": "qml.while_loop.",
      "name": "qml.while_loop.",
      "type": "function",
      "description": "PennyLane API: while_loop.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ynamic parameters as predicates. qml.for_loop with dynamic parameters for start, stop, or step. qml.while_loop.     Python control flow (if/else, for, while) is now supported when program capture is e"
    },
    {
      "id": "qml.liealg.cartan_decomp.",
      "name": "qml.liealg.cartan_decomp.",
      "type": "function",
      "description": "PennyLane API: liealg.cartan_decomp.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "l.center. >>> qml.center(dla) [X(0)]    Cartan decompositions, g = k + m, can be performed with qml.liealg.cartan_decomp. These use involution functions that return a boolean value. A variety of typic"
    },
    {
      "id": "qml.qaoa.cost_layer",
      "name": "qml.qaoa.cost_layer",
      "type": "function",
      "description": "PennyLane API: qaoa.cost_layer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ical operations ended up with the same hash as Sum‘s with different numbers of repeats. (#5851) qml.qaoa.cost_layer and qml.qaoa.mixer_layer can now be used with Sum operators. (#5846) Fixed a bug whe"
    },
    {
      "id": "qml.measurements.find_post_processed_mcms",
      "name": "qml.measurements.find_post_processed_mcms",
      "type": "function",
      "description": "PennyLane API: measurements.find_post_processed_mcms. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "m_predicates are now located in qml.ops.mid_measure. MidMeasureMP is now renamed to MidMeasure. qml.measurements.find_post_processed_mcms is now qml.devices.qubit.simulate._find_post_processed_mcms, a"
    },
    {
      "id": "qml.Snapshot.",
      "name": "qml.Snapshot.",
      "type": "class",
      "description": "PennyLane API: Snapshot.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "qml.snapshots and qml.Snapshot, clarifying that compilation transforms may move operations across a Snapshot. (#7746) In the Documentation page, references to the outdated Sphinx and unsupported Pytho"
    },
    {
      "id": "qml.StatePrepBase",
      "name": "qml.StatePrepBase",
      "type": "class",
      "description": "PennyLane API: StatePrepBase. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "Conditional. (#4860) The prep keyword argument has been removed from QuantumScript and QuantumTape. StatePrepBase operations should be placed at the beginning of the ops list instead. (#4756) qml.grad"
    },
    {
      "id": "qml.operation.convert_to_legacy_H",
      "name": "qml.operation.convert_to_legacy_H",
      "type": "function",
      "description": "PennyLane API: operation.convert_to_legacy_H. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n, qml.operation.Tensor, qml.operation.enable_new_opmath, qml.operation.disable_new_opmath, and qml.operation.convert_to_legacy_H. Note that qml.Hamiltonian will continue to dispatch to qml.ops.Linear"
    },
    {
      "id": "qml.MeasurementValue",
      "name": "qml.MeasurementValue",
      "type": "class",
      "description": "PennyLane API: MeasurementValue. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nylane.decomposition for more details. qml.measure, qml.measurements.MidMeasureMP, qml.measurements.MeasurementValue, and qml.measurements.get_mcm_predicates are now located in qml.ops.mid_measure. Mi"
    },
    {
      "id": "qml.ops.op_math.controlled_ops",
      "name": "qml.ops.op_math.controlled_ops",
      "type": "function",
      "description": "PennyLane API: ops.op_math.controlled_ops. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "iginal operator. (#4113) (#4256) qml.CY has been moved from qml.ops.qubit.non_parametric_ops to qml.ops.op_math.controlled_ops and now inherits from qml.ops.op_math.ControlledOp. (#4116) qml.CZ now in"
    },
    {
      "id": "qml.templates.subroutines.GroverOperator",
      "name": "qml.templates.subroutines.GroverOperator",
      "type": "function",
      "description": "PennyLane API: templates.subroutines.GroverOperator. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "observables that are created from multi-qubit operations. (#1550) Added the matrix attribute to qml.templates.subroutines.GroverOperator (#1553) The tape.to_openqasm() method now has a measure_all arg"
    },
    {
      "id": "qml.circuit_drawer.drawable_grid",
      "name": "qml.circuit_drawer.drawable_grid",
      "type": "function",
      "description": "PennyLane API: circuit_drawer.drawable_grid. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "beta.QNode now supports the qml.specs transform. (#1739) qml.circuit_drawer.drawable_layers and qml.circuit_drawer.drawable_grid process a list of operations to layer positions for drawing. (#1639) qm"
    },
    {
      "id": "qml.pauli.PauliWord.operation",
      "name": "qml.pauli.PauliWord.operation",
      "type": "function",
      "description": "PennyLane API: pauli.PauliWord.operation. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ord.hamiltonian have been deprecated. Instead, please use qml.pauli.PauliSentence.operation and qml.pauli.PauliWord.operation, respectively. (#6287) qml.pauli.simplify() has been deprecated. Instead, "
    },
    {
      "id": "qml.init.strong_ent_layers_normal",
      "name": "qml.init.strong_ent_layers_normal",
      "type": "function",
      "description": "PennyLane API: init.strong_ent_layers_normal. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "lyEntanglingLayers(weights, wires=range(wires))     return qml.expval(qml.PauliZ(0))  weights = qml.init.strong_ent_layers_normal(layers, wires, seed=1967)   Evaluating circuits and their gradients on"
    },
    {
      "id": "qml.capture.qnode_call",
      "name": "qml.capture.qnode_call",
      "type": "function",
      "description": "PennyLane API: capture.qnode_call. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d, eval_jaxpr, has been added to the device API for native execution of plxpr programs. (#6580) qml.capture.qnode_call has been made private and moved to the workflow module. (#6620)  Other Improvemen"
    },
    {
      "id": "qml.grouping.string_to_pauli_word",
      "name": "qml.grouping.string_to_pauli_word",
      "type": "function",
      "description": "PennyLane API: grouping.string_to_pauli_word. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "  qml.CZ(wires=[0, 1])     qml.RY(-0.4, wires=0)     qml.CZ(wires=[1, 2])     return qml.expval(qml.grouping.string_to_pauli_word(\"ZZZ\"))   >>> x = np.array(0.531, requires_grad=True) >>> circuit(x) 0"
    },
    {
      "id": "qml.Sum.",
      "name": "qml.Sum.",
      "type": "class",
      "description": "PennyLane API: Sum.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " (#7301) The inner_transform and config keyword arguments in qml.execute have been removed. (#7300) Sum.ops, Sum.coeffs, Prod.ops and Prod.coeffs have been removed. (#7304) Specifying pipeline=None wi"
    },
    {
      "id": "qml.labs.CompressedResourceOp",
      "name": "qml.labs.CompressedResourceOp",
      "type": "function",
      "description": "PennyLane API: labs.CompressedResourceOp. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " been added to store and track the quantum resources from a circuit. (#7406) A new class called qml.labs.CompressedResourceOp class has been added to store information about the operator type and para"
    },
    {
      "id": "qml.ops.op_math.decompositions.two_qubit_unitary.py",
      "name": "qml.ops.op_math.decompositions.two_qubit_unitary.py",
      "type": "function",
      "description": "PennyLane API: ops.op_math.decompositions.two_qubit_unitary.py. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "g with qml.classical_shadow and qml.shadow_expval. (#6301) Fixed unnecessary call of eigvals in qml.ops.op_math.decompositions.two_qubit_unitary.py that was causing an error in VJP. Raises warnings to"
    },
    {
      "id": "qml.qinfo.transforms.purity",
      "name": "qml.qinfo.transforms.purity",
      "type": "function",
      "description": "PennyLane API: qinfo.transforms.purity. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1 / 2]] >>> qml.math.purity(x, [0, 1]) 0.5    qml.qinfo.transforms.purity can transform a QNode returning a state to a function that returns the purit"
    },
    {
      "id": "qml.tape.",
      "name": "qml.tape.",
      "type": "function",
      "description": "PennyLane API: tape.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "easurementProcess methods should be used instead. (#8468) MeasurementProcess.expand is removed. qml.tape.QuantumScript(mp.obs.diagonalizing_gates(), [type(mp)(eigvals=mp.obs.eigvals(), wires=mp.obs.wi"
    },
    {
      "id": "qml.transform_angles.",
      "name": "qml.transform_angles.",
      "type": "function",
      "description": "PennyLane API: transform_angles.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " calculate and convert phase angles for QSP and QSVT has been added with qml.poly_to_angles and qml.transform_angles. (#6483) The qml.poly_to_angles function calculates phase angles directly given pol"
    },
    {
      "id": "qml.transforms.fold_global",
      "name": "qml.transforms.fold_global",
      "type": "function",
      "description": "PennyLane API: transforms.fold_global. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "lease use qml.tape.QuantumScript(op.decomposition()) instead. (#6227) The native folding method qml.transforms.fold_global for the qml.transforms.mitigate_with_zne transform no longer expands the circ"
    },
    {
      "id": "qml.data.Dataset.read",
      "name": "qml.data.Dataset.read",
      "type": "function",
      "description": "PennyLane API: data.Dataset.read. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "a module has been improved by employing a condensed writing format. (#3592) Lazy-loading in the qml.data.Dataset.read() method is more universally supported. (#3605) The qchem.Molecule class raises an"
    },
    {
      "id": "qml.GlobalPhase.",
      "name": "qml.GlobalPhase.",
      "type": "class",
      "description": "PennyLane API: GlobalPhase.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ". (#7025) qml.capture.PlxprInterpreter now flattens pytree arguments before evaluation. (#6975) qml.GlobalPhase.sparse_matrix now correctly returns a sparse matrix of the same shape as matrix. (#6940)"
    },
    {
      "id": "qml.pauli.PauliWord.hamiltonian",
      "name": "qml.pauli.PauliWord.hamiltonian",
      "type": "function",
      "description": "PennyLane API: pauli.PauliWord.hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " updated operator troubleshooting page. (#6287) (#6365) qml.pauli.PauliSentence.hamiltonian and qml.pauli.PauliWord.hamiltonian have been deprecated. Instead, please use qml.pauli.PauliSentence.operat"
    },
    {
      "id": "qml.labs.zxopt",
      "name": "qml.labs.zxopt",
      "type": "function",
      "description": "PennyLane API: labs.zxopt. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "has been updated to use the correct positional argument name. (#8174)  Labs Removals The module qml.labs.zxopt has been removed. Its functionalities are now available in the submodule zx. The same fun"
    },
    {
      "id": "qml.transforms.two_qubit_decomposition.",
      "name": "qml.transforms.two_qubit_decomposition.",
      "type": "function",
      "description": "PennyLane API: transforms.two_qubit_decomposition.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n incorporated into the qml.transforms.unitary_to_rot transform, and is available separately as qml.transforms.two_qubit_decomposition. (#1552) As an example, consider the following randomly-generated"
    },
    {
      "id": "qml.capture.transforms.DecomposeInterpreter",
      "name": "qml.capture.transforms.DecomposeInterpreter",
      "type": "function",
      "description": "PennyLane API: capture.transforms.DecomposeInterpreter. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "at are adjoints of each other following the same API as qml.transforms.cancel_inverses. (#6692) qml.capture.transforms.DecomposeInterpreter: this class decomposes pennylane operators following the sam"
    },
    {
      "id": "qml.drawer.drawable_layers.drawable_layers",
      "name": "qml.drawer.drawable_layers.drawable_layers",
      "type": "function",
      "description": "PennyLane API: drawer.drawable_layers.drawable_layers. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ". (#4117) The construction of the Pauli representation for the Sum class is now faster. (#4142) qml.drawer.drawable_layers.drawable_layers and qml.CircuitGraph have been updated to not rely on Operato"
    },
    {
      "id": "qml.transforms.core.TransformContainer",
      "name": "qml.transforms.core.TransformContainer",
      "type": "function",
      "description": "PennyLane API: transforms.core.TransformContainer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".Z(\"a\"))   >>> print(qml.draw(circuit)())   a: ──┤↗├────┤  <Z> aux: ───║───X─┤         ╚═══╝    qml.transforms.core.TransformContainer now holds onto a TransformDispatcher, args, and kwargs, instead o"
    },
    {
      "id": "qml.devices.",
      "name": "qml.devices.",
      "type": "function",
      "description": "PennyLane API: devices.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "stors(obj, sort=True) descendants_in_order(obj) in favor of descendants(obj, sort=True)   pennylane.devices.DefaultExecutionConfig has been removed. Instead, use qml.devices.ExecutionConfig() to creat"
    },
    {
      "id": "qml.vjp.",
      "name": "qml.vjp.",
      "type": "function",
      "description": "PennyLane API: vjp.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "num_work_wires. (#8769) argnum has been renamed argnums for qml.grad, qml.jacobian, qml.jvp and qml.vjp. (#8496) (#8481) qml.cond, the QNode, transforms, qml.grad, and qml.jacobian no longer treat all"
    },
    {
      "id": "qml.math.jax_argnums_to_tape_trainable",
      "name": "qml.math.jax_argnums_to_tape_trainable",
      "type": "function",
      "description": "PennyLane API: math.jax_argnums_to_tape_trainable. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "matic differentiation for validation, parameters from such a framework have to be used. (#6622) qml.math.jax_argnums_to_tape_trainable has been moved and made private to avoid an unnecessary QNode dep"
    },
    {
      "id": "qml.tape.TapeError",
      "name": "qml.tape.TapeError",
      "type": "function",
      "description": "PennyLane API: tape.TapeError. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ControlledQubitUnitary no longer accepts QubitUnitary objects as arguments as its base. (#7305) qml.tape.TapeError has been removed. (#7205)  Deprecations 👋Here’s a list of deprecations made this rele"
    },
    {
      "id": "qml.qinfo.vn_entropy",
      "name": "qml.qinfo.vn_entropy",
      "type": "function",
      "description": "PennyLane API: qinfo.vn_entropy. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ed_dm(circuit, wires=[0])(np.pi/2) [[0.5+0.j 0.+0.j]   [0.+0.j 0.5+0.j]]    Similar transforms, qml.qinfo.vn_entropy and qml.qinfo.mutual_info exist for transforming QNodes.  Currently, all quantum in"
    },
    {
      "id": "qml.hf.optimal_sector",
      "name": "qml.hf.optimal_sector",
      "type": "function",
      "description": "PennyLane API: hf.optimal_sector. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "an symmetries generators, paulix_ops = qml.hf.generate_symmetries(H, len(H.wires)) opt_sector = qml.hf.optimal_sector(H, generators, mol.n_electrons)  # taper the Hamiltonian H_tapered = qml.hf.transf"
    },
    {
      "id": "qml.measurements.expval",
      "name": "qml.measurements.expval",
      "type": "function",
      "description": "PennyLane API: measurements.expval. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nctions (e.g., qml.expval) to their top-level pages rather than their module-level pages (e.g., qml.measurements.expval). (#4750) Information for the documentation of qml.matrix about wire ordering ha"
    },
    {
      "id": "qml.compiler.python_compiler.transforms.ConvertToMBQCFormalismPass",
      "name": "qml.compiler.python_compiler.transforms.ConvertToMBQCFormalismPass",
      "type": "function",
      "description": "PennyLane API: compiler.python_compiler.transforms.ConvertToMBQCFormalismPass. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "instructions in the xDSL framework. (#7815) (#8059) A compilation pass written with xDSL called qml.compiler.python_compiler.transforms.ConvertToMBQCFormalismPass has been added for the experimental u"
    },
    {
      "id": "qml.liealg.change_basis_ad_rep.",
      "name": "qml.liealg.change_basis_ad_rep.",
      "type": "function",
      "description": "PennyLane API: liealg.change_basis_ad_rep.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "to_adjvec has moved to qml.liealg.op_to_adjvec. pennylane.labs.change_basis_ad_rep has moved to qml.liealg.change_basis_ad_rep. pennylane.labs.cartan_subalgebra has moved to qml.liealg.horizontal_cart"
    },
    {
      "id": "qml.pauli.grouping",
      "name": "qml.pauli.grouping",
      "type": "function",
      "description": "PennyLane API: pauli.grouping. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "p_wires instead. (#3186) The grouping module qml.grouping has been deprecated. Use qml.pauli or qml.pauli.grouping instead. The module will still be available until v0.28. (#3262)  Documentation The c"
    },
    {
      "id": "qml.default_expand_fn",
      "name": "qml.default_expand_fn",
      "type": "function",
      "description": "PennyLane API: default_expand_fn. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "w enable linting. (#4335) The default label for a StatePrepBase operator is now |Ψ⟩. (#4340) Device.default_expand_fn() has been updated to decompose qml.StatePrep operations present in the middle of "
    },
    {
      "id": "qml.Device.batch_transform",
      "name": "qml.Device.batch_transform",
      "type": "class",
      "description": "PennyLane API: Device.batch_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " The application of the qml.defer_measurements transform has been moved from QNode.construct to qml.Device.batch_transform to allow more fine-grain control over when defer_measurements should be used."
    },
    {
      "id": "qml.batch_transform.",
      "name": "qml.batch_transform.",
      "type": "function",
      "description": "PennyLane API: batch_transform.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "decorator on a batch-tape transform. (#1589) Quantum gradient transforms are a specific case of qml.batch_transform. Supported gradient transforms must be of the following form: @qml.gradients.gradien"
    },
    {
      "id": "qml.QubitUnitary.decomposition",
      "name": "qml.QubitUnitary.decomposition",
      "type": "class",
      "description": "PennyLane API: QubitUnitary.decomposition. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "96245-0.10177564j,  0.76279558-0.35024096j] ])   Then, we can compute the decomposition as: >>> qml.QubitUnitary.decomposition(U, wires=0) [Rot(-0.24209530281458358, 1.1493817777199102, 1.733058145303"
    },
    {
      "id": "qml.operation.Tensor",
      "name": "qml.operation.Tensor",
      "type": "function",
      "description": "PennyLane API: operation.Tensor. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "fusion. (#6590) Legacy operator arithmetic has been removed. This includes qml.ops.Hamiltonian, qml.operation.Tensor, qml.operation.enable_new_opmath, qml.operation.disable_new_opmath, and qml.operati"
    },
    {
      "id": "qml.transforms.mitigate_with_zne",
      "name": "qml.transforms.mitigate_with_zne",
      "type": "function",
      "description": "PennyLane API: transforms.mitigate_with_zne. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "has been introduced for testing purposes and referencing for future plugin development. (#6181) qml.transforms.mitigate_with_zne now gives a clearer error message when being applied on circuits, not d"
    },
    {
      "id": "qml.drawer.draw.draw_mpl",
      "name": "qml.drawer.draw.draw_mpl",
      "type": "function",
      "description": "PennyLane API: drawer.draw.draw_mpl. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "well as AnnotatedQueue. (#3097) Extended the qml.equal function to MeasurementProcesses (#3189) qml.drawer.draw.draw_mpl now accepts a style kwarg to select a style for plotting, rather than calling q"
    },
    {
      "id": "qml.qinfo.reduced_dm",
      "name": "qml.qinfo.reduced_dm",
      "type": "function",
      "description": "PennyLane API: qinfo.reduced_dm. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "4768725, -0.29183666]), array(-0.09489803))    Reduced density matrices of arbitrary states via qml.qinfo.reduced_dm: dev = qml.device(\"default.qubit\", wires=2) @qml.qnode(dev) def circuit(x):     qml"
    },
    {
      "id": "qml.center.",
      "name": "qml.center.",
      "type": "function",
      "description": "PennyLane API: center.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "the collection of operators that commute with all other operators in the DLA, can be found with qml.center. >>> qml.center(dla) [X(0)]    Cartan decompositions, g = k + m, can be performed with qml.li"
    },
    {
      "id": "qml.Hamiltonian.sparse_matrix",
      "name": "qml.Hamiltonian.sparse_matrix",
      "type": "class",
      "description": "PennyLane API: Hamiltonian.sparse_matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "of in-place inversion. (#3566) The qml.utils.sparse_hamiltonian function has been moved to thee qml.Hamiltonian.sparse_matrix method. (#3585) The qml.pauli.PauliSentence.operation() method has been im"
    },
    {
      "id": "qml.math.expand_vector.",
      "name": "qml.math.expand_vector.",
      "type": "function",
      "description": "PennyLane API: math.expand_vector.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "l.utils.pauli_eigs has been moved to qml.pauli.utils. qml.utils.expand_vector has been moved to qml.math.expand_vector.   The qml.qinfo module has been removed. Please use the corresponding functions "
    },
    {
      "id": "qml.tape.QubitParamShiftTape",
      "name": "qml.tape.QubitParamShiftTape",
      "type": "function",
      "description": "PennyLane API: tape.QubitParamShiftTape. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "9932, 3.4536312, 2.73521126, 2.6412488]  dev = qml.device(\"default.qubit\", wires=n_wires)  with qml.tape.QubitParamShiftTape() as tape:     for i in range(n_wires):         qml.RX(weights[i], wires=i)"
    },
    {
      "id": "qml.labs.ResourceQubitize",
      "name": "qml.labs.ResourceQubitize",
      "type": "function",
      "description": "PennyLane API: labs.ResourceQubitize. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ion for trotterization of CDF and THC Hamiltonians, respectively. (#7705) A new template called qml.labs.ResourceQubitize has been added which can be used to perform resource estimation for qubitizati"
    },
    {
      "id": "qml.labs.FreeWires",
      "name": "qml.labs.FreeWires",
      "type": "function",
      "description": "PennyLane API: labs.FreeWires. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " matrix that respects the connectivity. (#7394) qml.labs.QubitManager, qml.labs.AllocWires, and qml.labs.FreeWires classes have been added to track and manage auxiliary qubits. (#7404) A new function "
    },
    {
      "id": "qml.transforms.decompose.",
      "name": "qml.transforms.decompose.",
      "type": "function",
      "description": "PennyLane API: transforms.decompose.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "forms.DecomposeInterpreter: this class decomposes pennylane operators following the same API as qml.transforms.decompose. (#6691) qml.capture.transforms.MapWiresInterpreter: this class maps wires to n"
    },
    {
      "id": "qml.data.Dataset.write",
      "name": "qml.data.Dataset.write",
      "type": "function",
      "description": "PennyLane API: data.Dataset.write. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ue. (#3501) A typo has been fixed in the calculation and error messages in operation.py (#3536) qml.data.Dataset.write() now ensures that any lazy-loaded values are loaded before they are written to a"
    },
    {
      "id": "qml.transforms.convert_to_numpy_parameters.",
      "name": "qml.transforms.convert_to_numpy_parameters.",
      "type": "function",
      "description": "PennyLane API: transforms.convert_to_numpy_parameters.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "nd corresponding UnwrapTape and Unwrap classes have been removed. Instead of tape.unwrap(), use qml.transforms.convert_to_numpy_parameters. (#4535) The RandomLayers.compute_decomposition keyword argum"
    },
    {
      "id": "qml.fourier.visualize",
      "name": "qml.fourier.visualize",
      "type": "function",
      "description": "PennyLane API: fourier.visualize. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "esulting in a returned array with shape (2*degrees[0]+1,..., 2*degrees[-1]+1). The functions in qml.fourier.visualize accordingly accept such arrays of coefficients.   Other improvements A Shots class"
    },
    {
      "id": "qml.transforms.compile",
      "name": "qml.transforms.compile",
      "type": "function",
      "description": "PennyLane API: transforms.compile. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " new device interface. (#6420)  Deprecations 👋 The expand_depth and max_expansion arguments for qml.transforms.compile and qml.transforms.decompositions.clifford_t_decomposition respectively have been"
    },
    {
      "id": "qml.circuit_drawer.MPLDrawer",
      "name": "qml.circuit_drawer.MPLDrawer",
      "type": "function",
      "description": "PennyLane API: circuit_drawer.MPLDrawer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "904) ExpvalCost now returns corrects results shape when optimize=True with shots batch. (#1897) qml.circuit_drawer.MPLDrawer was slightly modified to work with matplotlib version 3.5. (#1899) qml.CSWA"
    },
    {
      "id": "qml.ApproxTimeEvolution.compute_decomposition",
      "name": "qml.ApproxTimeEvolution.compute_decomposition",
      "type": "class",
      "description": "PennyLane API: ApproxTimeEvolution.compute_decomposition. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "l.pulse.transmon_interaction and qml.pulse.transmon_drive documentation has been updated. #4327 qml.ApproxTimeEvolution.compute_decomposition() now has a code example. (#4354) The documentation for qm"
    },
    {
      "id": "qml.gradients.",
      "name": "qml.gradients.",
      "type": "function",
      "description": "PennyLane API: gradients.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " Please consider using a different machine learning framework, like PyTorch or JAX. (#7320) The qml.gradients.hamiltonian_grad function has been removed because this gradient recipe is no longer requi"
    },
    {
      "id": "qml.kUpCCGSD.",
      "name": "qml.kUpCCGSD.",
      "type": "function",
      "description": "PennyLane API: kUpCCGSD.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "atching is not supported. (#2900) Fixed a bug where the parameter-shift rule wasn’t defined for qml.kUpCCGSD. (#2913) Reworked the Hermiticity check in qml.Hermitian by using qml.math calls because ca"
    },
    {
      "id": "qml.circuit_drawer.CircuitDrawer",
      "name": "qml.circuit_drawer.CircuitDrawer",
      "type": "function",
      "description": "PennyLane API: circuit_drawer.CircuitDrawer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ces a ComplexWarning when the features parameter is batched and provided as a 2D array. (#1990) qml.circuit_drawer.CircuitDrawer no longer produces an error when attempting to draw tapes inside of cir"
    },
    {
      "id": "qml.FlipSign.",
      "name": "qml.FlipSign.",
      "type": "class",
      "description": "PennyLane API: FlipSign.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".e. wires=[m]). This is different from the previous interpretation of wires=range(m). Also, the qml.FlipSign.wires attribute is now returning the correct Wires object as for all other operations in Pe"
    },
    {
      "id": "qml.transforms.batch_input",
      "name": "qml.transforms.batch_input",
      "type": "function",
      "description": "PennyLane API: transforms.batch_input. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "quantum_fisher to support the new return types. (#3449) Updated qml.transforms.batch_params and qml.transforms.batch_input to support the new return types. (#3431) Updated qml.transforms.cut_circuit a"
    },
    {
      "id": "qml.qchem.givens_decomposition",
      "name": "qml.qchem.givens_decomposition",
      "type": "function",
      "description": "PennyLane API: qchem.givens_decomposition. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ot allowed, and raises an error when calling the function returned by qml.cond. (#7027) (#7051) qml.qchem.givens_decomposition no longer raises a RuntimeWarning when the input is a zero matrix. #7053)"
    },
    {
      "id": "qml.transforms.draw_old",
      "name": "qml.transforms.draw_old",
      "type": "function",
      "description": "PennyLane API: transforms.draw_old. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "emoved because the custom data class was replaced by list of sets of operators or measurements. qml.transforms.draw_old was replaced by qml.draw. qml.CircuitGraph.greedy_layers was deleted, as it was "
    },
    {
      "id": "qml.drawer.CircuitDrawer",
      "name": "qml.drawer.CircuitDrawer",
      "type": "function",
      "description": "PennyLane API: drawer.CircuitDrawer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "re has been removed. (#2310)  RepresentationResolver was replaced by the Operator.label method. qml.drawer.CircuitDrawer was replaced by qml.drawer.tape_text. qml.drawer.CHARSETS was removed because u"
    },
    {
      "id": "qml.labs.zxopt.full_optimize",
      "name": "qml.labs.zxopt.full_optimize",
      "type": "function",
      "description": "PennyLane API: labs.zxopt.full_optimize. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "bmodule zx. The same functions are available, but their signature may have changed.  Instead of qml.labs.zxopt.full_optimize, use optimize_t_count() Instead of qml.labs.zxopt.full_reduce, use reduce_n"
    },
    {
      "id": "qml.drawer.tape_text.",
      "name": "qml.drawer.tape_text.",
      "type": "function",
      "description": "PennyLane API: drawer.tape_text.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ionResolver was replaced by the Operator.label method. qml.drawer.CircuitDrawer was replaced by qml.drawer.tape_text. qml.drawer.CHARSETS was removed because unicode is assumed to be accessible. Grid "
    },
    {
      "id": "qml.gradients.pulse_generator.",
      "name": "qml.gradients.pulse_generator.",
      "type": "function",
      "description": "PennyLane API: gradients.pulse_generator.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " gates to differentiate pulse programs. Access it in your pulse programs by setting diff_method=qml.gradients.pulse_generator. (#4160) qml.pulse.ParametrizedEvolution now uses batched compressed spars"
    },
    {
      "id": "qml.transforms.make_tape.",
      "name": "qml.transforms.make_tape.",
      "type": "function",
      "description": "PennyLane API: transforms.make_tape.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "qscript has been created for converting a quantum function into a quantum script. This replaces qml.transforms.make_tape. (#3429) Add a _pauli_rep attribute to operators to integrate the new Pauli ari"
    },
    {
      "id": "qml.gradients.parameter_shift_hessian",
      "name": "qml.gradients.parameter_shift_hessian",
      "type": "function",
      "description": "PennyLane API: gradients.parameter_shift_hessian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "hould be used instead. (#2654) The module qml.gradients.param_shift_hessian has been renamed to qml.gradients.parameter_shift_hessian in order to distinguish it from the identically named function. No"
    },
    {
      "id": "qml.compiler.python_compiler.visualization",
      "name": "qml.compiler.python_compiler.visualization",
      "type": "function",
      "description": "PennyLane API: compiler.python_compiler.visualization. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ested fixes. (#7916) Two new draw and generate_mlir_graph functions have been introduced in the qml.compiler.python_compiler.visualization module to visualize circuits with the new unified compiler fr"
    },
    {
      "id": "qml.CompilePipeline.",
      "name": "qml.CompilePipeline.",
      "type": "class",
      "description": "PennyLane API: CompilePipeline.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ePipeline class (previously known as the TransformProgram) is now available at the top level as qml.CompilePipeline. Using this class you can now define large and complex compilation pipelines in an i"
    },
    {
      "id": "qml.labs.vibrational.vibrational_pes.",
      "name": "qml.labs.vibrational.vibrational_pes.",
      "type": "function",
      "description": "PennyLane API: labs.vibrational.vibrational_pes.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "th the construction of vibrational Hamiltonians.  Generate potential energy surfaces (PES) with qml.labs.vibrational.vibrational_pes. (#6616) (#6676) >>> symbols  = ['H', 'F'] >>> geometry = np.array("
    },
    {
      "id": "qml.inv",
      "name": "qml.inv",
      "type": "function",
      "description": "PennyLane API: inv. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "th two compilation passes applied: @qml.qjit @qml.transforms.merge_rotations @qml.transforms.cancel_inverses @qml.qnode(dev) def circuit(x):     qml.RX(x, wires=0)     qml.RX(x, wires=0)     qml.X(0) "
    },
    {
      "id": "qml.tape.Unwrap.",
      "name": "qml.tape.Unwrap.",
      "type": "function",
      "description": "PennyLane API: tape.Unwrap.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ce-specific parameters to one with only numpy parameters. This transform is designed to replace qml.tape.Unwrap. (#3899) qml.operation.WiresEnum.AllWires is now -2 instead of 0 to avoid the ambiguity "
    },
    {
      "id": "qml.labs.intermediate_reps.",
      "name": "qml.labs.intermediate_reps.",
      "type": "function",
      "description": "PennyLane API: labs.intermediate_reps.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "perform multiprocess and multithreaded execution. (#7401) A rowcol function is now available in qml.labs.intermediate_reps. Given the parity matrix of a CNOT circuit and a qubit connectivity graph, it"
    },
    {
      "id": "qml.operation.expand_matrix",
      "name": "qml.operation.expand_matrix",
      "type": "function",
      "description": "PennyLane API: operation.expand_matrix. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "sity_matrix measurements now support custom wire labels. (#2779) Add trivial behaviour logic to qml.operation.expand_matrix. (#2785) Added an are_pauli_words_qwc function which checks if certain Pauli"
    },
    {
      "id": "qml.CY.",
      "name": "qml.CY.",
      "type": "class",
      "description": "PennyLane API: CY.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ake custom qubit channels. (#760) (#766) (#778) The controlled-Y operation is now available via qml.CY. For devices that do not natively support the controlled-Y operation, it will be decomposed into "
    },
    {
      "id": "qml.hf.transform_hamiltonian",
      "name": "qml.hf.transform_hamiltonian",
      "type": "function",
      "description": "PennyLane API: hf.transform_hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "or = qml.hf.optimal_sector(H, generators, mol.n_electrons)  # taper the Hamiltonian H_tapered = qml.hf.transform_hamiltonian(H, generators, paulix_ops, opt_sector)   We can compare the number of qubit"
    },
    {
      "id": "qml.Observable",
      "name": "qml.Observable",
      "type": "class",
      "description": "PennyLane API: Observable. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ylane.liealg from pennylane.liealg import lie_closure, structure_constants, center    qml.operation.Observable and the corresponding Observable.compare have been removed, as PennyLane now depends on t"
    },
    {
      "id": "qml.compiler.python_compiler.transforms.MergeRotationsPass",
      "name": "qml.compiler.python_compiler.transforms.MergeRotationsPass",
      "type": "function",
      "description": "PennyLane API: compiler.python_compiler.transforms.MergeRotationsPass. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "lows autograph to transform the user function when transforms are applied to the QNode. (#8307) qml.compiler.python_compiler.transforms.MergeRotationsPass now takes the adjoint property of merged oper"
    },
    {
      "id": "qml.labs.zxopt.full_reduce",
      "name": "qml.labs.zxopt.full_reduce",
      "type": "function",
      "description": "PennyLane API: labs.zxopt.full_reduce. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e may have changed.  Instead of qml.labs.zxopt.full_optimize, use optimize_t_count() Instead of qml.labs.zxopt.full_reduce, use reduce_non_clifford() Instead of qml.labs.zxopt.todd, use todd() Instead"
    },
    {
      "id": "qml.qinfo.trace_distance",
      "name": "qml.qinfo.trace_distance",
      "type": "function",
      "description": "PennyLane API: qinfo.trace_distance. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tance. (#4181) Two cases are enabled for calculating the trace distance:  A QNode transform via qml.qinfo.trace_distance: dev = qml.device('default.qubit', wires=2)  @qml.qnode(dev) def circuit(param)"
    },
    {
      "id": "qml.ops.qubit.attributes",
      "name": "qml.ops.qubit.attributes",
      "type": "function",
      "description": "PennyLane API: ops.qubit.attributes. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "914523336-0.9230449299422961j)*(Identity(wires=[0]))]    The has_unitary_generator attribute in qml.ops.qubit.attributes no longer contains operators with non-unitary generators. (#4183) PennyLane Doc"
    },
    {
      "id": "qml.transforms.cancel_inverses.",
      "name": "qml.transforms.cancel_inverses.",
      "type": "function",
      "description": "PennyLane API: transforms.cancel_inverses.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "els operators appearing consecutively that are adjoints of each other following the same API as qml.transforms.cancel_inverses. (#6692) qml.capture.transforms.DecomposeInterpreter: this class decompos"
    },
    {
      "id": "qml.ops.op_math.Evolution.",
      "name": "qml.ops.op_math.Evolution.",
      "type": "function",
      "description": "PennyLane API: ops.op_math.Evolution.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", 0.        +0.j        ], requires_grad=True)    Create operators defined from a generator via qml.ops.op_math.Evolution. (#3375) qml.ops.op_math.Evolution defines the exponential of an operator $hat"
    },
    {
      "id": "qml.prob",
      "name": "qml.prob",
      "type": "function",
      "description": "PennyLane API: prob. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "RX(x, wires=0)     qml.RX(x, wires=0)     qml.X(0)     qml.X(0)     qml.CNOT([0, 1])     return qml.probs()   The supplied level to pennylane.specs() may be individual int values, or an iterable of mu"
    },
    {
      "id": "qml.optimize.AdaptiveOptimizer",
      "name": "qml.optimize.AdaptiveOptimizer",
      "type": "function",
      "description": "PennyLane API: optimize.AdaptiveOptimizer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", the optimizer is instantiated and then the circuit is created and optimized adaptively: opt = qml.optimize.AdaptiveOptimizer() for i in range(len(operator_pool)):     circuit, energy, gradient = opt"
    },
    {
      "id": "qml.is_hermitian.",
      "name": "qml.is_hermitian.",
      "type": "function",
      "description": "PennyLane API: is_hermitian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ing instead of an error. To definitively determine whether or not an operator is hermitian, use qml.is_hermitian. (#2960) The ControlledOperation class has been removed. This was a developer-only clas"
    },
    {
      "id": "qml.utils.pauli_eigs",
      "name": "qml.utils.pauli_eigs",
      "type": "function",
      "description": "PennyLane API: utils.pauli_eigs. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ng._unflatten_np respectively. qml.utils._inv_dict and qml._get_default_args have been removed. qml.utils.pauli_eigs has been moved to qml.pauli.utils. qml.utils.expand_vector has been moved to qml.ma"
    },
    {
      "id": "qml.tape.QuantumTape.draw",
      "name": "qml.tape.QuantumTape.draw",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape.draw. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "of that situation. qml.CircuitGraph.draw was deleted, as we draw tapes instead. The tape method qml.tape.QuantumTape.draw now simply calls qml.drawer.tape_text. In the new pathway, the charset keyword"
    },
    {
      "id": "qml.cond.",
      "name": "qml.cond.",
      "type": "function",
      "description": "PennyLane API: cond.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ts. It is now explicitly not allowed, and raises an error when calling the function returned by qml.cond. (#7027) (#7051) qml.qchem.givens_decomposition no longer raises a RuntimeWarning when the inpu"
    },
    {
      "id": "qml.tape.tape.rotations_and_diagonal_measurements",
      "name": "qml.tape.tape.rotations_and_diagonal_measurements",
      "type": "function",
      "description": "PennyLane API: tape.tape.rotations_and_diagonal_measurements. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "meters instead of qml.tape.Unwrap. (#3989) A sub-routine of expand_tape has been converted into qml.tape.tape.rotations_and_diagonal_measurements, a helper function that computes rotations and diagona"
    },
    {
      "id": "qml.beta.qnode",
      "name": "qml.beta.qnode",
      "type": "function",
      "description": "PennyLane API: beta.qnode. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "pes]  @qml.transforms.mitigate_with_zne([1, 2, 3], fold_global, RichardsonFactory.extrapolate) @qml.beta.qnode(dev) def circuit(w1, w2):     qml.SimplifiedTwoDesign(w1, w2, wires=range(2))     return "
    },
    {
      "id": "qml.tape_mode_active",
      "name": "qml.tape_mode_active",
      "type": "function",
      "description": "PennyLane API: tape_mode_active. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "on import location. In addition,  All tape-mode functions have been removed (qml.enable_tape(), qml.tape_mode_active()), All tape fixtures have been deleted, Tests specifically for non-tape mode have "
    },
    {
      "id": "qml.operation.has_gen",
      "name": "qml.operation.has_gen",
      "type": "function",
      "description": "PennyLane API: operation.has_gen. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rator. It returns whether or not the Operator has a generator defined. has_generator is used in qml.operation.has_gen, which improves its performance and extends differentiation support. (#3875) The p"
    },
    {
      "id": "qml.circuit_drawer.MPLDrawer.",
      "name": "qml.circuit_drawer.MPLDrawer.",
      "type": "function",
      "description": "PennyLane API: circuit_drawer.MPLDrawer.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ned unsorted by Tape.get_parameters. (#1836) Fixes a bug with the arrow width in the measure of qml.circuit_drawer.MPLDrawer. (#1823) The helper functions qml.math.block_diag and qml.math.scatter_elem"
    },
    {
      "id": "qml.qinfo.vn_entanglement_entropy",
      "name": "qml.qinfo.vn_entanglement_entropy",
      "type": "function",
      "description": "PennyLane API: qinfo.vn_entanglement_entropy. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "es the von Neumann entanglement entropy from a density matrix. A corresponding QNode transform, qml.qinfo.vn_entanglement_entropy, has also been added. (#5306) qml.draw and qml.draw_mpl will now attem"
    },
    {
      "id": "qml.hf.generate_hamiltonian",
      "name": "qml.hf.generate_hamiltonian",
      "type": "function",
      "description": "PennyLane API: hf.generate_hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "632]]) mol = qml.hf.Molecule(symbols, geometry, charge=1)  # generate the qubit Hamiltonian H = qml.hf.generate_hamiltonian(mol)(geometry)  # determine Hamiltonian symmetries generators, paulix_ops = "
    },
    {
      "id": "qml.ops.functions.bind_new_parameters.",
      "name": "qml.ops.functions.bind_new_parameters.",
      "type": "function",
      "description": "PennyLane API: ops.functions.bind_new_parameters.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d the skip_first option in expand_tape_state_prep. (#4564) convert_to_numpy_parameters now uses qml.ops.functions.bind_new_parameters. This reinitializes the operation and makes sure everything refere"
    },
    {
      "id": "qml.christiansen_mapping.",
      "name": "qml.christiansen_mapping.",
      "type": "function",
      "description": "PennyLane API: christiansen_mapping.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "sonic operators to qubit operators is available with qml.unary_mapping, qml.binary_mapping, and qml.christiansen_mapping. (#6623) (#6576) (#6564) All three mappings follow the same syntax, where a qml"
    },
    {
      "id": "qml.QutritUnitary.",
      "name": "qml.QutritUnitary.",
      "type": "class",
      "description": "PennyLane API: QutritUnitary.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "cuit() -0.42264973081037416    Controlled qutrit operations can now be performed with qml.ControlledQutritUnitary. (#2844) The control wires and values that define the operation are defined analogousl"
    },
    {
      "id": "qml.templates.ApproxTimeEvolution",
      "name": "qml.templates.ApproxTimeEvolution",
      "type": "function",
      "description": "PennyLane API: templates.ApproxTimeEvolution. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ml.PauliX(1)]  @qml.qnode(dev) def circuit(coeffs, t):     H = qml.Hamiltonian(coeffs, obs)     qml.templates.ApproxTimeEvolution(H, t, 2)     return qml.expval(qml.PauliZ(0))   >>> t = np.array(0.54,"
    },
    {
      "id": "qml.gradients.gradient_transform",
      "name": "qml.gradients.gradient_transform",
      "type": "function",
      "description": "PennyLane API: gradients.gradient_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " is extremely expensive, and the definition is ambiguous for non-commuting observables. (#7047) qml.gradients.gradient_transform.choose_trainable_params has been renamed to choose_trainable_param_indi"
    },
    {
      "id": "qml.circuit_drawer.drawable_layers",
      "name": "qml.circuit_drawer.drawable_layers",
      "type": "function",
      "description": "PennyLane API: circuit_drawer.drawable_layers. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ports the qml.qnn module. (#1748) @qml.beta.QNode now supports the qml.specs transform. (#1739) qml.circuit_drawer.drawable_layers and qml.circuit_drawer.drawable_grid process a list of operations to "
    },
    {
      "id": "qml.trotterize.",
      "name": "qml.trotterize.",
      "type": "function",
      "description": "PennyLane API: trotterize.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tem hamiltonians can now be encoded into circuits with the addition of qml.TrotterizedQfunc and qml.trotterize. This allows for custom specification of the first-order expansion of the Suzuki-Trotter "
    },
    {
      "id": "qml.gradients.quantum_fisher.",
      "name": "qml.gradients.quantum_fisher.",
      "type": "function",
      "description": "PennyLane API: gradients.quantum_fisher.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " qml.qinfo.quantum_fisher have been deprecated. Instead, use qml.gradients.classical_fisher and qml.gradients.quantum_fisher. (#5985) The legacy devices default.qubit.{autograd,torch,tf,jax,legacy} ha"
    },
    {
      "id": "qml.estimator.PauliHamiltonian",
      "name": "qml.estimator.PauliHamiltonian",
      "type": "function",
      "description": "PennyLane API: estimator.PauliHamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "#8561) Users can now estimate the resources of Trotterization for Pauli Hamiltonians, using the new estimator.PauliHamiltonian resource Hamiltonian class and the new estimator.TrotterPauli resource op"
    },
    {
      "id": "qml.QNGOptimizer.",
      "name": "qml.QNGOptimizer.",
      "type": "class",
      "description": "PennyLane API: QNGOptimizer.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ease saw the addition of the QNGOptimizerQJIT optimizer, which is a qml.qjit-compatible analogue to QNGOptimizer. In this release, we’ve added the MomentumQNGOptimizerQJIT optimizer, which is the qml."
    },
    {
      "id": "qml.QDrift.",
      "name": "qml.QDrift.",
      "type": "class",
      "description": "PennyLane API: QDrift.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rror instead of ignoring the input. (#5748) A custom decomposition can no longer be provided to qml.QDrift. Instead, apply the operations in your custom operation directly with qml.apply. (#5698) Samp"
    },
    {
      "id": "qml.transform.insert",
      "name": "qml.transform.insert",
      "type": "function",
      "description": "PennyLane API: transform.insert. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "with grouped observables are now allowed to be measured on devices which were transformed using qml.transform.insert(). (#2857) Fixed a bug where qml.batch_input raised an error when using a batched o"
    },
    {
      "id": "qml.liealg.",
      "name": "qml.liealg.",
      "type": "function",
      "description": "PennyLane API: liealg.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "pplied. Instead, the device will be responsible for all MCM handling. (#7243) Fixed coverage of qml.liealg.CII and qml.liealg.AIII. (#7291) Fixed a bug where the phase is used as the wire label for a "
    },
    {
      "id": "qml.vqe.Hamiltonian",
      "name": "qml.vqe.Hamiltonian",
      "type": "function",
      "description": "PennyLane API: vqe.Hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "unwrapping non-differentiable PennyLane tensors, which can cause issues on some devices. (#941) qml.vqe.Hamiltonian prints any observable with any number of strings. (#987) Fixes a bug where parameter"
    },
    {
      "id": "qml.qcut.",
      "name": "qml.qcut.",
      "type": "function",
      "description": "PennyLane API: qcut.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "with lightning if qml.metric_tensor is in the transform program. (#5624) Stopped printing the ID of qcut.MeasureNode and qcut.PrepareNode in tape drawing. (#5613) Improves the error message for settin"
    },
    {
      "id": "qml.devices.qutrit_mixed",
      "name": "qml.devices.qutrit_mixed",
      "type": "function",
      "description": "PennyLane API: devices.qutrit_mixed. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "s True). (#6410) A new function called sample_probs has been added to the qml.devices.qubit and qml.devices.qutrit_mixed modules. This function takes probability distributions as input and returns sam"
    },
    {
      "id": "qml.liealg.check_abelian.",
      "name": "qml.liealg.check_abelian.",
      "type": "function",
      "description": "PennyLane API: liealg.check_abelian.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "n Abelian subalgebra of m, and we can confirm that all elements in a are mutually commuting via qml.liealg.check_abelian. >>> qml.liealg.check_abelian(a) True    The following functions have also been"
    },
    {
      "id": "qml.resource.FirstQuantization.gate_cost",
      "name": "qml.resource.FirstQuantization.gate_cost",
      "type": "function",
      "description": "PennyLane API: resource.FirstQuantization.gate_cost. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "c methods: >>> qml.resource.FirstQuantization.qubit_cost(100000, 156, 169.69608, 0.01) 4377 >>> qml.resource.FirstQuantization.gate_cost(100000, 156, 169.69608, 0.01) 3676557345574     Differentiable "
    },
    {
      "id": "qml.ops.Hamiltonian",
      "name": "qml.ops.Hamiltonian",
      "type": "function",
      "description": "PennyLane API: ops.Hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tions, and avoids confusion. (#6590) Legacy operator arithmetic has been removed. This includes qml.ops.Hamiltonian, qml.operation.Tensor, qml.operation.enable_new_opmath, qml.operation.disable_new_op"
    },
    {
      "id": "qml.pauli.PauliSentence.operation",
      "name": "qml.pauli.PauliSentence.operation",
      "type": "function",
      "description": "PennyLane API: pauli.PauliSentence.operation. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "tence.hamiltonian and qml.pauli.PauliWord.hamiltonian have been deprecated. Instead, please use qml.pauli.PauliSentence.operation and qml.pauli.PauliWord.operation, respectively. (#6287) qml.pauli.sim"
    },
    {
      "id": "qml.transforms.qcut",
      "name": "qml.transforms.qcut",
      "type": "function",
      "description": "PennyLane API: transforms.qcut. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ule and is now accessible as qml.gradients.classical_jacobian. (#4900) The transforms submodule qml.transforms.qcut is now its own module: qml.qcut. (#4819) The decomposition of GroverOperator now has"
    },
    {
      "id": "qml._current_context",
      "name": "qml._current_context",
      "type": "function",
      "description": "PennyLane API: _current_context. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "er form RY @ CNOT @ RY @ CNOT (#547) The underlying queuing system was refactored, removing the qml._current_context property that held the currently active QNode or OperationRecorder. Now, all object"
    },
    {
      "id": "qml.CircuitGraph.draw",
      "name": "qml.CircuitGraph.draw",
      "type": "class",
      "description": "PennyLane API: CircuitGraph.draw. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "no longer needed by the circuit drawer and did not seem to have uses outside of that situation. qml.CircuitGraph.draw was deleted, as we draw tapes instead. The tape method qml.tape.QuantumTape.draw n"
    },
    {
      "id": "qml.qchem.mol_data.",
      "name": "qml.qchem.mol_data.",
      "type": "function",
      "description": "PennyLane API: qchem.mol_data.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "orkflows. (#8219) (#8273) Support for pubchempy has been updated to 1.0.5 in the unit tests for qml.qchem.mol_data. (#8224) A nightly RC builds script has been added to .github/workflows. (#8148) The "
    },
    {
      "id": "qml.QubitDensityMatrix.",
      "name": "qml.QubitDensityMatrix.",
      "type": "class",
      "description": "PennyLane API: QubitDensityMatrix.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "has been added to allow for initializing a circuit with a density matrix using qml.StatePrep or qml.QubitDensityMatrix. (#6503) Several additions have been made to eventually migrate the \"default.mixe"
    },
    {
      "id": "qml.GellMann.",
      "name": "qml.GellMann.",
      "type": "class",
      "description": "PennyLane API: GellMann.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ct comparison between instances of qml.GellMann, as well as Hamiltonians and Tensors containing qml.GellMann. (#4366) qml.transforms.merge_amplitude_embedding now works correctly when the AmplitudeEmb"
    },
    {
      "id": "qml.FlipSign.wires",
      "name": "qml.FlipSign.wires",
      "type": "class",
      "description": "PennyLane API: FlipSign.wires. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ".e. wires=[m]). This is different from the previous interpretation of wires=range(m). Also, the qml.FlipSign.wires attribute is now returning the correct Wires object as for all other operations in Pe"
    },
    {
      "id": "qml.drawer.tape_mpl.",
      "name": "qml.drawer.tape_mpl.",
      "type": "function",
      "description": "PennyLane API: drawer.tape_mpl.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " decomposition. (#3676) Fixed a bug that made tapes/qnodes using qml.Snapshot incompatible with qml.drawer.tape_mpl. (#3704) Tensor._pauli_rep is set to None during initialization and Tensor.data has "
    },
    {
      "id": "qml.QueuingContext",
      "name": "qml.QueuingContext",
      "type": "class",
      "description": "PennyLane API: QueuingContext. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " instead qml.tape.QuantumTape.stop_recording(): Use qml.QueuingManager.stop_recording() instead qml.QueuingContext is now qml.QueuingManager QueuingManager.safe_update_info and AnnotatedQueue.safe_upd"
    },
    {
      "id": "qml.utils._flatten",
      "name": "qml.utils._flatten",
      "type": "function",
      "description": "PennyLane API: utils._flatten. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d. (#6588): Specifically, the following 4 sets of functions have been either moved or removed:  qml.utils._flatten, qml.utils.unflatten has been moved and renamed to qml.optimize.qng._flatten_np and q"
    },
    {
      "id": "qml.transforms.Conditional",
      "name": "qml.transforms.Conditional",
      "type": "function",
      "description": "PennyLane API: transforms.Conditional. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "the Conditional operation have been moved from the transforms folder to the ops/op_math folder. qml.transforms.Conditional will now be available as qml.ops.Conditional. (#4860) The prep keyword argume"
    },
    {
      "id": "qml.utils",
      "name": "qml.utils",
      "type": "function",
      "description": "PennyLane API: utils. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " like to get the canonical interface you can simply use the Enum: >>> from pennylane.math.interface_utils import Interface >>> Interface(\"torch\") <Interface.TORCH: 'torch'> >>> Interface(\"jax-jit\") <I"
    },
    {
      "id": "qml.TorchLayer",
      "name": "qml.TorchLayer",
      "type": "class",
      "description": "PennyLane API: TorchLayer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "fined/correct in general. Adjoints of fractional powers can no longer be evaluated. (#5835) qml.qnn.TorchLayer now works with tuple returns. (#5816) An error is now raised if a transform is applied to"
    },
    {
      "id": "qml.tape.QuantumTape.adjoint",
      "name": "qml.tape.QuantumTape.adjoint",
      "type": "function",
      "description": "PennyLane API: tape.QuantumTape.adjoint. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "qml.transforms.qcut.remap_tape_wires: Use qml.map_wires instead qml.tape.QuantumTape.inv(): Use qml.tape.QuantumTape.adjoint() instead qml.tape.stop_recording(): Use qml.QueuingManager.stop_recording("
    },
    {
      "id": "qml.drawer.drawable_grid",
      "name": "qml.drawer.drawable_grid",
      "type": "function",
      "description": "PennyLane API: drawer.drawable_grid. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ape_text. qml.drawer.CHARSETS was removed because unicode is assumed to be accessible. Grid and qml.drawer.drawable_grid were removed because the custom data class was replaced by list of sets of oper"
    },
    {
      "id": "qml.math.safe_squeeze",
      "name": "qml.math.safe_squeeze",
      "type": "function",
      "description": "PennyLane API: math.safe_squeeze. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "are detected, instead of silently skipping update steps for all arguments. (#2109) The function qml.math.safe_squeeze is introduced and gradient_transform allows for QNode argument axes of size 1. (#2"
    },
    {
      "id": "qml.utils.expand_vector",
      "name": "qml.utils.expand_vector",
      "type": "function",
      "description": "PennyLane API: utils.expand_vector. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ml._get_default_args have been removed. qml.utils.pauli_eigs has been moved to qml.pauli.utils. qml.utils.expand_vector has been moved to qml.math.expand_vector.   The qml.qinfo module has been remove"
    },
    {
      "id": "qml.StatePrep.",
      "name": "qml.StatePrep.",
      "type": "class",
      "description": "PennyLane API: StatePrep.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ifferentiation method. (#6535) The qml.QubitStateVector template has been removed. Instead, use qml.StatePrep. (#6525) qml.broadcast has been removed. Users should use for loops instead. (#6527) The m"
    },
    {
      "id": "qml.labs.ResourceOperator",
      "name": "qml.labs.ResourceOperator",
      "type": "function",
      "description": "PennyLane API: labs.ResourceOperator. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "erator type and parameters for the purposes of resource estimation. (#7408) A base class called qml.labs.ResourceOperator has been added which will be used to implement all quantum operators for resou"
    },
    {
      "id": "qml.beta.QNode",
      "name": "qml.beta.QNode",
      "type": "function",
      "description": "PennyLane API: beta.QNode. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": ", custom quantum gradient support, and arbitrary order derivatives. This QNode is available via qml.beta.QNode, and @qml.beta.qnode. (#1642) (#1646) (#1651) (#1804) It differs from the standard QNode "
    },
    {
      "id": "qml.SPSAOptimizer.",
      "name": "qml.SPSAOptimizer.",
      "type": "class",
      "description": "PennyLane API: SPSAOptimizer.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " wire_order keyword argument over wires. (#4424) op.adjoint has been replaced with qml.adjoint in QNSPSAOptimizer. (#4421) jax.ad (deprecated) has been replaced by jax.interpreters.ad. (#4403) metric_"
    },
    {
      "id": "qml.AQFT.",
      "name": "qml.AQFT.",
      "type": "class",
      "description": "PennyLane API: AQFT.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "rformance boost. (#4662) The Approximate Quantum Fourier Transform (AQFT) is now available with qml.AQFT. (#4715) qml.draw and qml.draw_mpl now render operator IDs. (#4749) The ID can be specified as "
    },
    {
      "id": "qml.qaoa.mixer_layer",
      "name": "qml.qaoa.mixer_layer",
      "type": "function",
      "description": "PennyLane API: qaoa.mixer_layer. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " with the same hash as Sum‘s with different numbers of repeats. (#5851) qml.qaoa.cost_layer and qml.qaoa.mixer_layer can now be used with Sum operators. (#5846) Fixed a bug where qml.MottonenStatePrep"
    },
    {
      "id": "qml.math.sqrt_matrix_sparse",
      "name": "qml.math.sqrt_matrix_sparse",
      "type": "function",
      "description": "PennyLane API: math.sqrt_matrix_sparse. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "   1 (1, 1)    1 (2, 3)    1 (3, 2)    1    Sparse functionality is now available in qml.math:  qml.math.sqrt_matrix_sparse is available to compute the square root of a sparse Hermitian matrix. (#6976"
    },
    {
      "id": "qml.interfaces.set_shots",
      "name": "qml.interfaces.set_shots",
      "type": "function",
      "description": "PennyLane API: interfaces.set_shots. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "e machine learning boundary functions are now uncoupled from their legacy counterparts. (#4415) qml.interfaces.set_shots now accepts a Shots object as well as int‘s and tuples of int‘s. (#4388) Readab"
    },
    {
      "id": "qml.qinfo.fidelity",
      "name": "qml.qinfo.fidelity",
      "type": "function",
      "description": "PennyLane API: qinfo.fidelity. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "gradient [ 0.59422561 -0.02615095 -0.03989212]    The fidelity between two arbitrary states via qml.qinfo.fidelity: dev = qml.device('default.qubit', wires=1)  @qml.qnode(dev) def circuit_rx(x):     q"
    },
    {
      "id": "qml.ops.op_math.ControlledOp.",
      "name": "qml.ops.op_math.ControlledOp.",
      "type": "function",
      "description": "PennyLane API: ops.op_math.ControlledOp.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "d from qml.ops.qubit.non_parametric_ops to qml.ops.op_math.controlled_ops and now inherits from qml.ops.op_math.ControlledOp. (#4116) qml.CZ now inherits from the ControlledOp class and supports expon"
    },
    {
      "id": "qml.batch_transform",
      "name": "qml.batch_transform",
      "type": "function",
      "description": "PennyLane API: batch_transform. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "faces. (#6207) (#6208) (#6209) (#6210) (#6266) expand_fn, max_expansion, override_shots, and device_batch_transform have been removed from the signature of qml.execute. (#6203) max_expansion and expan"
    },
    {
      "id": "qml.operation.gen_is_multi_term_hamiltonian",
      "name": "qml.operation.gen_is_multi_term_hamiltonian",
      "type": "function",
      "description": "PennyLane API: operation.gen_is_multi_term_hamiltonian. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": " gate generators are defined using different PennyLane operators. This was resolved by updating qml.operation.gen_is_multi_term_hamiltonian to work with more complicated generators. (#7121) Modulo ope"
    },
    {
      "id": "qml.Superposition.",
      "name": "qml.Superposition.",
      "type": "class",
      "description": "PennyLane API: Superposition.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "reparation, CosineWindow, AmplitudeAmplification, Permute, AQFT, FlipSign, FABLE, Qubitization, and Superposition.  Two additions were made to Select, significantly improving its decomposition:  A new"
    },
    {
      "id": "qml.SingleExcitation.",
      "name": "qml.SingleExcitation.",
      "type": "class",
      "description": "PennyLane API: SingleExcitation.. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ion to qml.SingleExcitation has been added that halves the number of CNOTs required. (3976) >>> qml.SingleExcitation.compute_decomposition(1.23, wires=(0,1)) [Adjoint(T(wires=[0])), Hadamard(wires=[0]"
    },
    {
      "id": "qml.labs.AllocWires",
      "name": "qml.labs.AllocWires",
      "type": "function",
      "description": "PennyLane API: labs.AllocWires. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "lementation of the parity matrix that respects the connectivity. (#7394) qml.labs.QubitManager, qml.labs.AllocWires, and qml.labs.FreeWires classes have been added to track and manage auxiliary qubits"
    },
    {
      "id": "qml.optimize.qng._unflatten_np",
      "name": "qml.optimize.qng._unflatten_np",
      "type": "function",
      "description": "PennyLane API: optimize.qng._unflatten_np. Found in release_notes.html",
      "source_file": "release_notes.html",
      "context": "ls._flatten, qml.utils.unflatten has been moved and renamed to qml.optimize.qng._flatten_np and qml.optimize.qng._unflatten_np respectively. qml.utils._inv_dict and qml._get_default_args have been rem"
    },
    {
      "id": "qml.default_config.path",
      "name": "qml.default_config.path",
      "type": "function",
      "description": "PennyLane API: default_config.path. Found in configuration.html",
      "source_file": "configuration.html",
      "context": "n.shots\"]), and save/load new configuration files. For example: >>> import pennylane as qml >>> qml.default_config.path 'config.toml' >>> print(qml.default_config) {'main': {'shots': 1000},  'default'"
    },
    {
      "id": "qiskit.readthedocs.io",
      "name": "qiskit.readthedocs.io",
      "type": "function",
      "description": "Qiskit API: readthedocs.io. Found in configuration.html",
      "source_file": "configuration.html",
      "context": "wberry Fields plugin # For more details, see the PennyLane-SF documentation: # https://pennylane-sf.readthedocs.io hbar = 2 shots = 100      [strawberryfields.fock]     # Options for the strawberryfie"
    },
    {
      "id": "qiskit.global",
      "name": "qiskit.global",
      "type": "function",
      "description": "Qiskit API: global. Found in configuration.html",
      "source_file": "configuration.html",
      "context": "le config.toml uses the TOML standard. See the following example configuration that configures some global options, as well as plugin and plugin device-specific options. [main] # Global PennyLane opti"
    },
    {
      "id": "qiskit.ibmq",
      "name": "qiskit.ibmq",
      "type": "function",
      "description": "Qiskit API: ibmq. Found in configuration.html",
      "source_file": "configuration.html",
      "context": "    # using '=' rather than ':'.     backend_options = {\"validation_threshold\" = 1e-6}      [qiskit.ibmq]     # Default options for IBMQ      # IBM Quantum Experience authentication token     ibmqx_to"
    },
    {
      "id": "qml.math.SUPPORTED_INTERFACE_NAMES",
      "name": "qml.math.SUPPORTED_INTERFACE_NAMES",
      "type": "function",
      "description": "PennyLane API: math.SUPPORTED_INTERFACE_NAMES. Found in interfaces.html",
      "source_file": "interfaces.html",
      "context": "ll automatically determine the interface based on provided arguments and keyword arguments. See qml.math.SUPPORTED_INTERFACE_NAMES for a list of all accepted interface strings.   Warning ComplexWarnin"
    },
    {
      "id": "qml.templates.layer.",
      "name": "qml.templates.layer.",
      "type": "function",
      "description": "PennyLane API: templates.layer.. Found in templates.html",
      "source_file": "templates.html",
      "context": "equence of quantum gates to a set of wires. You can import this function both via qml.layer and qml.templates.layer.       pennylane.layer(template, depth, *args, **kwargs) Repeatedly applies a unitar"
    },
    {
      "id": "qml.ops.Hamiltonian.",
      "name": "qml.ops.Hamiltonian.",
      "type": "function",
      "description": "PennyLane API: ops.Hamiltonian.. Found in new_opmath.html",
      "source_file": "new_opmath.html",
      "context": ".operands instead. op = X(0) @ X(1) assert op.operands == (X(0), X(1))    Check explicit use of qml.ops.Hamiltonian. In that case, simply change to qml.Hamiltonian. This will dispatch to the LinearCom"
    },
    {
      "id": "qml.for_loop.",
      "name": "qml.for_loop.",
      "type": "function",
      "description": "PennyLane API: for_loop.. Found in program_capture_sharp_bits.html",
      "source_file": "program_capture_sharp_bits.html",
      "context": " error will be raised. Consider this QNode that has a dynamic argument corresponding to stop in qml.for_loop. import pennylane as qml  @shift_rx_to_end @qml.qnode(qml.device(\"default.qubit\", wires=4))"
    }
  ],
  "edges": []
}